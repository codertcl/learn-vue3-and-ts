/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* binding */ WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* binding */ buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* binding */ extractIdentifiers),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* binding */ getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* binding */ isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* binding */ isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* binding */ isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* binding */ isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* binding */ isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* binding */ isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* binding */ isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "makeBlock": () => (/* binding */ makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* binding */ walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* binding */ walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* binding */ walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _errorMessages, _helperNameMap, _deprecationData;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function defaultOnError(error) {
  throw error;
}

function defaultOnWarn(msg) {
   true && console.warn("[Vue warn] ".concat(msg.message));
}

function createCompilerError(code, loc, messages, additionalMessage) {
  var msg =  true ? (messages || errorMessages)[code] + (additionalMessage || "") : 0;
  var error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}

var errorMessages = (_errorMessages = {}, _defineProperty(_errorMessages, 0
/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
, 'Illegal comment.'), _defineProperty(_errorMessages, 1
/* CDATA_IN_HTML_CONTENT */
, 'CDATA section is allowed only in XML context.'), _defineProperty(_errorMessages, 2
/* DUPLICATE_ATTRIBUTE */
, 'Duplicate attribute.'), _defineProperty(_errorMessages, 3
/* END_TAG_WITH_ATTRIBUTES */
, 'End tag cannot have attributes.'), _defineProperty(_errorMessages, 4
/* END_TAG_WITH_TRAILING_SOLIDUS */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 5
/* EOF_BEFORE_TAG_NAME */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 6
/* EOF_IN_CDATA */
, 'Unexpected EOF in CDATA section.'), _defineProperty(_errorMessages, 7
/* EOF_IN_COMMENT */
, 'Unexpected EOF in comment.'), _defineProperty(_errorMessages, 8
/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
, 'Unexpected EOF in script.'), _defineProperty(_errorMessages, 9
/* EOF_IN_TAG */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 10
/* INCORRECTLY_CLOSED_COMMENT */
, 'Incorrectly closed comment.'), _defineProperty(_errorMessages, 11
/* INCORRECTLY_OPENED_COMMENT */
, 'Incorrectly opened comment.'), _defineProperty(_errorMessages, 12
/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
, "Illegal tag name. Use '&lt;' to print '<'."), _defineProperty(_errorMessages, 13
/* MISSING_ATTRIBUTE_VALUE */
, 'Attribute value was expected.'), _defineProperty(_errorMessages, 14
/* MISSING_END_TAG_NAME */
, 'End tag name was expected.'), _defineProperty(_errorMessages, 15
/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
, 'Whitespace was expected.'), _defineProperty(_errorMessages, 16
/* NESTED_COMMENT */
, "Unexpected '<!--' in comment."), _defineProperty(_errorMessages, 17
/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
, 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).'), _defineProperty(_errorMessages, 18
/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
, 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).'), _defineProperty(_errorMessages, 19
/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
, "Attribute name cannot start with '='."), _defineProperty(_errorMessages, 21
/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
, "'<?' is allowed only in XML context."), _defineProperty(_errorMessages, 20
/* UNEXPECTED_NULL_CHARACTER */
, "Unexpected null character."), _defineProperty(_errorMessages, 22
/* UNEXPECTED_SOLIDUS_IN_TAG */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 23
/* X_INVALID_END_TAG */
, 'Invalid end tag.'), _defineProperty(_errorMessages, 24
/* X_MISSING_END_TAG */
, 'Element is missing end tag.'), _defineProperty(_errorMessages, 25
/* X_MISSING_INTERPOLATION_END */
, 'Interpolation end sign was not found.'), _defineProperty(_errorMessages, 27
/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
, 'End bracket for dynamic directive argument was not found. ' + 'Note that dynamic directive argument cannot contain spaces.'), _defineProperty(_errorMessages, 26
/* X_MISSING_DIRECTIVE_NAME */
, 'Legal directive name was expected.'), _defineProperty(_errorMessages, 28
/* X_V_IF_NO_EXPRESSION */
, "v-if/v-else-if is missing expression."), _defineProperty(_errorMessages, 29
/* X_V_IF_SAME_KEY */
, "v-if/else branches must use unique keys."), _defineProperty(_errorMessages, 30
/* X_V_ELSE_NO_ADJACENT_IF */
, "v-else/v-else-if has no adjacent v-if or v-else-if."), _defineProperty(_errorMessages, 31
/* X_V_FOR_NO_EXPRESSION */
, "v-for is missing expression."), _defineProperty(_errorMessages, 32
/* X_V_FOR_MALFORMED_EXPRESSION */
, "v-for has invalid expression."), _defineProperty(_errorMessages, 33
/* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
, "<template v-for> key should be placed on the <template> tag."), _defineProperty(_errorMessages, 34
/* X_V_BIND_NO_EXPRESSION */
, "v-bind is missing expression."), _defineProperty(_errorMessages, 35
/* X_V_ON_NO_EXPRESSION */
, "v-on is missing expression."), _defineProperty(_errorMessages, 36
/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
, "Unexpected custom directive on <slot> outlet."), _defineProperty(_errorMessages, 37
/* X_V_SLOT_MIXED_SLOT_USAGE */
, "Mixed v-slot usage on both the component and nested <template>." + "When there are multiple named slots, all slots should use <template> " + "syntax to avoid scope ambiguity."), _defineProperty(_errorMessages, 38
/* X_V_SLOT_DUPLICATE_SLOT_NAMES */
, "Duplicate slot names found. "), _defineProperty(_errorMessages, 39
/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
, "Extraneous children found when component already has explicitly named " + "default slot. These children will be ignored."), _defineProperty(_errorMessages, 40
/* X_V_SLOT_MISPLACED */
, "v-slot can only be used on components or <template> tags."), _defineProperty(_errorMessages, 41
/* X_V_MODEL_NO_EXPRESSION */
, "v-model is missing expression."), _defineProperty(_errorMessages, 42
/* X_V_MODEL_MALFORMED_EXPRESSION */
, "v-model value must be a valid JavaScript member expression."), _defineProperty(_errorMessages, 43
/* X_V_MODEL_ON_SCOPE_VARIABLE */
, "v-model cannot be used on v-for or v-slot scope variables because they are not writable."), _defineProperty(_errorMessages, 44
/* X_INVALID_EXPRESSION */
, "Error parsing JavaScript expression: "), _defineProperty(_errorMessages, 45
/* X_KEEP_ALIVE_INVALID_CHILDREN */
, "<KeepAlive> expects exactly one child component."), _defineProperty(_errorMessages, 46
/* X_PREFIX_ID_NOT_SUPPORTED */
, "\"prefixIdentifiers\" option is not supported in this build of compiler."), _defineProperty(_errorMessages, 47
/* X_MODULE_MODE_NOT_SUPPORTED */
, "ES module mode is not supported in this build of compiler."), _defineProperty(_errorMessages, 48
/* X_CACHE_HANDLER_NOT_SUPPORTED */
, "\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled."), _defineProperty(_errorMessages, 49
/* X_SCOPE_ID_NOT_SUPPORTED */
, "\"scopeId\" option is only supported in module mode."), _defineProperty(_errorMessages, 50
/* __EXTEND_POINT__ */
, ""), _errorMessages);
var FRAGMENT = Symbol( true ? "Fragment" : 0);
var TELEPORT = Symbol( true ? "Teleport" : 0);
var SUSPENSE = Symbol( true ? "Suspense" : 0);
var KEEP_ALIVE = Symbol( true ? "KeepAlive" : 0);
var BASE_TRANSITION = Symbol( true ? "BaseTransition" : 0);
var OPEN_BLOCK = Symbol( true ? "openBlock" : 0);
var CREATE_BLOCK = Symbol( true ? "createBlock" : 0);
var CREATE_ELEMENT_BLOCK = Symbol( true ? "createElementBlock" : 0);
var CREATE_VNODE = Symbol( true ? "createVNode" : 0);
var CREATE_ELEMENT_VNODE = Symbol( true ? "createElementVNode" : 0);
var CREATE_COMMENT = Symbol( true ? "createCommentVNode" : 0);
var CREATE_TEXT = Symbol( true ? "createTextVNode" : 0);
var CREATE_STATIC = Symbol( true ? "createStaticVNode" : 0);
var RESOLVE_COMPONENT = Symbol( true ? "resolveComponent" : 0);
var RESOLVE_DYNAMIC_COMPONENT = Symbol( true ? "resolveDynamicComponent" : 0);
var RESOLVE_DIRECTIVE = Symbol( true ? "resolveDirective" : 0);
var RESOLVE_FILTER = Symbol( true ? "resolveFilter" : 0);
var WITH_DIRECTIVES = Symbol( true ? "withDirectives" : 0);
var RENDER_LIST = Symbol( true ? "renderList" : 0);
var RENDER_SLOT = Symbol( true ? "renderSlot" : 0);
var CREATE_SLOTS = Symbol( true ? "createSlots" : 0);
var TO_DISPLAY_STRING = Symbol( true ? "toDisplayString" : 0);
var MERGE_PROPS = Symbol( true ? "mergeProps" : 0);
var NORMALIZE_CLASS = Symbol( true ? "normalizeClass" : 0);
var NORMALIZE_STYLE = Symbol( true ? "normalizeStyle" : 0);
var NORMALIZE_PROPS = Symbol( true ? "normalizeProps" : 0);
var GUARD_REACTIVE_PROPS = Symbol( true ? "guardReactiveProps" : 0);
var TO_HANDLERS = Symbol( true ? "toHandlers" : 0);
var CAMELIZE = Symbol( true ? "camelize" : 0);
var CAPITALIZE = Symbol( true ? "capitalize" : 0);
var TO_HANDLER_KEY = Symbol( true ? "toHandlerKey" : 0);
var SET_BLOCK_TRACKING = Symbol( true ? "setBlockTracking" : 0);
var PUSH_SCOPE_ID = Symbol( true ? "pushScopeId" : 0);
var POP_SCOPE_ID = Symbol( true ? "popScopeId" : 0);
var WITH_CTX = Symbol( true ? "withCtx" : 0);
var UNREF = Symbol( true ? "unref" : 0);
var IS_REF = Symbol( true ? "isRef" : 0);
var WITH_MEMO = Symbol( true ? "withMemo" : 0);
var IS_MEMO_SAME = Symbol( true ? "isMemoSame" : 0); // Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.

var helperNameMap = (_helperNameMap = {}, _defineProperty(_helperNameMap, FRAGMENT, "Fragment"), _defineProperty(_helperNameMap, TELEPORT, "Teleport"), _defineProperty(_helperNameMap, SUSPENSE, "Suspense"), _defineProperty(_helperNameMap, KEEP_ALIVE, "KeepAlive"), _defineProperty(_helperNameMap, BASE_TRANSITION, "BaseTransition"), _defineProperty(_helperNameMap, OPEN_BLOCK, "openBlock"), _defineProperty(_helperNameMap, CREATE_BLOCK, "createBlock"), _defineProperty(_helperNameMap, CREATE_ELEMENT_BLOCK, "createElementBlock"), _defineProperty(_helperNameMap, CREATE_VNODE, "createVNode"), _defineProperty(_helperNameMap, CREATE_ELEMENT_VNODE, "createElementVNode"), _defineProperty(_helperNameMap, CREATE_COMMENT, "createCommentVNode"), _defineProperty(_helperNameMap, CREATE_TEXT, "createTextVNode"), _defineProperty(_helperNameMap, CREATE_STATIC, "createStaticVNode"), _defineProperty(_helperNameMap, RESOLVE_COMPONENT, "resolveComponent"), _defineProperty(_helperNameMap, RESOLVE_DYNAMIC_COMPONENT, "resolveDynamicComponent"), _defineProperty(_helperNameMap, RESOLVE_DIRECTIVE, "resolveDirective"), _defineProperty(_helperNameMap, RESOLVE_FILTER, "resolveFilter"), _defineProperty(_helperNameMap, WITH_DIRECTIVES, "withDirectives"), _defineProperty(_helperNameMap, RENDER_LIST, "renderList"), _defineProperty(_helperNameMap, RENDER_SLOT, "renderSlot"), _defineProperty(_helperNameMap, CREATE_SLOTS, "createSlots"), _defineProperty(_helperNameMap, TO_DISPLAY_STRING, "toDisplayString"), _defineProperty(_helperNameMap, MERGE_PROPS, "mergeProps"), _defineProperty(_helperNameMap, NORMALIZE_CLASS, "normalizeClass"), _defineProperty(_helperNameMap, NORMALIZE_STYLE, "normalizeStyle"), _defineProperty(_helperNameMap, NORMALIZE_PROPS, "normalizeProps"), _defineProperty(_helperNameMap, GUARD_REACTIVE_PROPS, "guardReactiveProps"), _defineProperty(_helperNameMap, TO_HANDLERS, "toHandlers"), _defineProperty(_helperNameMap, CAMELIZE, "camelize"), _defineProperty(_helperNameMap, CAPITALIZE, "capitalize"), _defineProperty(_helperNameMap, TO_HANDLER_KEY, "toHandlerKey"), _defineProperty(_helperNameMap, SET_BLOCK_TRACKING, "setBlockTracking"), _defineProperty(_helperNameMap, PUSH_SCOPE_ID, "pushScopeId"), _defineProperty(_helperNameMap, POP_SCOPE_ID, "popScopeId"), _defineProperty(_helperNameMap, WITH_CTX, "withCtx"), _defineProperty(_helperNameMap, UNREF, "unref"), _defineProperty(_helperNameMap, IS_REF, "isRef"), _defineProperty(_helperNameMap, WITH_MEMO, "withMemo"), _defineProperty(_helperNameMap, IS_MEMO_SAME, "isMemoSame"), _helperNameMap);

function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach(function (s) {
    helperNameMap[s] = helpers[s];
  });
} // AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.


var locStub = {
  source: '',
  start: {
    line: 1,
    column: 1,
    offset: 0
  },
  end: {
    line: 1,
    column: 1,
    offset: 0
  }
};

function createRoot(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 0
    /* ROOT */
    ,
    children: children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc: loc
  };
}

function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives) {
  var isBlock = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var disableTracking = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var isComponent = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var loc = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : locStub;

  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }

    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }

  return {
    type: 13
    /* VNODE_CALL */
    ,
    tag: tag,
    props: props,
    children: children,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    directives: directives,
    isBlock: isBlock,
    disableTracking: disableTracking,
    isComponent: isComponent,
    loc: loc
  };
}

function createArrayExpression(elements) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 17
    /* JS_ARRAY_EXPRESSION */
    ,
    loc: loc,
    elements: elements
  };
}

function createObjectExpression(properties) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 15
    /* JS_OBJECT_EXPRESSION */
    ,
    loc: loc,
    properties: properties
  };
}

function createObjectProperty(key, value) {
  return {
    type: 16
    /* JS_PROPERTY */
    ,
    loc: locStub,
    key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
    value: value
  };
}

function createSimpleExpression(content) {
  var isStatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  var constType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    type: 4
    /* SIMPLE_EXPRESSION */
    ,
    loc: loc,
    content: content,
    isStatic: isStatic,
    constType: isStatic ? 3
    /* CAN_STRINGIFY */
    : constType
  };
}

function createInterpolation(content, loc) {
  return {
    type: 5
    /* INTERPOLATION */
    ,
    loc: loc,
    content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content) ? createSimpleExpression(content, false, loc) : content
  };
}

function createCompoundExpression(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 8
    /* COMPOUND_EXPRESSION */
    ,
    loc: loc,
    children: children
  };
}

function createCallExpression(callee) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  return {
    type: 14
    /* JS_CALL_EXPRESSION */
    ,
    loc: loc,
    callee: callee,
    arguments: args
  };
}

function createFunctionExpression(params) {
  var returns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var newline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSlot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var loc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : locStub;
  return {
    type: 18
    /* JS_FUNCTION_EXPRESSION */
    ,
    params: params,
    returns: returns,
    newline: newline,
    isSlot: isSlot,
    loc: loc
  };
}

function createConditionalExpression(test, consequent, alternate) {
  var newline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return {
    type: 19
    /* JS_CONDITIONAL_EXPRESSION */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    newline: newline,
    loc: locStub
  };
}

function createCacheExpression(index, value) {
  var isVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 20
    /* JS_CACHE_EXPRESSION */
    ,
    index: index,
    value: value,
    isVNode: isVNode,
    loc: locStub
  };
}

function createBlockStatement(body) {
  return {
    type: 21
    /* JS_BLOCK_STATEMENT */
    ,
    body: body,
    loc: locStub
  };
}

function createTemplateLiteral(elements) {
  return {
    type: 22
    /* JS_TEMPLATE_LITERAL */
    ,
    elements: elements,
    loc: locStub
  };
}

function createIfStatement(test, consequent, alternate) {
  return {
    type: 23
    /* JS_IF_STATEMENT */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    loc: locStub
  };
}

function createAssignmentExpression(left, right) {
  return {
    type: 24
    /* JS_ASSIGNMENT_EXPRESSION */
    ,
    left: left,
    right: right,
    loc: locStub
  };
}

function createSequenceExpression(expressions) {
  return {
    type: 25
    /* JS_SEQUENCE_EXPRESSION */
    ,
    expressions: expressions,
    loc: locStub
  };
}

function createReturnStatement(returns) {
  return {
    type: 26
    /* JS_RETURN_STATEMENT */
    ,
    returns: returns,
    loc: locStub
  };
}

var isStaticExp = function isStaticExp(p) {
  return p.type === 4
  /* SIMPLE_EXPRESSION */
  && p.isStatic;
};

var isBuiltInType = function isBuiltInType(tag, expected) {
  return tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
};

function isCoreComponent(tag) {
  if (isBuiltInType(tag, 'Teleport')) {
    return TELEPORT;
  } else if (isBuiltInType(tag, 'Suspense')) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, 'KeepAlive')) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, 'BaseTransition')) {
    return BASE_TRANSITION;
  }
}

var nonIdentifierRE = /^\d|[^\$\w]/;

var isSimpleIdentifier = function isSimpleIdentifier(name) {
  return !nonIdentifierRE.test(name);
};

var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */

var isMemberExpressionBrowser = function isMemberExpressionBrowser(path) {
  // remove whitespaces around . or [ first
  path = path.trim().replace(whitespaceRE, function (s) {
    return s.trim();
  });
  var state = 0
  /* inMemberExp */
  ;
  var stateStack = [];
  var currentOpenBracketCount = 0;
  var currentOpenParensCount = 0;
  var currentStringType = null;

  for (var i = 0; i < path.length; i++) {
    var _char = path.charAt(i);

    switch (state) {
      case 0
      /* inMemberExp */
      :
        if (_char === '[') {
          stateStack.push(state);
          state = 1
          /* inBrackets */
          ;
          currentOpenBracketCount++;
        } else if (_char === '(') {
          stateStack.push(state);
          state = 2
          /* inParens */
          ;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(_char)) {
          return false;
        }

        break;

      case 1
      /* inBrackets */
      :
        if (_char === "'" || _char === "\"" || _char === '`') {
          stateStack.push(state);
          state = 3
          /* inString */
          ;
          currentStringType = _char;
        } else if (_char === "[") {
          currentOpenBracketCount++;
        } else if (_char === "]") {
          if (! --currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }

        break;

      case 2
      /* inParens */
      :
        if (_char === "'" || _char === "\"" || _char === '`') {
          stateStack.push(state);
          state = 3
          /* inString */
          ;
          currentStringType = _char;
        } else if (_char === "(") {
          currentOpenParensCount++;
        } else if (_char === ")") {
          // if the exp ends as a call then it should not be considered valid
          if (i === path.length - 1) {
            return false;
          }

          if (! --currentOpenParensCount) {
            state = stateStack.pop();
          }
        }

        break;

      case 3
      /* inString */
      :
        if (_char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }

        break;
    }
  }

  return !currentOpenBracketCount && !currentOpenParensCount;
};

var isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP;
var isMemberExpression = isMemberExpressionBrowser;

function getInnerRange(loc, offset, length) {
  var source = loc.source.slice(offset, offset + length);
  var newLoc = {
    source: source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };

  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }

  return newLoc;
}

function advancePositionWithClone(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
} // advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser


function advancePositionWithMutation(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  var linesCount = 0;
  var lastNewLinePos = -1;

  for (var i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10
    /* newline char code */
    ) {
      linesCount++;
      lastNewLinePos = i;
    }
  }

  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}

function assert(condition, msg) {
  /* istanbul ignore if */
  if (!condition) {
    throw new Error(msg || "unexpected compiler condition");
  }
}

function findDir(node, name) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 7
    /* DIRECTIVE */
    && (allowEmpty || p.exp) && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}

function findProp(node, name) {
  var dynamicOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
      if (dynamicOnly) continue;

      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === 'bind' && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}

function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}

function hasDynamicKeyVBind(node) {
  return node.props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'bind' && (!p.arg || // v-bind="obj"
    p.arg.type !== 4
    /* SIMPLE_EXPRESSION */
    || // v-bind:[_ctx.foo]
    !p.arg.isStatic);
  } // v-bind:[foo]
  );
}

function isText(node) {
  return node.type === 5
  /* INTERPOLATION */
  || node.type === 2
  /* TEXT */
  ;
}

function isVSlot(p) {
  return p.type === 7
  /* DIRECTIVE */
  && p.name === 'slot';
}

function isTemplateNode(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 3
  /* TEMPLATE */
  ;
}

function isSlotOutlet(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 2
  /* SLOT */
  ;
}

function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}

function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}

var propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);

function getUnnormalizedProps(props) {
  var callPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14
  /* JS_CALL_EXPRESSION */
  ) {
    var callee = props.callee;

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }

  return [props, callPath];
}

function injectProp(node, prop, context) {
  var propsWithInjection;
  /**
   * 1. mergeProps(...)
   * 2. toHandlers(...)
   * 3. normalizeProps(...)
   * 4. normalizeProps(guardReactiveProps(...))
   *
   * we need to get the real props before normalization
   */

  var props = node.type === 13
  /* VNODE_CALL */
  ? node.props : node.arguments[2];
  var callPath = [];
  var parentCall;

  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14
  /* JS_CALL_EXPRESSION */
  ) {
    var ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }

  if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14
  /* JS_CALL_EXPRESSION */
  ) {
    // merged props... add ours
    // only inject key to object literal if it's the first argument so that
    // if doesn't override user provided keys
    var first = props.arguments[0];

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15
    /* JS_OBJECT_EXPRESSION */
    ) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        // #2366
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }

    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
    var alreadyExists = false; // check existing key to avoid overriding user provided keys

    if (prop.key.type === 4
    /* SIMPLE_EXPRESSION */
    ) {
      var propKeyName = prop.key.content;
      alreadyExists = props.properties.some(function (p) {
        return p.key.type === 4
        /* SIMPLE_EXPRESSION */
        && p.key.content === propKeyName;
      });
    }

    if (!alreadyExists) {
      props.properties.unshift(prop);
    }

    propsWithInjection = props;
  } else {
    // single v-bind with expression, return a merged replacement
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]); // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
    // the `guardReactiveProps` will no longer be needed

    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }

  if (node.type === 13
  /* VNODE_CALL */
  ) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}

function toValidAssetId(name, type) {
  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
  return "_".concat(type, "_").concat(name.replace(/[^\w]/g, function (searchValue, replaceValue) {
    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
  }));
} // Check if a node contains expressions that reference current context scope ids


function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      for (var i = 0; i < node.props.length; i++) {
        var p = node.props[i];

        if (p.type === 7
        /* DIRECTIVE */
        && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 11
    /* FOR */
    :
      if (hasScopeRef(node.source, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 9
    /* IF */
    :
      return node.branches.some(function (b) {
        return hasScopeRef(b, ids);
      });

    case 10
    /* IF_BRANCH */
    :
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];

    case 8
    /* COMPOUND_EXPRESSION */
    :
      return node.children.some(function (c) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids);
      });

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return hasScopeRef(node.content, ids);

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return false;

    default:
      if (true) ;
      return false;
  }
}

function getMemoedVNodeCall(node) {
  if (node.type === 14
  /* JS_CALL_EXPRESSION */
  && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}

function makeBlock(node, _ref) {
  var helper = _ref.helper,
      removeHelper = _ref.removeHelper,
      inSSR = _ref.inSSR;

  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

var deprecationData = (_deprecationData = {}, _defineProperty(_deprecationData, "COMPILER_IS_ON_ELEMENT"
/* COMPILER_IS_ON_ELEMENT */
, {
  message: "Platform-native elements with \"is\" prop will no longer be " + "treated as components in Vue 3 unless the \"is\" value is explicitly " + "prefixed with \"vue:\".",
  link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_SYNC"
/* COMPILER_V_BIND_SYNC */
, {
  message: function message(key) {
    return ".sync modifier for v-bind has been removed. Use v-model with " + "argument instead. `v-bind:".concat(key, ".sync` should be changed to ") + "`v-model:".concat(key, "`.");
  },
  link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_PROP"
/* COMPILER_V_BIND_PROP */
, {
  message: ".prop modifier for v-bind has been removed and no longer necessary. " + "Vue 3 will automatically set a binding as DOM property when appropriate."
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_OBJECT_ORDER"
/* COMPILER_V_BIND_OBJECT_ORDER */
, {
  message: "v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript " + "object spread: it will now overwrite an existing non-mergeable attribute " + "that appears before v-bind in the case of conflict. " + "To retain 2.x behavior, move v-bind to make it the first attribute. " + "You can also suppress this warning if the usage is intended.",
  link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
}), _defineProperty(_deprecationData, "COMPILER_V_ON_NATIVE"
/* COMPILER_V_ON_NATIVE */
, {
  message: ".native modifier for v-on has been removed as is no longer necessary.",
  link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
}), _defineProperty(_deprecationData, "COMPILER_V_IF_V_FOR_PRECEDENCE"
/* COMPILER_V_IF_V_FOR_PRECEDENCE */
, {
  message: "v-if / v-for precedence when used on the same element has changed " + "in Vue 3: v-if now takes higher precedence and will no longer have " + "access to v-for scope variables. It is best to avoid the ambiguity " + "with <template> tags or use a computed property that filters v-for " + "data source.",
  link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
}), _defineProperty(_deprecationData, "COMPILER_NATIVE_TEMPLATE"
/* COMPILER_NATIVE_TEMPLATE */
, {
  message: "<template> with no special directives will render as a native template " + "element instead of its inner content in Vue 3."
}), _defineProperty(_deprecationData, "COMPILER_INLINE_TEMPLATE"
/* COMPILER_INLINE_TEMPLATE */
, {
  message: "\"inline-template\" has been removed in Vue 3.",
  link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
}), _defineProperty(_deprecationData, "COMPILER_FILTER"
/* COMPILER_FILTERS */
, {
  message: "filters have been removed in Vue 3. " + "The \"|\" symbol will be treated as native JavaScript bitwise OR operator. " + "Use method calls or computed properties instead.",
  link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
}), _deprecationData);

function getCompatValue(key, context) {
  var config = context.options ? context.options.compatConfig : context.compatConfig;
  var value = config && config[key];

  if (key === 'MODE') {
    return value || 3; // compiler defaults to v3 behavior
  } else {
    return value;
  }
}

function isCompatEnabled(key, context) {
  var mode = getCompatValue('MODE', context);
  var value = getCompatValue(key, context); // in v3 mode, only enable if explicitly set to true
  // otherwise enable for any non-false value

  return mode === 3 ? value === true : value !== false;
}

function checkCompatEnabled(key, context, loc) {
  var enabled = isCompatEnabled(key, context);

  if ( true && enabled) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    warnDeprecation.apply(void 0, [key, context, loc].concat(args));
  }

  return enabled;
}

function warnDeprecation(key, context, loc) {
  var val = getCompatValue(key, context);

  if (val === 'suppress-warning') {
    return;
  }

  var _deprecationData$key = deprecationData[key],
      message = _deprecationData$key.message,
      link = _deprecationData$key.link;

  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var msg = "(deprecation ".concat(key, ") ").concat(typeof message === 'function' ? message.apply(void 0, args) : message).concat(link ? "\n  Details: ".concat(link) : "");
  var err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
} // The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.


var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap = {
  gt: '>',
  lt: '<',
  amp: '&',
  apos: "'",
  quot: '"'
};
var defaultParserOptions = {
  delimiters: ["{{", "}}"],
  getNamespace: function getNamespace() {
    return 0;
  }
  /* HTML */
  ,
  getTextMode: function getTextMode() {
    return 0;
  }
  /* DATA */
  ,
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  decodeEntities: function decodeEntities(rawText) {
    return rawText.replace(decodeRE, function (_, p1) {
      return decodeMap[p1];
    });
  },
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: "development" !== 'production'
};

function baseParse(content) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createParserContext(content, options);
  var start = getCursor(context);
  return createRoot(parseChildren(context, 0
  /* DATA */
  , []), getSelection(context, start));
}

function createParserContext(content, rawOptions) {
  var options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
  var key;

  for (key in rawOptions) {
    // @ts-ignore
    options[key] = rawOptions[key] === undefined ? defaultParserOptions[key] : rawOptions[key];
  }

  return {
    options: options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}

function parseChildren(context, mode, ancestors) {
  var parent = last(ancestors);
  var ns = parent ? parent.ns : 0
  /* HTML */
  ;
  var nodes = [];

  while (!isEnd(context, mode, ancestors)) {
    var s = context.source;
    var node = undefined;

    if (mode === 0
    /* DATA */
    || mode === 1
    /* RCDATA */
    ) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        // '{{'
        node = parseInterpolation(context, mode);
      } else if (mode === 0
      /* DATA */
      && s[0] === '<') {
        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
        if (s.length === 1) {
          emitError(context, 5
          /* EOF_BEFORE_TAG_NAME */
          , 1);
        } else if (s[1] === '!') {
          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
          if (startsWith(s, '<!--')) {
            node = parseComment(context);
          } else if (startsWith(s, '<!DOCTYPE')) {
            // Ignore DOCTYPE by a limitation.
            node = parseBogusComment(context);
          } else if (startsWith(s, '<![CDATA[')) {
            if (ns !== 0
            /* HTML */
            ) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1
              /* CDATA_IN_HTML_CONTENT */
              );
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11
            /* INCORRECTLY_OPENED_COMMENT */
            );
            node = parseBogusComment(context);
          }
        } else if (s[1] === '/') {
          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
          if (s.length === 2) {
            emitError(context, 5
            /* EOF_BEFORE_TAG_NAME */
            , 2);
          } else if (s[2] === '>') {
            emitError(context, 14
            /* MISSING_END_TAG_NAME */
            , 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23
            /* X_INVALID_END_TAG */
            );
            parseTag(context, 1
            /* End */
            , parent);
            continue;
          } else {
            emitError(context, 12
            /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
            , 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors); // 2.x <template> with no directive compat

          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE"
          /* COMPILER_NATIVE_TEMPLATE */
          , context) && node && node.tag === 'template' && !node.props.some(function (p) {
            return p.type === 7
            /* DIRECTIVE */
            && isSpecialTemplateDirective(p.name);
          })) {
             true && warnDeprecation("COMPILER_NATIVE_TEMPLATE"
            /* COMPILER_NATIVE_TEMPLATE */
            , context, node.loc);
            node = node.children;
          }
        } else if (s[1] === '?') {
          emitError(context, 21
          /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
          , 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12
          /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
          , 1);
        }
      }
    }

    if (!node) {
      node = parseText(context, mode);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      for (var i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  } // Whitespace handling strategy like v2


  var removedWhitespace = false;

  if (mode !== 2
  /* RAWTEXT */
  && mode !== 1
  /* RCDATA */
  ) {
    var shouldCondense = context.options.whitespace !== 'preserve';

    for (var _i = 0; _i < nodes.length; _i++) {
      var _node2 = nodes[_i];

      if (!context.inPre && _node2.type === 2
      /* TEXT */
      ) {
        if (!/[^\t\r\n\f ]/.test(_node2.content)) {
          var prev = nodes[_i - 1];
          var next = nodes[_i + 1]; // Remove if:
          // - the whitespace is the first or last node, or:
          // - (condense mode) the whitespace is adjacent to a comment, or:
          // - (condense mode) the whitespace is between two elements AND contains newline

          if (!prev || !next || shouldCondense && (prev.type === 3
          /* COMMENT */
          || next.type === 3
          /* COMMENT */
          || prev.type === 1
          /* ELEMENT */
          && next.type === 1
          /* ELEMENT */
          && /[\r\n]/.test(_node2.content))) {
            removedWhitespace = true;
            nodes[_i] = null;
          } else {
            // Otherwise, the whitespace is condensed into a single space
            _node2.content = ' ';
          }
        } else if (shouldCondense) {
          // in condense mode, consecutive whitespaces in text are condensed
          // down to a single space.
          _node2.content = _node2.content.replace(/[\t\r\n\f ]+/g, ' ');
        }
      } // Remove comment nodes if desired by configuration.
      else if (_node2.type === 3
      /* COMMENT */
      && !context.options.comments) {
        removedWhitespace = true;
        nodes[_i] = null;
      }
    }

    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      // remove leading newline per html spec
      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
      var first = nodes[0];

      if (first && first.type === 2
      /* TEXT */
      ) {
        first.content = first.content.replace(/^\r?\n/, '');
      }
    }
  }

  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}

function pushNode(nodes, node) {
  if (node.type === 2
  /* TEXT */
  ) {
    var prev = last(nodes); // Merge if both this and the previous node are text and those are
    // consecutive. This happens for cases like "a < b".

    if (prev && prev.type === 2
    /* TEXT */
    && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }

  nodes.push(node);
}

function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  var nodes = parseChildren(context, 3
  /* CDATA */
  , ancestors);

  if (context.source.length === 0) {
    emitError(context, 6
    /* EOF_IN_CDATA */
    );
  } else {
    advanceBy(context, 3);
  }

  return nodes;
}

function parseComment(context) {
  var start = getCursor(context);
  var content; // Regular comment.

  var match = /--(\!)?>/.exec(context.source);

  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7
    /* EOF_IN_COMMENT */
    );
  } else {
    if (match.index <= 3) {
      emitError(context, 0
      /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
      );
    }

    if (match[1]) {
      emitError(context, 10
      /* INCORRECTLY_CLOSED_COMMENT */
      );
    }

    content = context.source.slice(4, match.index); // Advancing with reporting nested comments.

    var s = context.source.slice(0, match.index);
    var prevIndex = 1,
        nestedIndex = 0;

    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);

      if (nestedIndex + 4 < s.length) {
        emitError(context, 16
        /* NESTED_COMMENT */
        );
      }

      prevIndex = nestedIndex + 1;
    }

    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseBogusComment(context) {
  var start = getCursor(context);
  var contentStart = context.source[1] === '?' ? 1 : 2;
  var content;
  var closeIndex = context.source.indexOf('>');

  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseElement(context, ancestors) {
  // Start tag.
  var wasInPre = context.inPre;
  var wasInVPre = context.inVPre;
  var parent = last(ancestors);
  var element = parseTag(context, 0
  /* Start */
  , parent);
  var isPreBoundary = context.inPre && !wasInPre;
  var isVPreBoundary = context.inVPre && !wasInVPre;

  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    // #4030 self-closing <pre> tag
    if (isPreBoundary) {
      context.inPre = false;
    }

    if (isVPreBoundary) {
      context.inVPre = false;
    }

    return element;
  } // Children.


  ancestors.push(element);
  var mode = context.options.getTextMode(element, parent);
  var children = parseChildren(context, mode, ancestors);
  ancestors.pop(); // 2.x inline-template compat

  {
    var inlineTemplateProp = element.props.find(function (p) {
      return p.type === 6
      /* ATTRIBUTE */
      && p.name === 'inline-template';
    });

    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE"
    /* COMPILER_INLINE_TEMPLATE */
    , context, inlineTemplateProp.loc)) {
      var loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2
        /* TEXT */
        ,
        content: loc.source,
        loc: loc
      };
    }
  }
  element.children = children; // End tag.

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1
    /* End */
    , parent);
  } else {
    emitError(context, 24
    /* X_MISSING_END_TAG */
    , 0, element.loc.start);

    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
      var first = children[0];

      if (first && startsWith(first.loc.source, '<!--')) {
        emitError(context, 8
        /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        );
      }
    }
  }

  element.loc = getSelection(context, element.loc.start);

  if (isPreBoundary) {
    context.inPre = false;
  }

  if (isVPreBoundary) {
    context.inVPre = false;
  }

  return element;
}

var isSpecialTemplateDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("if,else,else-if,for,slot");

function parseTag(context, type, parent) {
  // Tag open.
  var start = getCursor(context);
  var match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  var tag = match[1];
  var ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context); // save current state in case we need to re-parse attributes with v-pre

  var cursor = getCursor(context);
  var currentSource = context.source; // check <pre> tag

  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  } // Attributes.


  var props = parseAttributes(context, type); // check v-pre

  if (type === 0
  /* Start */
  && !context.inVPre && props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'pre';
  })) {
    context.inVPre = true; // reset context

    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
    context.source = currentSource; // re-parse attrs and filter out v-pre itself

    props = parseAttributes(context, type).filter(function (p) {
      return p.name !== 'v-pre';
    });
  } // Tag close.


  var isSelfClosing = false;

  if (context.source.length === 0) {
    emitError(context, 9
    /* EOF_IN_TAG */
    );
  } else {
    isSelfClosing = startsWith(context.source, '/>');

    if (type === 1
    /* End */
    && isSelfClosing) {
      emitError(context, 4
      /* END_TAG_WITH_TRAILING_SOLIDUS */
      );
    }

    advanceBy(context, isSelfClosing ? 2 : 1);
  }

  if (type === 1
  /* End */
  ) {
    return;
  } // 2.x deprecation checks


  if ( true && isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE"
  /* COMPILER_V_IF_V_FOR_PRECEDENCE */
  , context)) {
    var hasIf = false;
    var hasFor = false;

    for (var i = 0; i < props.length; i++) {
      var p = props[i];

      if (p.type === 7
      /* DIRECTIVE */
      ) {
        if (p.name === 'if') {
          hasIf = true;
        } else if (p.name === 'for') {
          hasFor = true;
        }
      }

      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE"
        /* COMPILER_V_IF_V_FOR_PRECEDENCE */
        , context, getSelection(context, start));
        break;
      }
    }
  }

  var tagType = 0
  /* ELEMENT */
  ;

  if (!context.inVPre) {
    if (tag === 'slot') {
      tagType = 2
      /* SLOT */
      ;
    } else if (tag === 'template') {
      if (props.some(function (p) {
        return p.type === 7
        /* DIRECTIVE */
        && isSpecialTemplateDirective(p.name);
      })) {
        tagType = 3
        /* TEMPLATE */
        ;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1
      /* COMPONENT */
      ;
    }
  }

  return {
    type: 1
    /* ELEMENT */
    ,
    ns: ns,
    tag: tag,
    tagType: tagType,
    props: props,
    isSelfClosing: isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // to be created during transform phase

  };
}

function isComponent(tag, props, context) {
  var options = context.options;

  if (options.isCustomElement(tag)) {
    return false;
  }

  if (tag === 'component' || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  } // at this point the tag should be a native tag, but check for potential "is"
  // casting


  for (var i = 0; i < props.length; i++) {
    var p = props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
      if (p.name === 'is' && p.value) {
        if (p.value.content.startsWith('vue:')) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT"
        /* COMPILER_IS_ON_ELEMENT */
        , context, p.loc)) {
          return true;
        }
      }
    } else {
      // directive
      // v-is (TODO Deprecate)
      if (p.name === 'is') {
        return true;
      } else if ( // :is on plain element - only treat as component in compat mode
      p.name === 'bind' && isStaticArgOf(p.arg, 'is') && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT"
      /* COMPILER_IS_ON_ELEMENT */
      , context, p.loc)) {
        return true;
      }
    }
  }
}

function parseAttributes(context, type) {
  var props = [];
  var attributeNames = new Set();

  while (context.source.length > 0 && !startsWith(context.source, '>') && !startsWith(context.source, '/>')) {
    if (startsWith(context.source, '/')) {
      emitError(context, 22
      /* UNEXPECTED_SOLIDUS_IN_TAG */
      );
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }

    if (type === 1
    /* End */
    ) {
      emitError(context, 3
      /* END_TAG_WITH_ATTRIBUTES */
      );
    }

    var attr = parseAttribute(context, attributeNames); // Trim whitespace between class
    // https://github.com/vuejs/core/issues/4251

    if (attr.type === 6
    /* ATTRIBUTE */
    && attr.value && attr.name === 'class') {
      attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
    }

    if (type === 0
    /* Start */
    ) {
      props.push(attr);
    }

    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15
      /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
      );
    }

    advanceSpaces(context);
  }

  return props;
}

function parseAttribute(context, nameSet) {
  // Name.
  var start = getCursor(context);
  var match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  var name = match[0];

  if (nameSet.has(name)) {
    emitError(context, 2
    /* DUPLICATE_ATTRIBUTE */
    );
  }

  nameSet.add(name);

  if (name[0] === '=') {
    emitError(context, 19
    /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
    );
  }

  {
    var pattern = /["'<]/g;
    var m;

    while (m = pattern.exec(name)) {
      emitError(context, 17
      /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
      , m.index);
    }
  }
  advanceBy(context, name.length); // Value

  var value = undefined;

  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);

    if (!value) {
      emitError(context, 13
      /* MISSING_ATTRIBUTE_VALUE */
      );
    }
  }

  var loc = getSelection(context, start);

  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    var _match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);

    var isPropShorthand = startsWith(name, '.');
    var dirName = _match[1] || (isPropShorthand || startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
    var arg;

    if (_match[2]) {
      var isSlot = dirName === 'slot';
      var startOffset = name.lastIndexOf(_match[2]);

      var _loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + _match[2].length + (isSlot && _match[3] || '').length));

      var content = _match[2];
      var isStatic = true;

      if (content.startsWith('[')) {
        isStatic = false;

        if (!content.endsWith(']')) {
          emitError(context, 27
          /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
          );
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        // #1241 special case for v-slot: vuetify relies extensively on slot
        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
        // supports such usage so we are keeping it consistent with 2.x.
        content += _match[3] || '';
      }

      arg = {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: content,
        isStatic: isStatic,
        constType: isStatic ? 3
        /* CAN_STRINGIFY */
        : 0
        /* NOT_CONSTANT */
        ,
        loc: _loc
      };
    }

    if (value && value.isQuoted) {
      var valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }

    var modifiers = _match[3] ? _match[3].slice(1).split('.') : [];
    if (isPropShorthand) modifiers.push('prop'); // 2.x compat v-bind:foo.sync -> v-model:foo

    if (dirName === 'bind' && arg) {
      if (modifiers.includes('sync') && checkCompatEnabled("COMPILER_V_BIND_SYNC"
      /* COMPILER_V_BIND_SYNC */
      , context, loc, arg.loc.source)) {
        dirName = 'model';
        modifiers.splice(modifiers.indexOf('sync'), 1);
      }

      if ( true && modifiers.includes('prop')) {
        checkCompatEnabled("COMPILER_V_BIND_PROP"
        /* COMPILER_V_BIND_PROP */
        , context, loc);
      }
    }

    return {
      type: 7
      /* DIRECTIVE */
      ,
      name: dirName,
      exp: value && {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0
        /* NOT_CONSTANT */
        ,
        loc: value.loc
      },
      arg: arg,
      modifiers: modifiers,
      loc: loc
    };
  } // missing directive name or illegal directive name


  if (!context.inVPre && startsWith(name, 'v-')) {
    emitError(context, 26
    /* X_MISSING_DIRECTIVE_NAME */
    );
  }

  return {
    type: 6
    /* ATTRIBUTE */
    ,
    name: name,
    value: value && {
      type: 2
      /* TEXT */
      ,
      content: value.content,
      loc: value.loc
    },
    loc: loc
  };
}

function parseAttributeValue(context) {
  var start = getCursor(context);
  var content;
  var quote = context.source[0];
  var isQuoted = quote === "\"" || quote === "'";

  if (isQuoted) {
    // Quoted value.
    advanceBy(context, 1);
    var endIndex = context.source.indexOf(quote);

    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4
      /* ATTRIBUTE_VALUE */
      );
    } else {
      content = parseTextData(context, endIndex, 4
      /* ATTRIBUTE_VALUE */
      );
      advanceBy(context, 1);
    }
  } else {
    // Unquoted
    var match = /^[^\t\r\n\f >]+/.exec(context.source);

    if (!match) {
      return undefined;
    }

    var unexpectedChars = /["'<=`]/g;
    var m;

    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18
      /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
      , m.index);
    }

    content = parseTextData(context, match[0].length, 4
    /* ATTRIBUTE_VALUE */
    );
  }

  return {
    content: content,
    isQuoted: isQuoted,
    loc: getSelection(context, start)
  };
}

function parseInterpolation(context, mode) {
  var _context$options$deli = _slicedToArray(context.options.delimiters, 2),
      open = _context$options$deli[0],
      close = _context$options$deli[1];

  var closeIndex = context.source.indexOf(close, open.length);

  if (closeIndex === -1) {
    emitError(context, 25
    /* X_MISSING_INTERPOLATION_END */
    );
    return undefined;
  }

  var start = getCursor(context);
  advanceBy(context, open.length);
  var innerStart = getCursor(context);
  var innerEnd = getCursor(context);
  var rawContentLength = closeIndex - open.length;
  var rawContent = context.source.slice(0, rawContentLength);
  var preTrimContent = parseTextData(context, rawContentLength, mode);
  var content = preTrimContent.trim();
  var startOffset = preTrimContent.indexOf(content);

  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }

  var endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5
    /* INTERPOLATION */
    ,
    content: {
      type: 4
      /* SIMPLE_EXPRESSION */
      ,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0
      /* NOT_CONSTANT */
      ,
      content: content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}

function parseText(context, mode) {
  var endTokens = mode === 3
  /* CDATA */
  ? [']]>'] : ['<', context.options.delimiters[0]];
  var endIndex = context.source.length;

  for (var i = 0; i < endTokens.length; i++) {
    var index = context.source.indexOf(endTokens[i], 1);

    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }

  var start = getCursor(context);
  var content = parseTextData(context, endIndex, mode);
  return {
    type: 2
    /* TEXT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */


function parseTextData(context, length, mode) {
  var rawText = context.source.slice(0, length);
  advanceBy(context, length);

  if (mode === 2
  /* RAWTEXT */
  || mode === 3
  /* CDATA */
  || !rawText.includes('&')) {
    return rawText;
  } else {
    // DATA or RCDATA containing "&"". Entity decoding required.
    return context.options.decodeEntities(rawText, mode === 4
    /* ATTRIBUTE_VALUE */
    );
  }
}

function getCursor(context) {
  var column = context.column,
      line = context.line,
      offset = context.offset;
  return {
    column: column,
    line: line,
    offset: offset
  };
}

function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start: start,
    end: end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}

function last(xs) {
  return xs[xs.length - 1];
}

function startsWith(source, searchString) {
  return source.startsWith(searchString);
}

function advanceBy(context, numberOfCharacters) {
  var source = context.source;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}

function advanceSpaces(context) {
  var match = /^[\t\r\n\f ]+/.exec(context.source);

  if (match) {
    advanceBy(context, match[0].length);
  }
}

function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}

function emitError(context, code, offset) {
  var loc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCursor(context);

  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }

  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ''
  }));
}

function isEnd(context, mode, ancestors) {
  var s = context.source;

  switch (mode) {
    case 0
    /* DATA */
    :
      if (startsWith(s, '</')) {
        // TODO: probably bad performance
        for (var i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }

      break;

    case 1
    /* RCDATA */
    :
    case 2
    /* RAWTEXT */
    :
      {
        var parent = last(ancestors);

        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }

        break;
      }

    case 3
    /* CDATA */
    :
      if (startsWith(s, ']]>')) {
        return true;
      }

      break;
  }

  return !s;
}

function startsWithEndTagOpen(source, tag) {
  return startsWith(source, '</') && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || '>');
}

function hoistStatic(root, context) {
  walk(root, context, // Root node is unfortunately non-hoistable due to potential parent
  // fallthrough attributes.
  isSingleElementRoot(root, root.children[0]));
}

function isSingleElementRoot(root, child) {
  var children = root.children;
  return children.length === 1 && child.type === 1
  /* ELEMENT */
  && !isSlotOutlet(child);
}

function walk(node, context) {
  var doNotHoistNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var children = node.children;
  var originalCount = children.length;
  var hoistedCount = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // only plain elements & text calls are eligible for hoisting.

    if (child.type === 1
    /* ELEMENT */
    && child.tagType === 0
    /* ELEMENT */
    ) {
      var constantType = doNotHoistNode ? 0
      /* NOT_CONSTANT */
      : getConstantType(child, context);

      if (constantType > 0
      /* NOT_CONSTANT */
      ) {
        if (constantType >= 2
        /* CAN_HOIST */
        ) {
          child.codegenNode.patchFlag = -1
          /* HOISTED */
          + ( true ? " /* HOISTED */" : 0);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        // node may contain dynamic children, but its props may be eligible for
        // hoisting.
        var codegenNode = child.codegenNode;

        if (codegenNode.type === 13
        /* VNODE_CALL */
        ) {
          var flag = getPatchFlag(codegenNode);

          if ((!flag || flag === 512
          /* NEED_PATCH */
          || flag === 1
          /* TEXT */
          ) && getGeneratedPropsConstantType(child, context) >= 2
          /* CAN_HOIST */
          ) {
            var props = getNodeProps(child);

            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }

          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12
    /* TEXT_CALL */
    && getConstantType(child.content, context) >= 2
    /* CAN_HOIST */
    ) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    } // walk further


    if (child.type === 1
    /* ELEMENT */
    ) {
      var _isComponent = child.tagType === 1
      /* COMPONENT */
      ;

      if (_isComponent) {
        context.scopes.vSlot++;
      }

      walk(child, context);

      if (_isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11
    /* FOR */
    ) {
      // Do not hoist v-for single child because it has to be a block
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9
    /* IF */
    ) {
      for (var _i2 = 0; _i2 < child.branches.length; _i2++) {
        // Do not hoist v-if single child because it has to be a block
        walk(child.branches[_i2], context, child.branches[_i2].children.length === 1);
      }
    }
  }

  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  } // all children were hoisted - the entire children array is hoistable.


  if (hoistedCount && hoistedCount === originalCount && node.type === 1
  /* ELEMENT */
  && node.tagType === 0
  /* ELEMENT */
  && node.codegenNode && node.codegenNode.type === 13
  /* VNODE_CALL */
  && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}

function getConstantType(node, context) {
  var constantCache = context.constantCache;

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      if (node.tagType !== 0
      /* ELEMENT */
      ) {
        return 0
        /* NOT_CONSTANT */
        ;
      }

      var cached = constantCache.get(node);

      if (cached !== undefined) {
        return cached;
      }

      var codegenNode = node.codegenNode;

      if (codegenNode.type !== 13
      /* VNODE_CALL */
      ) {
        return 0
        /* NOT_CONSTANT */
        ;
      }

      if (codegenNode.isBlock && node.tag !== 'svg' && node.tag !== 'foreignObject') {
        return 0
        /* NOT_CONSTANT */
        ;
      }

      var flag = getPatchFlag(codegenNode);

      if (!flag) {
        var _returnType = 3
        /* CAN_STRINGIFY */
        ; // Element itself has no patch flag. However we still need to check:
        // 1. Even for a node with no patch flag, it is possible for it to contain
        // non-hoistable expressions that refers to scope variables, e.g. compiler
        // injected keys or cached event handlers. Therefore we need to always
        // check the codegenNode's props to be sure.

        var generatedPropsType = getGeneratedPropsConstantType(node, context);

        if (generatedPropsType === 0
        /* NOT_CONSTANT */
        ) {
          constantCache.set(node, 0
          /* NOT_CONSTANT */
          );
          return 0
          /* NOT_CONSTANT */
          ;
        }

        if (generatedPropsType < _returnType) {
          _returnType = generatedPropsType;
        } // 2. its children.


        for (var i = 0; i < node.children.length; i++) {
          var childType = getConstantType(node.children[i], context);

          if (childType === 0
          /* NOT_CONSTANT */
          ) {
            constantCache.set(node, 0
            /* NOT_CONSTANT */
            );
            return 0
            /* NOT_CONSTANT */
            ;
          }

          if (childType < _returnType) {
            _returnType = childType;
          }
        } // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
        // type, check if any of the props can cause the type to be lowered
        // we can skip can_patch because it's guaranteed by the absence of a
        // patchFlag.


        if (_returnType > 1
        /* CAN_SKIP_PATCH */
        ) {
          for (var _i3 = 0; _i3 < node.props.length; _i3++) {
            var p = node.props[_i3];

            if (p.type === 7
            /* DIRECTIVE */
            && p.name === 'bind' && p.exp) {
              var expType = getConstantType(p.exp, context);

              if (expType === 0
              /* NOT_CONSTANT */
              ) {
                constantCache.set(node, 0
                /* NOT_CONSTANT */
                );
                return 0
                /* NOT_CONSTANT */
                ;
              }

              if (expType < _returnType) {
                _returnType = expType;
              }
            }
          }
        } // only svg/foreignObject could be block here, however if they are
        // static then they don't need to be blocks since there will be no
        // nested updates.


        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }

        constantCache.set(node, _returnType);
        return _returnType;
      } else {
        constantCache.set(node, 0
        /* NOT_CONSTANT */
        );
        return 0
        /* NOT_CONSTANT */
        ;
      }

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return 3
      /* CAN_STRINGIFY */
      ;

    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
    case 10
    /* IF_BRANCH */
    :
      return 0
      /* NOT_CONSTANT */
      ;

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return getConstantType(node.content, context);

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return node.constType;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      var returnType = 3
      /* CAN_STRINGIFY */
      ;

      for (var _i4 = 0; _i4 < node.children.length; _i4++) {
        var child = node.children[_i4];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
          continue;
        }

        var _childType = getConstantType(child, context);

        if (_childType === 0
        /* NOT_CONSTANT */
        ) {
          return 0
          /* NOT_CONSTANT */
          ;
        } else if (_childType < returnType) {
          returnType = _childType;
        }
      }

      return returnType;

    default:
      if (true) ;
      return 0
      /* NOT_CONSTANT */
      ;
  }
}

var allowHoistedHelperSet = new Set([NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);

function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14
  /* JS_CALL_EXPRESSION */
  && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    var arg = value.arguments[0];

    if (arg.type === 4
    /* SIMPLE_EXPRESSION */
    ) {
      return getConstantType(arg, context);
    } else if (arg.type === 14
    /* JS_CALL_EXPRESSION */
    ) {
      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
      return getConstantTypeOfHelperCall(arg, context);
    }
  }

  return 0
  /* NOT_CONSTANT */
  ;
}

function getGeneratedPropsConstantType(node, context) {
  var returnType = 3
  /* CAN_STRINGIFY */
  ;
  var props = getNodeProps(node);

  if (props && props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
    var properties = props.properties;

    for (var i = 0; i < properties.length; i++) {
      var _properties$i = properties[i],
          key = _properties$i.key,
          value = _properties$i.value;
      var keyType = getConstantType(key, context);

      if (keyType === 0
      /* NOT_CONSTANT */
      ) {
        return keyType;
      }

      if (keyType < returnType) {
        returnType = keyType;
      }

      var valueType = void 0;

      if (value.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14
      /* JS_CALL_EXPRESSION */
      ) {
        // some helper calls can be hoisted,
        // such as the `normalizeProps` generated by the compiler for pre-normalize class,
        // in this case we need to respect the ConstantType of the helper's arguments
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0
        /* NOT_CONSTANT */
        ;
      }

      if (valueType === 0
      /* NOT_CONSTANT */
      ) {
        return valueType;
      }

      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }

  return returnType;
}

function getNodeProps(node) {
  var codegenNode = node.codegenNode;

  if (codegenNode.type === 13
  /* VNODE_CALL */
  ) {
    return codegenNode.props;
  }
}

function getPatchFlag(node) {
  var flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, _ref2) {
  var _ref2$filename = _ref2.filename,
      filename = _ref2$filename === void 0 ? '' : _ref2$filename,
      _ref2$prefixIdentifie = _ref2.prefixIdentifiers,
      prefixIdentifiers = _ref2$prefixIdentifie === void 0 ? false : _ref2$prefixIdentifie,
      _ref2$hoistStatic = _ref2.hoistStatic,
      hoistStatic = _ref2$hoistStatic === void 0 ? false : _ref2$hoistStatic,
      _ref2$cacheHandlers = _ref2.cacheHandlers,
      cacheHandlers = _ref2$cacheHandlers === void 0 ? false : _ref2$cacheHandlers,
      _ref2$nodeTransforms = _ref2.nodeTransforms,
      nodeTransforms = _ref2$nodeTransforms === void 0 ? [] : _ref2$nodeTransforms,
      _ref2$directiveTransf = _ref2.directiveTransforms,
      directiveTransforms = _ref2$directiveTransf === void 0 ? {} : _ref2$directiveTransf,
      _ref2$transformHoist = _ref2.transformHoist,
      transformHoist = _ref2$transformHoist === void 0 ? null : _ref2$transformHoist,
      _ref2$isBuiltInCompon = _ref2.isBuiltInComponent,
      isBuiltInComponent = _ref2$isBuiltInCompon === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref2$isBuiltInCompon,
      _ref2$isCustomElement = _ref2.isCustomElement,
      isCustomElement = _ref2$isCustomElement === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref2$isCustomElement,
      _ref2$expressionPlugi = _ref2.expressionPlugins,
      expressionPlugins = _ref2$expressionPlugi === void 0 ? [] : _ref2$expressionPlugi,
      _ref2$scopeId = _ref2.scopeId,
      scopeId = _ref2$scopeId === void 0 ? null : _ref2$scopeId,
      _ref2$slotted = _ref2.slotted,
      slotted = _ref2$slotted === void 0 ? true : _ref2$slotted,
      _ref2$ssr = _ref2.ssr,
      ssr = _ref2$ssr === void 0 ? false : _ref2$ssr,
      _ref2$inSSR = _ref2.inSSR,
      inSSR = _ref2$inSSR === void 0 ? false : _ref2$inSSR,
      _ref2$ssrCssVars = _ref2.ssrCssVars,
      ssrCssVars = _ref2$ssrCssVars === void 0 ? "" : _ref2$ssrCssVars,
      _ref2$bindingMetadata = _ref2.bindingMetadata,
      bindingMetadata = _ref2$bindingMetadata === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ : _ref2$bindingMetadata,
      _ref2$inline = _ref2.inline,
      inline = _ref2$inline === void 0 ? false : _ref2$inline,
      _ref2$isTS = _ref2.isTS,
      isTS = _ref2$isTS === void 0 ? false : _ref2$isTS,
      _ref2$onError = _ref2.onError,
      onError = _ref2$onError === void 0 ? defaultOnError : _ref2$onError,
      _ref2$onWarn = _ref2.onWarn,
      onWarn = _ref2$onWarn === void 0 ? defaultOnWarn : _ref2$onWarn,
      compatConfig = _ref2.compatConfig;
  var nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
  var context = {
    // options
    selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
    prefixIdentifiers: prefixIdentifiers,
    hoistStatic: hoistStatic,
    cacheHandlers: cacheHandlers,
    nodeTransforms: nodeTransforms,
    directiveTransforms: directiveTransforms,
    transformHoist: transformHoist,
    isBuiltInComponent: isBuiltInComponent,
    isCustomElement: isCustomElement,
    expressionPlugins: expressionPlugins,
    scopeId: scopeId,
    slotted: slotted,
    ssr: ssr,
    inSSR: inSSR,
    ssrCssVars: ssrCssVars,
    bindingMetadata: bindingMetadata,
    inline: inline,
    isTS: isTS,
    onError: onError,
    onWarn: onWarn,
    compatConfig: compatConfig,
    // state
    root: root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper: function helper(name) {
      var count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper: function removeHelper(name) {
      var count = context.helpers.get(name);

      if (count) {
        var currentCount = count - 1;

        if (!currentCount) {
          context.helpers["delete"](name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString: function helperString(name) {
      return "_".concat(helperNameMap[context.helper(name)]);
    },
    replaceNode: function replaceNode(node) {
      /* istanbul ignore if */
      if (true) {
        if (!context.currentNode) {
          throw new Error("Node being replaced is already removed.");
        }

        if (!context.parent) {
          throw new Error("Cannot replace root node.");
        }
      }

      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode: function removeNode(node) {
      if ( true && !context.parent) {
        throw new Error("Cannot remove root node.");
      }

      var list = context.parent.children;
      var removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      /* istanbul ignore if */

      if ( true && removalIndex < 0) {
        throw new Error("node being removed is not a child of current parent");
      }

      if (!node || node === context.currentNode) {
        // current node removed
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        // sibling node removed
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }

      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: function onNodeRemoved() {},
    addIdentifiers: function addIdentifiers(exp) {},
    removeIdentifiers: function removeIdentifiers(exp) {},
    hoist: function hoist(exp) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      var identifier = createSimpleExpression("_hoisted_".concat(context.hoists.length), false, exp.loc, 2
      /* CAN_HOIST */
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache: function cache(exp) {
      var isVNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = new Set();
  }
  return context;
}

function transform(root, options) {
  var context = createTransformContext(root, options);
  traverseNode(root, context);

  if (options.hoistStatic) {
    hoistStatic(root, context);
  }

  if (!options.ssr) {
    createRootCodegen(root, context);
  } // finalize meta information


  root.helpers = _toConsumableArray(context.helpers.keys());
  root.components = _toConsumableArray(context.components);
  root.directives = _toConsumableArray(context.directives);
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = _toConsumableArray(context.filters);
  }
}

function createRootCodegen(root, context) {
  var helper = context.helper;
  var children = root.children;

  if (children.length === 1) {
    var child = children[0]; // if the single child is an element, turn it into a block.

    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // single element root is never hoisted so codegenNode will never be
      // SimpleExpressionNode
      var codegenNode = child.codegenNode;

      if (codegenNode.type === 13
      /* VNODE_CALL */
      ) {
        makeBlock(codegenNode, context);
      }

      root.codegenNode = codegenNode;
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    // root has multiple nodes - return a fragment block.
    var patchFlag = 64
    /* STABLE_FRAGMENT */
    ;
    var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
    // the rest being comments

    if ( true && children.filter(function (c) {
      return c.type !== 3;
    }
    /* COMMENT */
    ).length === 1) {
      patchFlag |= 2048
      /* DEV_ROOT_FRAGMENT */
      ;
      patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
    }

    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true, undefined, false
    /* isComponent */
    );
  } else ;
}

function traverseChildren(parent, context) {
  var i = 0;

  var nodeRemoved = function nodeRemoved() {
    i--;
  };

  for (; i < parent.children.length; i++) {
    var child = parent.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}

function traverseNode(node, context) {
  context.currentNode = node; // apply transform plugins

  var nodeTransforms = context.nodeTransforms;
  var exitFns = [];

  for (var _i5 = 0; _i5 < nodeTransforms.length; _i5++) {
    var onExit = nodeTransforms[_i5](node, context);

    if (onExit) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
        exitFns.push.apply(exitFns, _toConsumableArray(onExit));
      } else {
        exitFns.push(onExit);
      }
    }

    if (!context.currentNode) {
      // node was removed
      return;
    } else {
      // node may have been replaced
      node = context.currentNode;
    }
  }

  switch (node.type) {
    case 3
    /* COMMENT */
    :
      if (!context.ssr) {
        // inject import for the Comment symbol, which is needed for creating
        // comment nodes with `createVNode`
        context.helper(CREATE_COMMENT);
      }

      break;

    case 5
    /* INTERPOLATION */
    :
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }

      break;
    // for container types, further traverse downwards

    case 9
    /* IF */
    :
      for (var _i6 = 0; _i6 < node.branches.length; _i6++) {
        traverseNode(node.branches[_i6], context);
      }

      break;

    case 10
    /* IF_BRANCH */
    :
    case 11
    /* FOR */
    :
    case 1
    /* ELEMENT */
    :
    case 0
    /* ROOT */
    :
      traverseChildren(node, context);
      break;
  } // exit transforms


  context.currentNode = node;
  var i = exitFns.length;

  while (i--) {
    exitFns[i]();
  }
}

function createStructuralDirectiveTransform(name, fn) {
  var matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? function (n) {
    return n === name;
  } : function (n) {
    return name.test(n);
  };
  return function (node, context) {
    if (node.type === 1
    /* ELEMENT */
    ) {
      var props = node.props; // structural directive transforms are not concerned with slots
      // as they are handled separately in vSlot.ts

      if (node.tagType === 3
      /* TEMPLATE */
      && props.some(isVSlot)) {
        return;
      }

      var exitFns = [];

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];

        if (prop.type === 7
        /* DIRECTIVE */
        && matches(prop.name)) {
          // structural directives are removed to avoid infinite recursion
          // also we remove them *before* applying so that it can further
          // traverse itself in case it moves the node around
          props.splice(i, 1);
          i--;
          var onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }

      return exitFns;
    }
  };
}

var PURE_ANNOTATION = "/*#__PURE__*/";

function createCodegenContext(ast, _ref3) {
  var _ref3$mode = _ref3.mode,
      mode = _ref3$mode === void 0 ? 'function' : _ref3$mode,
      _ref3$prefixIdentifie = _ref3.prefixIdentifiers,
      prefixIdentifiers = _ref3$prefixIdentifie === void 0 ? mode === 'module' : _ref3$prefixIdentifie,
      _ref3$sourceMap = _ref3.sourceMap,
      sourceMap = _ref3$sourceMap === void 0 ? false : _ref3$sourceMap,
      _ref3$filename = _ref3.filename,
      filename = _ref3$filename === void 0 ? "template.vue.html" : _ref3$filename,
      _ref3$scopeId = _ref3.scopeId,
      scopeId = _ref3$scopeId === void 0 ? null : _ref3$scopeId,
      _ref3$optimizeImports = _ref3.optimizeImports,
      optimizeImports = _ref3$optimizeImports === void 0 ? false : _ref3$optimizeImports,
      _ref3$runtimeGlobalNa = _ref3.runtimeGlobalName,
      runtimeGlobalName = _ref3$runtimeGlobalNa === void 0 ? "Vue" : _ref3$runtimeGlobalNa,
      _ref3$runtimeModuleNa = _ref3.runtimeModuleName,
      runtimeModuleName = _ref3$runtimeModuleNa === void 0 ? "vue" : _ref3$runtimeModuleNa,
      _ref3$ssrRuntimeModul = _ref3.ssrRuntimeModuleName,
      ssrRuntimeModuleName = _ref3$ssrRuntimeModul === void 0 ? 'vue/server-renderer' : _ref3$ssrRuntimeModul,
      _ref3$ssr = _ref3.ssr,
      ssr = _ref3$ssr === void 0 ? false : _ref3$ssr,
      _ref3$isTS = _ref3.isTS,
      isTS = _ref3$isTS === void 0 ? false : _ref3$isTS,
      _ref3$inSSR = _ref3.inSSR,
      inSSR = _ref3$inSSR === void 0 ? false : _ref3$inSSR;
  var context = {
    mode: mode,
    prefixIdentifiers: prefixIdentifiers,
    sourceMap: sourceMap,
    filename: filename,
    scopeId: scopeId,
    optimizeImports: optimizeImports,
    runtimeGlobalName: runtimeGlobalName,
    runtimeModuleName: runtimeModuleName,
    ssrRuntimeModuleName: ssrRuntimeModuleName,
    ssr: ssr,
    isTS: isTS,
    inSSR: inSSR,
    source: ast.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: undefined,
    helper: function helper(key) {
      return "_".concat(helperNameMap[key]);
    },
    push: function push(code, node) {
      context.code += code;
    },
    indent: function indent() {
      _newline(++context.indentLevel);
    },
    deindent: function deindent() {
      var withoutNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        _newline(--context.indentLevel);
      }
    },
    newline: function newline() {
      _newline(context.indentLevel);
    }
  };

  function _newline(n) {
    context.push('\n' + "  ".repeat(n));
  }

  return context;
}

function generate(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  var mode = context.mode,
      push = context.push,
      prefixIdentifiers = context.prefixIdentifiers,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline,
      scopeId = context.scopeId,
      ssr = context.ssr;
  var hasHelpers = ast.helpers.length > 0;
  var useWithBlock = !prefixIdentifiers && mode !== 'module'; // preambles
  // in setup() inline mode, the preamble is generated in a sub context
  // and returned separately.

  var preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  } // enter render function

  var functionName = ssr ? "ssrRender" : "render";
  var args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
  var signature = args.join(', ');
  {
    push("function ".concat(functionName, "(").concat(signature, ") {"));
  }
  indent();

  if (useWithBlock) {
    push("with (_ctx) {");
    indent(); // function mode const declarations should be inside with block
    // also they should be renamed to avoid collision with user properties

    if (hasHelpers) {
      push("const { ".concat(ast.helpers.map(function (s) {
        return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
      }).join(', '), " } = _Vue"));
      push("\n");
      newline();
    }
  } // generate asset resolution statements


  if (ast.components.length) {
    genAssets(ast.components, 'component', context);

    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }

  if (ast.directives.length) {
    genAssets(ast.directives, 'directive', context);

    if (ast.temps > 0) {
      newline();
    }
  }

  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, 'filter', context);
    newline();
  }

  if (ast.temps > 0) {
    push("let ");

    for (var i = 0; i < ast.temps; i++) {
      push("".concat(i > 0 ? ", " : "", "_temp").concat(i));
    }
  }

  if (ast.components.length || ast.directives.length || ast.temps) {
    push("\n");
    newline();
  } // generate the VNode tree expression


  if (!ssr) {
    push("return ");
  }

  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push("null");
  }

  if (useWithBlock) {
    deindent();
    push("}");
  }

  deindent();
  push("}");
  return {
    ast: ast,
    code: context.code,
    preamble: "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : undefined
  };
}

function genFunctionPreamble(ast, context) {
  var ssr = context.ssr,
      prefixIdentifiers = context.prefixIdentifiers,
      push = context.push,
      newline = context.newline,
      runtimeModuleName = context.runtimeModuleName,
      runtimeGlobalName = context.runtimeGlobalName,
      ssrRuntimeModuleName = context.ssrRuntimeModuleName;
  var VueBinding = runtimeGlobalName;

  var aliasHelper = function aliasHelper(s) {
    return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
  }; // Generate const declaration for helpers
  // In prefix mode, we place the const declaration at top so it's done
  // only once; But if we not prefixing, we place the declaration inside the
  // with block so it doesn't incur the `in` check cost for every helper access.


  if (ast.helpers.length > 0) {
    {
      // "with" mode.
      // save Vue in a separate variable to avoid collision
      push("const _Vue = ".concat(VueBinding, "\n")); // in "with" mode, helpers are declared inside the with block to avoid
      // has check cost, but hoists are lifted out of the function - we need
      // to provide the helper here.

      if (ast.hoists.length) {
        var staticHelpers = [CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC].filter(function (helper) {
          return ast.helpers.includes(helper);
        }).map(aliasHelper).join(', ');
        push("const { ".concat(staticHelpers, " } = _Vue\n"));
      }
    }
  }

  genHoists(ast.hoists, context);
  newline();
  push("return ");
}

function genAssets(assets, type, _ref4) {
  var helper = _ref4.helper,
      push = _ref4.push,
      newline = _ref4.newline,
      isTS = _ref4.isTS;
  var resolver = helper(type === 'filter' ? RESOLVE_FILTER : type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);

  for (var i = 0; i < assets.length; i++) {
    var id = assets[i]; // potential component implicit self-reference inferred from SFC filename

    var maybeSelfReference = id.endsWith('__self');

    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }

    push("const ".concat(toValidAssetId(id, type), " = ").concat(resolver, "(").concat(JSON.stringify(id)).concat(maybeSelfReference ? ", true" : "", ")").concat(isTS ? "!" : ""));

    if (i < assets.length - 1) {
      newline();
    }
  }
}

function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }

  context.pure = true;
  var push = context.push,
      newline = context.newline,
      helper = context.helper,
      scopeId = context.scopeId,
      mode = context.mode;
  newline();

  for (var i = 0; i < hoists.length; i++) {
    var exp = hoists[i];

    if (exp) {
      push("const _hoisted_".concat(i + 1, " = ", ""));
      genNode(exp, context);
      newline();
    }
  }

  context.pure = false;
}

function isText$1(n) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) || n.type === 4
  /* SIMPLE_EXPRESSION */
  || n.type === 2
  /* TEXT */
  || n.type === 5
  /* INTERPOLATION */
  || n.type === 8
  /* COMPOUND_EXPRESSION */
  ;
}

function genNodeListAsArray(nodes, context) {
  var multilines = nodes.length > 3 ||  true && nodes.some(function (n) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n);
  });
  context.push("[");
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push("]");
}

function genNodeList(nodes, context) {
  var multilines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var comma = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var push = context.push,
      newline = context.newline;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
      push(node);
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }

    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(',');
        newline();
      } else {
        comma && push(', ');
      }
    }
  }
}

function genNode(node, context) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
    context.push(node);
    return;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
    context.push(context.helper(node));
    return;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
       true && assert(node.codegenNode != null, "Codegen node is missing for element/if/for node. " + "Apply appropriate transforms first.");
      genNode(node.codegenNode, context);
      break;

    case 2
    /* TEXT */
    :
      genText(node, context);
      break;

    case 4
    /* SIMPLE_EXPRESSION */
    :
      genExpression(node, context);
      break;

    case 5
    /* INTERPOLATION */
    :
      genInterpolation(node, context);
      break;

    case 12
    /* TEXT_CALL */
    :
      genNode(node.codegenNode, context);
      break;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      genCompoundExpression(node, context);
      break;

    case 3
    /* COMMENT */
    :
      genComment(node, context);
      break;

    case 13
    /* VNODE_CALL */
    :
      genVNodeCall(node, context);
      break;

    case 14
    /* JS_CALL_EXPRESSION */
    :
      genCallExpression(node, context);
      break;

    case 15
    /* JS_OBJECT_EXPRESSION */
    :
      genObjectExpression(node, context);
      break;

    case 17
    /* JS_ARRAY_EXPRESSION */
    :
      genArrayExpression(node, context);
      break;

    case 18
    /* JS_FUNCTION_EXPRESSION */
    :
      genFunctionExpression(node, context);
      break;

    case 19
    /* JS_CONDITIONAL_EXPRESSION */
    :
      genConditionalExpression(node, context);
      break;

    case 20
    /* JS_CACHE_EXPRESSION */
    :
      genCacheExpression(node, context);
      break;

    case 21
    /* JS_BLOCK_STATEMENT */
    :
      genNodeList(node.body, context, true, false);
      break;
    // SSR only types

    case 22
    /* JS_TEMPLATE_LITERAL */
    :
      break;

    case 23
    /* JS_IF_STATEMENT */
    :
      break;

    case 24
    /* JS_ASSIGNMENT_EXPRESSION */
    :
      break;

    case 25
    /* JS_SEQUENCE_EXPRESSION */
    :
      break;

    case 26
    /* JS_RETURN_STATEMENT */
    :
      break;

    /* istanbul ignore next */

    case 10
    /* IF_BRANCH */
    :
      // noop
      break;

    default:
      if (true) {
        assert(false, "unhandled codegen node type: ".concat(node.type)); // make sure we exhaust all possible types

        var exhaustiveCheck = node;
        return exhaustiveCheck;
      }

  }
}

function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}

function genExpression(node, context) {
  var content = node.content,
      isStatic = node.isStatic;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}

function genInterpolation(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  if (pure) push(PURE_ANNOTATION);
  push("".concat(helper(TO_DISPLAY_STRING), "("));
  genNode(node.content, context);
  push(")");
}

function genCompoundExpression(node, context) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}

function genExpressionAsPropertyKey(node, context) {
  var push = context.push;

  if (node.type === 8
  /* COMPOUND_EXPRESSION */
  ) {
    push("[");
    genCompoundExpression(node, context);
    push("]");
  } else if (node.isStatic) {
    // only quote keys if necessary
    var text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push("[".concat(node.content, "]"), node);
  }
}

function genComment(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push("".concat(helper(CREATE_COMMENT), "(").concat(JSON.stringify(node.content), ")"), node);
}

function genVNodeCall(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var tag = node.tag,
      props = node.props,
      children = node.children,
      patchFlag = node.patchFlag,
      dynamicProps = node.dynamicProps,
      directives = node.directives,
      isBlock = node.isBlock,
      disableTracking = node.disableTracking,
      isComponent = node.isComponent;

  if (directives) {
    push(helper(WITH_DIRECTIVES) + "(");
  }

  if (isBlock) {
    push("(".concat(helper(OPEN_BLOCK), "(").concat(disableTracking ? "true" : "", "), "));
  }

  if (pure) {
    push(PURE_ANNOTATION);
  }

  var callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + "(", node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(")");

  if (isBlock) {
    push(")");
  }

  if (directives) {
    push(", ");
    genNode(directives, context);
    push(")");
  }
}

function genNullableArgs(args) {
  var i = args.length;

  while (i--) {
    if (args[i] != null) break;
  }

  return args.slice(0, i + 1).map(function (arg) {
    return arg || "null";
  });
} // JavaScript


function genCallExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push(callee + "(", node);
  genNodeList(node.arguments, context);
  push(")");
}

function genObjectExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  var properties = node.properties;

  if (!properties.length) {
    push("{}", node);
    return;
  }

  var multilines = properties.length > 1 ||  true && properties.some(function (p) {
    return p.value.type !== 4;
  }
  /* SIMPLE_EXPRESSION */
  );
  push(multilines ? "{" : "{ ");
  multilines && indent();

  for (var i = 0; i < properties.length; i++) {
    var _properties$i2 = properties[i],
        key = _properties$i2.key,
        value = _properties$i2.value; // key

    genExpressionAsPropertyKey(key, context);
    push(": "); // value

    genNode(value, context);

    if (i < properties.length - 1) {
      // will only reach this if it's multilines
      push(",");
      newline();
    }
  }

  multilines && deindent();
  push(multilines ? "}" : " }");
}

function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}

function genFunctionExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent;
  var params = node.params,
      returns = node.returns,
      body = node.body,
      newline = node.newline,
      isSlot = node.isSlot;

  if (isSlot) {
    // wrap slot functions with owner context
    push("_".concat(helperNameMap[WITH_CTX], "("));
  }

  push("(", node);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }

  push(") => ");

  if (newline || body) {
    push("{");
    indent();
  }

  if (returns) {
    if (newline) {
      push("return ");
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }

  if (newline || body) {
    deindent();
    push("}");
  }

  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(", undefined, true");
    }

    push(")");
  }
}

function genConditionalExpression(node, context) {
  var test = node.test,
      consequent = node.consequent,
      alternate = node.alternate,
      needNewline = node.newline;
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;

  if (test.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
    var needsParens = !isSimpleIdentifier(test.content);
    needsParens && push("(");
    genExpression(test, context);
    needsParens && push(")");
  } else {
    push("(");
    genNode(test, context);
    push(")");
  }

  needNewline && indent();
  context.indentLevel++;
  needNewline || push(" ");
  push("? ");
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(" ");
  push(": ");
  var isNested = alternate.type === 19
  /* JS_CONDITIONAL_EXPRESSION */
  ;

  if (!isNested) {
    context.indentLevel++;
  }

  genNode(alternate, context);

  if (!isNested) {
    context.indentLevel--;
  }

  needNewline && deindent(true
  /* without newline */
  );
}

function genCacheExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  push("_cache[".concat(node.index, "] || ("));

  if (node.isVNode) {
    indent();
    push("".concat(helper(SET_BLOCK_TRACKING), "(-1),"));
    newline();
  }

  push("_cache[".concat(node.index, "] = "));
  genNode(node.value, context);

  if (node.isVNode) {
    push(",");
    newline();
    push("".concat(helper(SET_BLOCK_TRACKING), "(1),"));
    newline();
    push("_cache[".concat(node.index, "]"));
    deindent();
  }

  push(")");
}

function walkIdentifiers(root, onIdentifier) {
  var includeAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var parentStack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var knownIds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Object.create(null);
  {
    return;
  }
}

function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}

function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
    var i = parentStack.length;

    while (i--) {
      var p = parentStack[i];

      if (p.type === 'AssignmentExpression') {
        return true;
      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
        break;
      }
    }
  }

  return false;
}

function walkFunctionParams(node, onIdent) {
  var _iterator = _createForOfIteratorHelper(node.params),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var p = _step.value;

      var _iterator2 = _createForOfIteratorHelper(extractIdentifiers(p)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var id = _step2.value;
          onIdent(id);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function walkBlockDeclarations(block, onIdent) {
  var _iterator3 = _createForOfIteratorHelper(block.body),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var stmt = _step3.value;

      if (stmt.type === 'VariableDeclaration') {
        if (stmt.declare) continue;

        var _iterator4 = _createForOfIteratorHelper(stmt.declarations),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var decl = _step4.value;

            var _iterator5 = _createForOfIteratorHelper(extractIdentifiers(decl.id)),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var id = _step5.value;
                onIdent(id);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else if (stmt.type === 'FunctionDeclaration' || stmt.type === 'ClassDeclaration') {
        if (stmt.declare || !stmt.id) continue;
        onIdent(stmt.id);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function extractIdentifiers(param) {
  var nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  switch (param.type) {
    case 'Identifier':
      nodes.push(param);
      break;

    case 'MemberExpression':
      var object = param;

      while (object.type === 'MemberExpression') {
        object = object.object;
      }

      nodes.push(object);
      break;

    case 'ObjectPattern':
      var _iterator6 = _createForOfIteratorHelper(param.properties),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var prop = _step6.value;

          if (prop.type === 'RestElement') {
            extractIdentifiers(prop.argument, nodes);
          } else {
            extractIdentifiers(prop.value, nodes);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      break;

    case 'ArrayPattern':
      param.elements.forEach(function (element) {
        if (element) extractIdentifiers(element, nodes);
      });
      break;

    case 'RestElement':
      extractIdentifiers(param.argument, nodes);
      break;

    case 'AssignmentPattern':
      extractIdentifiers(param.left, nodes);
      break;
  }

  return nodes;
}

var isFunctionType = function isFunctionType(node) {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};

var isStaticProperty = function isStaticProperty(node) {
  return node && (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') && !node.computed;
};

var isStaticPropertyKey = function isStaticPropertyKey(node, parent) {
  return isStaticProperty(parent) && parent.key === node;
}; // these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments,typeof,void').split(',').join('\\b|\\b') + '\\b'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */

function validateBrowserExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var exp = node.content; // empty expressions are validated per-directive since some directives
  // do allow empty expressions.

  if (!exp.trim()) {
    return;
  }

  try {
    new Function(asRawStatements ? " ".concat(exp, " ") : "return ".concat(asParams ? "(".concat(exp, ") => {}") : "(".concat(exp, ")")));
  } catch (e) {
    var message = e.message;
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      message = "avoid using JavaScript keyword as property name: \"".concat(keywordMatch[0], "\"");
    }

    context.onError(createCompilerError(44
    /* X_INVALID_EXPRESSION */
    , node.loc, undefined, message));
  }
}

var transformExpression = function transformExpression(node, context) {
  if (node.type === 5
  /* INTERPOLATION */
  ) {
    node.content = processExpression(node.content, context);
  } else if (node.type === 1
  /* ELEMENT */
  ) {
    // handle directives on element
    for (var i = 0; i < node.props.length; i++) {
      var dir = node.props[i]; // do not process for v-on & v-for since they are special handled

      if (dir.type === 7
      /* DIRECTIVE */
      && dir.name !== 'for') {
        var exp = dir.exp;
        var arg = dir.arg; // do not process exp if this is v-on:arg - we need special handling
        // for wrapping inline statements.

        if (exp && exp.type === 4
        /* SIMPLE_EXPRESSION */
        && !(dir.name === 'on' && arg)) {
          dir.exp = processExpression(exp, context, // slot args must be processed as function params
          dir.name === 'slot');
        }

        if (arg && arg.type === 4
        /* SIMPLE_EXPRESSION */
        && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
}; // Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.


function processExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var localVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Object.create(context.identifiers);
  {
    if (true) {
      // simple in-browser validation (same logic in 2.x)
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }

    return node;
  }
}

var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, function (node, dir, context) {
  return processIf(node, dir, context, function (ifNode, branch, isRoot) {
    // #1587: We need to dynamically increment the key based on the current
    // node's sibling nodes, since chained v-if/else branches are
    // rendered at the same depth
    var siblings = context.parent.children;
    var i = siblings.indexOf(ifNode);
    var key = 0;

    while (i-- >= 0) {
      var sibling = siblings[i];

      if (sibling && sibling.type === 9
      /* IF */
      ) {
        key += sibling.branches.length;
      }
    } // Exit callback. Complete the codegenNode when all children have been
    // transformed.


    return function () {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        // attach this branch's codegen node to the v-if root.
        var parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processIf(node, dir, context, processCodegen) {
  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {
    var loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28
    /* X_V_IF_NO_EXPRESSION */
    , dir.loc));
    dir.exp = createSimpleExpression("true", false, loc);
  }

  if ( true && dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }

  if (dir.name === 'if') {
    var branch = createIfBranch(node, dir);
    var ifNode = {
      type: 9
      /* IF */
      ,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);

    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    // locate the adjacent v-if
    var siblings = context.parent.children;
    var comments = [];
    var i = siblings.indexOf(node);

    while (i-- >= -1) {
      var sibling = siblings[i];

      if ( true && sibling && sibling.type === 3
      /* COMMENT */
      ) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }

      if (sibling && sibling.type === 2
      /* TEXT */
      && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }

      if (sibling && sibling.type === 9
      /* IF */
      ) {
        (function () {
          // Check if v-else was followed by v-else-if
          if (dir.name === 'else-if' && sibling.branches[sibling.branches.length - 1].condition === undefined) {
            context.onError(createCompilerError(30
            /* X_V_ELSE_NO_ADJACENT_IF */
            , node.loc));
          } // move the node to the if node's branches


          context.removeNode();
          var branch = createIfBranch(node, dir);

          if ( true && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
          !(context.parent && context.parent.type === 1
          /* ELEMENT */
          && isBuiltInType(context.parent.tag, 'transition'))) {
            branch.children = [].concat(comments, _toConsumableArray(branch.children));
          } // check if user is forcing same key on different branches


          if (true) {
            var key = branch.userKey;

            if (key) {
              sibling.branches.forEach(function (_ref5) {
                var userKey = _ref5.userKey;

                if (isSameKey(userKey, key)) {
                  context.onError(createCompilerError(29
                  /* X_V_IF_SAME_KEY */
                  , branch.userKey.loc));
                }
              });
            }
          }

          sibling.branches.push(branch);
          var onExit = processCodegen && processCodegen(sibling, branch, false); // since the branch was removed, it will not be traversed.
          // make sure to traverse here.

          traverseNode(branch, context); // call on exit

          if (onExit) onExit(); // make sure to reset currentNode after traversal to indicate this
          // node has been removed.

          context.currentNode = null;
        })();
      } else {
        context.onError(createCompilerError(30
        /* X_V_ELSE_NO_ADJACENT_IF */
        , node.loc));
      }

      break;
    }
  }
}

function createIfBranch(node, dir) {
  return {
    type: 10
    /* IF_BRANCH */
    ,
    loc: node.loc,
    condition: dir.name === 'else' ? undefined : dir.exp,
    children: node.tagType === 3
    /* TEMPLATE */
    && !findDir(node, 'for') ? node.children : [node],
    userKey: findProp(node, "key")
  };
}

function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    createCallExpression(context.helper(CREATE_COMMENT), [ true ? '"v-if"' : 0, 'true']));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}

function createChildrenCodegenNode(branch, keyIndex, context) {
  var helper = context.helper;
  var keyProperty = createObjectProperty("key", createSimpleExpression("".concat(keyIndex), false, locStub, 2
  /* CAN_HOIST */
  ));
  var children = branch.children;
  var firstChild = children[0];
  var needFragmentWrapper = children.length !== 1 || firstChild.type !== 1
  /* ELEMENT */
  ;

  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11
    /* FOR */
    ) {
      // optimize away nested fragments when child is a ForNode
      var vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      var patchFlag = 64
      /* STABLE_FRAGMENT */
      ;
      var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
      // the rest being comments

      if ( true && children.filter(function (c) {
        return c.type !== 3;
      }
      /* COMMENT */
      ).length === 1) {
        patchFlag |= 2048
        /* DEV_ROOT_FRAGMENT */
        ;
        patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
      }

      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true, false, false
      /* isComponent */
      , branch.loc);
    }
  } else {
    var ret = firstChild.codegenNode;

    var _vnodeCall = getMemoedVNodeCall(ret); // Change createVNode to createBlock.


    if (_vnodeCall.type === 13
    /* VNODE_CALL */
    ) {
      makeBlock(_vnodeCall, context);
    } // inject branch key


    injectProp(_vnodeCall, keyProperty, context);
    return ret;
  }
}

function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }

  if (a.type === 6
  /* ATTRIBUTE */
  ) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    // directive
    var exp = a.exp;
    var branchExp = b.exp;

    if (exp.type !== branchExp.type) {
      return false;
    }

    if (exp.type !== 4
    /* SIMPLE_EXPRESSION */
    || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }

  return true;
}

function getParentCondition(node) {
  while (true) {
    if (node.type === 19
    /* JS_CONDITIONAL_EXPRESSION */
    ) {
      if (node.alternate.type === 19
      /* JS_CONDITIONAL_EXPRESSION */
      ) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20
    /* JS_CACHE_EXPRESSION */
    ) {
      node = node.value;
    }
  }
}

var transformFor = createStructuralDirectiveTransform('for', function (node, dir, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  return processFor(node, dir, context, function (forNode) {
    // create the loop render function expression now, and add the
    // iterator on exit after all children have been traversed
    var renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
    var isTemplate = isTemplateNode(node);
    var memo = findDir(node, 'memo');
    var keyProp = findProp(node, "key");
    var keyExp = keyProp && (keyProp.type === 6
    /* ATTRIBUTE */
    ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    var keyProperty = keyProp ? createObjectProperty("key", keyExp) : null;
    var isStableFragment = forNode.source.type === 4
    /* SIMPLE_EXPRESSION */
    && forNode.source.constType > 0
    /* NOT_CONSTANT */
    ;
    var fragmentFlag = isStableFragment ? 64
    /* STABLE_FRAGMENT */
    : keyProp ? 128
    /* KEYED_FRAGMENT */
    : 256
    /* UNKEYED_FRAGMENT */
    ;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag], " */") : 0), undefined, undefined, true
    /* isBlock */
    , !isStableFragment
    /* disableTracking */
    , false
    /* isComponent */
    , node.loc);
    return function () {
      // finish the codegen now that all children have been traversed
      var childBlock;
      var children = forNode.children; // check <template v-for> key placement

      if (( true) && isTemplate) {
        node.children.some(function (c) {
          if (c.type === 1
          /* ELEMENT */
          ) {
            var key = findProp(c, 'key');

            if (key) {
              context.onError(createCompilerError(33
              /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
              , key.loc));
              return true;
            }
          }
        });
      }

      var needFragmentWrapper = children.length !== 1 || children[0].type !== 1
      /* ELEMENT */
      ;
      var slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] // api-extractor somehow fails to infer this
      : null;

      if (slotOutlet) {
        // <slot v-for="..."> or <template v-for="..."><slot/></template>
        childBlock = slotOutlet.codegenNode;

        if (isTemplate && keyProperty) {
          // <template v-for="..." :key="..."><slot/></template>
          // we need to inject the key to the renderSlot() call.
          // the props for renderSlot is passed as the 3rd argument.
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        // <template v-for="..."> with text or multi-elements
        // should generate a fragment block for each loop
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64
        /* STABLE_FRAGMENT */
        + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64], " */") : 0), undefined, undefined, true, undefined, false
        /* isComponent */
        );
      } else {
        // Normal element v-for. Directly use the child's codegenNode
        // but mark it as a block.
        childBlock = children[0].codegenNode;

        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }

        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            // switch from block to vnode
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            // switch from vnode to block
            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }

        childBlock.isBlock = !isStableFragment;

        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
        }
      }

      if (memo) {
        var loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [createSimpleExpression("_cached")]));
        loop.body = createBlockStatement([createCompoundExpression(["const _memo = (", memo.exp, ")"]), createCompoundExpression(["if (_cached"].concat(_toConsumableArray(keyExp ? [" && _cached.key === ", keyExp] : []), [" && ".concat(context.helperString(IS_MEMO_SAME), "(_cached, _memo)) return _cached")])), createCompoundExpression(["const _item = ", childBlock]), createSimpleExpression("_item.memo = _memo"), createSimpleExpression("return _item")]);
        renderExp.arguments.push(loop, createSimpleExpression("_cache"), createSimpleExpression(String(context.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true
        /* force newline */
        ));
      }
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31
    /* X_V_FOR_NO_EXPRESSION */
    , dir.loc));
    return;
  }

  var parseResult = parseForExpression( // can only be simple expression because vFor transform is applied
  // before expression transform.
  dir.exp, context);

  if (!parseResult) {
    context.onError(createCompilerError(32
    /* X_V_FOR_MALFORMED_EXPRESSION */
    , dir.loc));
    return;
  }

  var addIdentifiers = context.addIdentifiers,
      removeIdentifiers = context.removeIdentifiers,
      scopes = context.scopes;
  var source = parseResult.source,
      value = parseResult.value,
      key = parseResult.key,
      index = parseResult.index;
  var forNode = {
    type: 11
    /* FOR */
    ,
    loc: dir.loc,
    source: source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult: parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode); // bookkeeping

  scopes.vFor++;
  var onExit = processCodegen && processCodegen(forNode);
  return function () {
    scopes.vFor--;
    if (onExit) onExit();
  };
}

var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/; // This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.

var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

function parseForExpression(input, context) {
  var loc = input.loc;
  var exp = input.content;
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) return;

  var _inMatch = _slicedToArray(inMatch, 3),
      LHS = _inMatch[1],
      RHS = _inMatch[2];

  var result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: undefined,
    key: undefined,
    index: undefined
  };

  if (true) {
    validateBrowserExpression(result.source, context);
  }

  var valueContent = LHS.trim().replace(stripParensRE, '').trim();
  var trimmedOffset = LHS.indexOf(valueContent);
  var iteratorMatch = valueContent.match(forIteratorRE);

  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, '').trim();
    var keyContent = iteratorMatch[1].trim();
    var keyOffset;

    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);

      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }

    if (iteratorMatch[2]) {
      var indexContent = iteratorMatch[2].trim();

      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));

        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }

  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);

    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }

  return result;
}

function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}

function createForLoopParams(_ref6) {
  var value = _ref6.value,
      key = _ref6.key,
      index = _ref6.index;
  var memoArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return createParamsList([value, key, index].concat(_toConsumableArray(memoArgs)));
}

function createParamsList(args) {
  var i = args.length;

  while (i--) {
    if (args[i]) break;
  }

  return args.slice(0, i + 1).map(function (arg, i) {
    return arg || createSimpleExpression("_".repeat(i + 1), false);
  });
}

var defaultFallback = createSimpleExpression("undefined", false); // A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.

var trackSlotScopes = function trackSlotScopes(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && (node.tagType === 1
  /* COMPONENT */
  || node.tagType === 3
  /* TEMPLATE */
  )) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    var vSlot = findDir(node, 'slot');

    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return function () {
        context.scopes.vSlot--;
      };
    }
  }
}; // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }


var trackVForSlotScopes = function trackVForSlotScopes(node, context) {
  var vFor;

  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, 'for'))) {
    var result = vFor.parseResult = parseForExpression(vFor.exp, context);

    if (result) {
      var value = result.value,
          key = result.key,
          index = result.index;
      var addIdentifiers = context.addIdentifiers,
          removeIdentifiers = context.removeIdentifiers;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return function () {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};

var buildClientSlotFn = function buildClientSlotFn(props, children, loc) {
  return createFunctionExpression(props, children, false
  /* newline */
  , true
  /* isSlot */
  , children.length ? children[0].loc : loc);
}; // Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.


function buildSlots(node, context) {
  var buildSlotFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buildClientSlotFn;
  context.helper(WITH_CTX);
  var children = node.children,
      loc = node.loc;
  var slotsProperties = [];
  var dynamicSlots = []; // If the slot is inside a v-for or another v-slot, force it to be dynamic
  // since it likely uses a scope variable.

  var hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0; // 1. Check for slot with slotProps on component itself.
  //    <Comp v-slot="{ prop }"/>

  var onComponentSlot = findDir(node, 'slot', true);

  if (onComponentSlot) {
    var arg = onComponentSlot.arg,
        exp = onComponentSlot.exp;

    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }

    slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
  } // 2. Iterate through children and check for template slots
  //    <template v-slot:foo="{ prop }">


  var hasTemplateSlots = false;
  var hasNamedDefaultSlot = false;
  var implicitDefaultChildren = [];
  var seenSlotNames = new Set();

  for (var i = 0; i < children.length; i++) {
    var slotElement = children[i];
    var slotDir = void 0;

    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, 'slot', true))) {
      // not a <template v-slot>, skip.
      if (slotElement.type !== 3
      /* COMMENT */
      ) {
        implicitDefaultChildren.push(slotElement);
      }

      continue;
    }

    if (onComponentSlot) {
      // already has on-component slot - this is incorrect usage.
      context.onError(createCompilerError(37
      /* X_V_SLOT_MIXED_SLOT_USAGE */
      , slotDir.loc));
      break;
    }

    hasTemplateSlots = true;
    var slotChildren = slotElement.children,
        slotLoc = slotElement.loc;
    var _slotDir = slotDir,
        _slotDir$arg = _slotDir.arg,
        slotName = _slotDir$arg === void 0 ? createSimpleExpression("default", true) : _slotDir$arg,
        slotProps = _slotDir.exp,
        dirLoc = _slotDir.loc; // check if name is dynamic.

    var staticSlotName = void 0;

    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : "default";
    } else {
      hasDynamicSlots = true;
    }

    var slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc); // check if this slot is conditional (v-if/v-for)

    var vIf = void 0;
    var vElse = void 0;
    var vFor = void 0;

    if (vIf = findDir(slotElement, 'if')) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true
    /* allowEmpty */
    )) {
      // find adjacent v-if
      var j = i;
      var prev = void 0;

      while (j--) {
        prev = children[j];

        if (prev.type !== 3
        /* COMMENT */
        ) {
          break;
        }
      }

      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
        // remove node
        children.splice(i, 1);
        i--; // attach this slot to previous conditional

        var conditional = dynamicSlots[dynamicSlots.length - 1];

        while (conditional.alternate.type === 19
        /* JS_CONDITIONAL_EXPRESSION */
        ) {
          conditional = conditional.alternate;
        }

        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30
        /* X_V_ELSE_NO_ADJACENT_IF */
        , vElse.loc));
      }
    } else if (vFor = findDir(slotElement, 'for')) {
      hasDynamicSlots = true;
      var parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);

      if (parseResult) {
        // Render the dynamic slots as an array and add it to the createSlot()
        // args. The runtime knows how to handle it appropriately.
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true
        /* force newline */
        )]));
      } else {
        context.onError(createCompilerError(32
        /* X_V_FOR_MALFORMED_EXPRESSION */
        , vFor.loc));
      }
    } else {
      // check duplicate static names
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38
          /* X_V_SLOT_DUPLICATE_SLOT_NAMES */
          , dirLoc));
          continue;
        }

        seenSlotNames.add(staticSlotName);

        if (staticSlotName === 'default') {
          hasNamedDefaultSlot = true;
        }
      }

      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }

  if (!onComponentSlot) {
    var buildDefaultSlotProperty = function buildDefaultSlotProperty(props, children) {
      var fn = buildSlotFn(props, children, loc);

      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }

      return createObjectProperty("default", fn);
    };

    if (!hasTemplateSlots) {
      // implicit default slot (on component)
      slotsProperties.push(buildDefaultSlotProperty(undefined, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some(function (node) {
      return isNonWhitespaceContent(node);
    })) {
      // implicit default slot (mixed with named slots)
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39
        /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
        , implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
      }
    }
  }

  var slotFlag = hasDynamicSlots ? 2
  /* DYNAMIC */
  : hasForwardedSlots(node.children) ? 3
  /* FORWARDED */
  : 1
  /* STABLE */
  ;
  var slots = createObjectExpression(slotsProperties.concat(createObjectProperty("_", // 2 = compiled but dynamic = can skip normalization, but must run diff
  // 1 = compiled and static = can skip normalization AND diff as optimized
  createSimpleExpression(slotFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag], " */") : 0), false))), loc);

  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
  }

  return {
    slots: slots,
    hasDynamicSlots: hasDynamicSlots
  };
}

function buildDynamicSlot(name, fn) {
  return createObjectExpression([createObjectProperty("name", name), createObjectProperty("fn", fn)]);
}

function hasForwardedSlots(children) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    switch (child.type) {
      case 1
      /* ELEMENT */
      :
        if (child.tagType === 2
        /* SLOT */
        || hasForwardedSlots(child.children)) {
          return true;
        }

        break;

      case 9
      /* IF */
      :
        if (hasForwardedSlots(child.branches)) return true;
        break;

      case 10
      /* IF_BRANCH */
      :
      case 11
      /* FOR */
      :
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }

  return false;
}

function isNonWhitespaceContent(node) {
  if (node.type !== 2
  /* TEXT */
  && node.type !== 12
  /* TEXT_CALL */
  ) return true;
  return node.type === 2
  /* TEXT */
  ? !!node.content.trim() : isNonWhitespaceContent(node.content);
} // some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.


var directiveImportMap = new WeakMap(); // generate a JavaScript AST for this element's codegen

var transformElement = function transformElement(node, context) {
  // perform the work on exit, after all child expressions have been
  // processed and merged.
  return function postTransformElement() {
    node = context.currentNode;

    if (!(node.type === 1
    /* ELEMENT */
    && (node.tagType === 0
    /* ELEMENT */
    || node.tagType === 1
    /* COMPONENT */
    ))) {
      return;
    }

    var _node3 = node,
        tag = _node3.tag,
        props = _node3.props;
    var isComponent = node.tagType === 1
    /* COMPONENT */
    ; // The goal of the transform is to create a codegenNode implementing the
    // VNodeCall interface.

    var vnodeTag = isComponent ? resolveComponentType(node, context) : "\"".concat(tag, "\"");
    var isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    var vnodeProps;
    var vnodeChildren;
    var vnodePatchFlag;
    var patchFlag = 0;
    var vnodeDynamicProps;
    var dynamicPropNames;
    var vnodeDirectives;
    var shouldUseBlock = // dynamic component may resolve to plain elements
    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && ( // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    tag === 'svg' || tag === 'foreignObject'); // props

    if (props.length > 0) {
      var propsBuildResult = buildProps(node, context);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      var directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(function (dir) {
        return buildDirectiveArgs(dir, context);
      })) : undefined;

      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    } // children


    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        // Although a built-in component, we compile KeepAlive with raw children
        // instead of slot functions so that it can be used inside Transition
        // or other Transition-wrapping HOCs.
        // To ensure correct updates with block optimizations, we need to:
        // 1. Force keep-alive into a block. This avoids its children being
        //    collected by a parent block.
        shouldUseBlock = true; // 2. Force keep-alive to always be updated, since it uses raw children.

        patchFlag |= 1024
        /* DYNAMIC_SLOTS */
        ;

        if ( true && node.children.length > 1) {
          context.onError(createCompilerError(45
          /* X_KEEP_ALIVE_INVALID_CHILDREN */
          , {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ''
          }));
        }
      }

      var shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;

      if (shouldBuildAsSlots) {
        var _buildSlots = buildSlots(node, context),
            slots = _buildSlots.slots,
            hasDynamicSlots = _buildSlots.hasDynamicSlots;

        vnodeChildren = slots;

        if (hasDynamicSlots) {
          patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        var child = node.children[0];
        var type = child.type; // check for dynamic text children

        var hasDynamicTextChild = type === 5
        /* INTERPOLATION */
        || type === 8
        /* COMPOUND_EXPRESSION */
        ;

        if (hasDynamicTextChild && getConstantType(child, context) === 0
        /* NOT_CONSTANT */
        ) {
          patchFlag |= 1
          /* TEXT */
          ;
        } // pass directly if the only child is a text node
        // (plain / interpolation / expression)


        if (hasDynamicTextChild || type === 2
        /* TEXT */
        ) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    } // patchFlag & dynamicPropNames


    if (patchFlag !== 0) {
      if (true) {
        if (patchFlag < 0) {
          // special flags (negative and mutually exclusive)
          vnodePatchFlag = patchFlag + " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag], " */");
        } else {
          // bitwise flags
          var flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames).map(Number).filter(function (n) {
            return n > 0 && patchFlag & n;
          }).map(function (n) {
            return _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n];
          }).join(", ");
          vnodePatchFlag = patchFlag + " /* ".concat(flagNames, " */");
        }
      } else {}

      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }

    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false
    /* disableTracking */
    , isComponent, node.loc);
  };
};

function resolveComponentType(node, context) {
  var ssr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var tag = node.tag; // 1. dynamic component

  var isExplicitDynamic = isComponentTag(tag);
  var isProp = findProp(node, 'is');

  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT"
    /* COMPILER_IS_ON_ELEMENT */
    , context)) {
      var exp = isProp.type === 6
      /* ATTRIBUTE */
      ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;

      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
      }
    } else if (isProp.type === 6
    /* ATTRIBUTE */
    && isProp.value.content.startsWith('vue:')) {
      // <button is="vue:xxx">
      // if not <component>, only is value that starts with "vue:" will be
      // treated as component by the parse phase and reach here, unless it's
      // compat mode where all is values are considered components
      tag = isProp.value.content.slice(4);
    }
  } // 1.5 v-is (TODO: Deprecate)


  var isDir = !isExplicitDynamic && findDir(node, 'is');

  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [isDir.exp]);
  } // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)


  var builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);

  if (builtIn) {
    // built-ins are simply fallthroughs / have special handling during ssr
    // so we don't need to import their runtime equivalents
    if (!ssr) context.helper(builtIn);
    return builtIn;
  } // 5. user component (resolve)


  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, "component");
}

function buildProps(node, context) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.props;
  var ssr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var tag = node.tag,
      elementLoc = node.loc,
      children = node.children;
  var isComponent = node.tagType === 1
  /* COMPONENT */
  ;
  var properties = [];
  var mergeArgs = [];
  var runtimeDirectives = [];
  var hasChildren = children.length > 0;
  var shouldUseBlock = false; // patchFlag analysis

  var patchFlag = 0;
  var hasRef = false;
  var hasClassBinding = false;
  var hasStyleBinding = false;
  var hasHydrationEventBinding = false;
  var hasDynamicKeys = false;
  var hasVnodeHook = false;
  var dynamicPropNames = [];

  var analyzePatchFlag = function analyzePatchFlag(_ref7) {
    var key = _ref7.key,
        value = _ref7.value;

    if (isStaticExp(key)) {
      var name = key.content;
      var isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);

      if (!isComponent && isEventHandler && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== 'onclick' && // omit v-model handlers
      name !== 'onUpdate:modelValue' && // omit onVnodeXXX hooks
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasHydrationEventBinding = true;
      }

      if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasVnodeHook = true;
      }

      if (value.type === 20
      /* JS_CACHE_EXPRESSION */
      || (value.type === 4
      /* SIMPLE_EXPRESSION */
      || value.type === 8
      /* COMPOUND_EXPRESSION */
      ) && getConstantType(value, context) > 0) {
        // skip if the prop is a cached handler or has constant value
        return;
      }

      if (name === 'ref') {
        hasRef = true;
      } else if (name === 'class') {
        hasClassBinding = true;
      } else if (name === 'style') {
        hasStyleBinding = true;
      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      } // treat the dynamic class and style binding of the component as dynamic props


      if (isComponent && (name === 'class' || name === 'style') && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };

  for (var i = 0; i < props.length; i++) {
    // static attribute
    var prop = props[i];

    if (prop.type === 6
    /* ATTRIBUTE */
    ) {
      var loc = prop.loc,
          name = prop.name,
          value = prop.value;
      var isStatic = true;

      if (name === 'ref') {
        hasRef = true;

        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
        }
      } // skip is on <component>, or is="vue:xxx"


      if (name === 'is' && (isComponentTag(tag) || value && value.content.startsWith('vue:') || isCompatEnabled("COMPILER_IS_ON_ELEMENT"
      /* COMPILER_IS_ON_ELEMENT */
      , context))) {
        continue;
      }

      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
    } else {
      // directives
      var _name = prop.name,
          arg = prop.arg,
          exp = prop.exp,
          _loc2 = prop.loc;
      var isVBind = _name === 'bind';
      var isVOn = _name === 'on'; // skip v-slot - it is handled by its dedicated transform.

      if (_name === 'slot') {
        if (!isComponent) {
          context.onError(createCompilerError(40
          /* X_V_SLOT_MISPLACED */
          , _loc2));
        }

        continue;
      } // skip v-once/v-memo - they are handled by dedicated transforms.


      if (_name === 'once' || _name === 'memo') {
        continue;
      } // skip v-is and :is on <component>


      if (_name === 'is' || isVBind && isStaticArgOf(arg, 'is') && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT"
      /* COMPILER_IS_ON_ELEMENT */
      , context))) {
        continue;
      } // skip v-on in SSR compilation


      if (isVOn && ssr) {
        continue;
      }

      if ( // #938: elements with dynamic keys should be forced into blocks
      isVBind && isStaticArgOf(arg, 'key') || // inline before-update hooks need to force block so that it is invoked
      // before children
      isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update')) {
        shouldUseBlock = true;
      }

      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
      } // special case for v-bind and v-on with no argument


      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;

        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }

          if (isVBind) {
            {
              // 2.x v-bind object order compat
              if (true) {
                var hasOverridableKeys = mergeArgs.some(function (arg) {
                  if (arg.type === 15
                  /* JS_OBJECT_EXPRESSION */
                  ) {
                    return arg.properties.some(function (_ref8) {
                      var key = _ref8.key;

                      if (key.type !== 4
                      /* SIMPLE_EXPRESSION */
                      || !key.isStatic) {
                        return true;
                      }

                      return key.content !== 'class' && key.content !== 'style' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content);
                    });
                  } else {
                    // dynamic expression
                    return true;
                  }
                });

                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
                  /* COMPILER_V_BIND_OBJECT_ORDER */
                  , context, _loc2);
                }
              }

              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
              /* COMPILER_V_BIND_OBJECT_ORDER */
              , context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            // v-on="obj" -> toHandlers(obj)
            mergeArgs.push({
              type: 14
              /* JS_CALL_EXPRESSION */
              ,
              loc: _loc2,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34
          /* X_V_BIND_NO_EXPRESSION */
          : 35
          /* X_V_ON_NO_EXPRESSION */
          , _loc2));
        }

        continue;
      }

      var directiveTransform = context.directiveTransforms[_name];

      if (directiveTransform) {
        var _properties;

        // has built-in directive transform.
        var _directiveTransform = directiveTransform(prop, node, context),
            _props = _directiveTransform.props,
            needRuntime = _directiveTransform.needRuntime;

        !ssr && _props.forEach(analyzePatchFlag);

        (_properties = properties).push.apply(_properties, _toConsumableArray(_props));

        if (needRuntime) {
          runtimeDirectives.push(prop);

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(_name)) {
        // no built-in transform, this is a user custom directive.
        runtimeDirectives.push(prop); // custom dirs may use beforeUpdate so they need to force blocks
        // to ensure before-update gets called before children update

        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }

  var propsExpression = undefined; // has v-bind="object" or v-on="object", wrap with mergeProps

  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }

    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      // single v-bind with nothing else - no need for a mergeProps call
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  } // patchFlag analysis


  if (hasDynamicKeys) {
    patchFlag |= 16
    /* FULL_PROPS */
    ;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2
      /* CLASS */
      ;
    }

    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4
      /* STYLE */
      ;
    }

    if (dynamicPropNames.length) {
      patchFlag |= 8
      /* PROPS */
      ;
    }

    if (hasHydrationEventBinding) {
      patchFlag |= 32
      /* HYDRATE_EVENTS */
      ;
    }
  }

  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32
  /* HYDRATE_EVENTS */
  ) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512
    /* NEED_PATCH */
    ;
  } // pre-normalize props, SSR is skipped for now


  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15
      /* JS_OBJECT_EXPRESSION */
      :
        // means that there is no v-bind,
        // but still need to deal with dynamic key binding
        var classKeyIndex = -1;
        var styleKeyIndex = -1;
        var hasDynamicKey = false;

        for (var _i7 = 0; _i7 < propsExpression.properties.length; _i7++) {
          var key = propsExpression.properties[_i7].key;

          if (isStaticExp(key)) {
            if (key.content === 'class') {
              classKeyIndex = _i7;
            } else if (key.content === 'style') {
              styleKeyIndex = _i7;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }

        var classProp = propsExpression.properties[classKeyIndex];
        var styleProp = propsExpression.properties[styleKeyIndex]; // no dynamic key

        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }

          if (styleProp && !isStaticExp(styleProp.value) && ( // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          hasStyleBinding || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17
          /* JS_ARRAY_EXPRESSION */
          )) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          // dynamic key binding, wrap with `normalizeProps`
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }

        break;

      case 14
      /* JS_CALL_EXPRESSION */
      :
        // mergeProps call, do nothing
        break;

      default:
        // single v-bind
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [propsExpression])]);
        break;
    }
  }

  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag: patchFlag,
    dynamicPropNames: dynamicPropNames,
    shouldUseBlock: shouldUseBlock
  };
} // Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation


function dedupeProperties(properties) {
  var knownProps = new Map();
  var deduped = [];

  for (var i = 0; i < properties.length; i++) {
    var prop = properties[i]; // dynamic keys are always allowed

    if (prop.key.type === 8
    /* COMPOUND_EXPRESSION */
    || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }

    var name = prop.key.content;
    var existing = knownProps.get(name);

    if (existing) {
      if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
        mergeAsArray(existing, prop);
      } // unexpected duplicate, should have emitted error during parse

    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }

  return deduped;
}

function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17
  /* JS_ARRAY_EXPRESSION */
  ) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}

function buildDirectiveArgs(dir, context) {
  var dirArgs = [];
  var runtime = directiveImportMap.get(dir);

  if (runtime) {
    // built-in directive with runtime
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      // inject statement for resolving directive
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, "directive"));
    }
  }

  var loc = dir.loc;
  if (dir.exp) dirArgs.push(dir.exp);

  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push("void 0");
    }

    dirArgs.push(dir.arg);
  }

  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push("void 0");
      }

      dirArgs.push("void 0");
    }

    var trueExpression = createSimpleExpression("true", false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map(function (modifier) {
      return createObjectProperty(modifier, trueExpression);
    }), loc));
  }

  return createArrayExpression(dirArgs, dir.loc);
}

function stringifyDynamicPropNames(props) {
  var propsNamesString = "[";

  for (var i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ', ';
  }

  return propsNamesString + "]";
}

function isComponentTag(tag) {
  return tag === 'component' || tag === 'Component';
}

 true ? Object.freeze({}) : 0;
 true ? Object.freeze([]) : 0;

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

var transformSlotOutlet = function transformSlotOutlet(node, context) {
  if (isSlotOutlet(node)) {
    var children = node.children,
        loc = node.loc;

    var _processSlotOutlet = processSlotOutlet(node, context),
        slotName = _processSlotOutlet.slotName,
        slotProps = _processSlotOutlet.slotProps;

    var slotArgs = [context.prefixIdentifiers ? "_ctx.$slots" : "$slots", slotName, '{}', 'undefined', 'true'];
    var expectedLen = 2;

    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }

    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }

    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }

    slotArgs.splice(expectedLen); // remove unused arguments

    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};

function processSlotOutlet(node, context) {
  var slotName = "\"default\"";
  var slotProps = undefined;
  var nonNameProps = [];

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
      if (p.value) {
        if (p.name === 'name') {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
        if (p.exp) slotName = p.exp;
      } else {
        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }

        nonNameProps.push(p);
      }
    }
  }

  if (nonNameProps.length > 0) {
    var _buildProps = buildProps(node, context, nonNameProps),
        props = _buildProps.props,
        directives = _buildProps.directives;

    slotProps = props;

    if (directives.length) {
      context.onError(createCompilerError(36
      /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
      , directives[0].loc));
    }
  }

  return {
    slotName: slotName,
    slotProps: slotProps
  };
}

var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;

var transformOn = function transformOn(dir, node, context, augmentor) {
  var loc = dir.loc,
      modifiers = dir.modifiers,
      arg = dir.arg;

  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35
    /* X_V_ON_NO_EXPRESSION */
    , loc));
  }

  var eventName;

  if (arg.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
    if (arg.isStatic) {
      var rawName = arg.content; // TODO deprecate @vnodeXXX usage

      if (rawName.startsWith('vue:')) {
        rawName = "vnode-".concat(rawName.slice(4));
      } // for all event listeners, auto convert it to camelCase. See issue #2249


      eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
    } else {
      // #2388
      eventName = createCompoundExpression(["".concat(context.helperString(TO_HANDLER_KEY), "("), arg, ")"]);
    }
  } else {
    // already a compound expression.
    eventName = arg;
    eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY), "("));
    eventName.children.push(")");
  } // handler processing


  var exp = dir.exp;

  if (exp && !exp.content.trim()) {
    exp = undefined;
  }

  var shouldCache = context.cacheHandlers && !exp && !context.inVOnce;

  if (exp) {
    var isMemberExp = isMemberExpression(exp.content);
    var isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    var hasMultipleStatements = exp.content.includes(";");

    if (true) {
      validateBrowserExpression(exp, context, false, hasMultipleStatements);
    }

    if (isInlineStatement || shouldCache && isMemberExp) {
      // wrap inline statement in a function expression
      exp = createCompoundExpression(["".concat(isInlineStatement ? "$event" : "".concat("", "(...args)"), " => ").concat(hasMultipleStatements ? "{" : "("), exp, hasMultipleStatements ? "}" : ")"]);
    }
  }

  var ret = {
    props: [createObjectProperty(eventName, exp || createSimpleExpression("() => {}", false, loc))]
  }; // apply extended compiler augmentor

  if (augmentor) {
    ret = augmentor(ret);
  }

  if (shouldCache) {
    // cache handlers so that it's always the same handler being passed down.
    // this avoids unnecessary re-renders when users use inline handlers on
    // components.
    ret.props[0].value = context.cache(ret.props[0].value);
  } // mark the key as handler for props normalization check


  ret.props.forEach(function (p) {
    return p.key.isHandlerKey = true;
  });
  return ret;
}; // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.


var transformBind = function transformBind(dir, _node, context) {
  var exp = dir.exp,
      modifiers = dir.modifiers,
      loc = dir.loc;
  var arg = dir.arg;

  if (arg.type !== 4
  /* SIMPLE_EXPRESSION */
  ) {
    arg.children.unshift("(");
    arg.children.push(") || \"\"");
  } else if (!arg.isStatic) {
    arg.content = "".concat(arg.content, " || \"\"");
  } // .sync is replaced by v-model:arg


  if (modifiers.includes('camel')) {
    if (arg.type === 4
    /* SIMPLE_EXPRESSION */
    ) {
      if (arg.isStatic) {
        arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
      } else {
        arg.content = "".concat(context.helperString(CAMELIZE), "(").concat(arg.content, ")");
      }
    } else {
      arg.children.unshift("".concat(context.helperString(CAMELIZE), "("));
      arg.children.push(")");
    }
  }

  if (!context.inSSR) {
    if (modifiers.includes('prop')) {
      injectPrefix(arg, '.');
    }

    if (modifiers.includes('attr')) {
      injectPrefix(arg, '^');
    }
  }

  if (!exp || exp.type === 4
  /* SIMPLE_EXPRESSION */
  && !exp.content.trim()) {
    context.onError(createCompilerError(34
    /* X_V_BIND_NO_EXPRESSION */
    , loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
    };
  }

  return {
    props: [createObjectProperty(arg, exp)]
  };
};

var injectPrefix = function injectPrefix(arg, prefix) {
  if (arg.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = "`".concat(prefix, "${").concat(arg.content, "}`");
    }
  } else {
    arg.children.unshift("'".concat(prefix, "' + ("));
    arg.children.push(")");
  }
}; // Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.


var transformText = function transformText(node, context) {
  if (node.type === 0
  /* ROOT */
  || node.type === 1
  /* ELEMENT */
  || node.type === 11
  /* FOR */
  || node.type === 10
  /* IF_BRANCH */
  ) {
    // perform the transform on node exit so that all expressions have already
    // been processed.
    return function () {
      var children = node.children;
      var currentContainer = undefined;
      var hasText = false;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (isText(child)) {
          hasText = true;

          for (var j = i + 1; j < children.length; j++) {
            var next = children[j];

            if (isText(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = {
                  type: 8
                  /* COMPOUND_EXPRESSION */
                  ,
                  loc: child.loc,
                  children: [child]
                };
              } // merge adjacent text node into current


              currentContainer.children.push(" + ", next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = undefined;
              break;
            }
          }
        }
      }

      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0
      /* ROOT */
      || node.type === 1
      /* ELEMENT */
      && node.tagType === 0
      /* ELEMENT */
      && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(function (p) {
        return p.type === 7
        /* DIRECTIVE */
        && !context.directiveTransforms[p.name];
      }) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === 'template'))) {
        return;
      } // pre-convert text nodes into createTextVNode(text) calls to avoid
      // runtime normalization.


      for (var _i8 = 0; _i8 < children.length; _i8++) {
        var _child = children[_i8];

        if (isText(_child) || _child.type === 8
        /* COMPOUND_EXPRESSION */
        ) {
          var callArgs = []; // createTextVNode defaults to single whitespace, so if it is a
          // single space the code could be an empty call to save bytes.

          if (_child.type !== 2
          /* TEXT */
          || _child.content !== ' ') {
            callArgs.push(_child);
          } // mark dynamic text with flag so it gets patched inside a block


          if (!context.ssr && getConstantType(_child, context) === 0
          /* NOT_CONSTANT */
          ) {
            callArgs.push(1
            /* TEXT */
            + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1], " */") : 0));
          }

          children[_i8] = {
            type: 12
            /* TEXT_CALL */
            ,
            content: _child,
            loc: _child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};

var seen = new WeakSet();

var transformOnce = function transformOnce(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && findDir(node, 'once', true)) {
    if (seen.has(node) || context.inVOnce) {
      return;
    }

    seen.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return function () {
      context.inVOnce = false;
      var cur = context.currentNode;

      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true
        /* isVNode */
        );
      }
    };
  }
};

var transformModel = function transformModel(dir, node, context) {
  var exp = dir.exp,
      arg = dir.arg;

  if (!exp) {
    context.onError(createCompilerError(41
    /* X_V_MODEL_NO_EXPRESSION */
    , dir.loc));
    return createTransformProps();
  }

  var rawExp = exp.loc.source;
  var expString = exp.type === 4
  /* SIMPLE_EXPRESSION */
  ? exp.content : rawExp; // im SFC <script setup> inline mode, the exp may have been transformed into
  // _unref(exp)

  context.bindingMetadata[rawExp];
  var maybeRef = !true
  /* SETUP_CONST */
  ;

  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(42
    /* X_V_MODEL_MALFORMED_EXPRESSION */
    , exp.loc));
    return createTransformProps();
  }

  var propName = arg ? arg : createSimpleExpression('modelValue', true);
  var eventName = arg ? isStaticExp(arg) ? "onUpdate:".concat(arg.content) : createCompoundExpression(['"onUpdate:" + ', arg]) : "onUpdate:modelValue";
  var assignmentExp;
  var eventArg = context.isTS ? "($event: any)" : "$event";
  {
    assignmentExp = createCompoundExpression(["".concat(eventArg, " => (("), exp, ") = $event)"]);
  }
  var props = [// modelValue: foo
  createObjectProperty(propName, dir.exp), // "onUpdate:modelValue": $event => (foo = $event)
  createObjectProperty(eventName, assignmentExp)]; // modelModifiers: { foo: true, "bar-baz": true }

  if (dir.modifiers.length && node.tagType === 1
  /* COMPONENT */
  ) {
    var modifiers = dir.modifiers.map(function (m) {
      return (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + ": true";
    }).join(", ");
    var modifiersKey = arg ? isStaticExp(arg) ? "".concat(arg.content, "Modifiers") : createCompoundExpression([arg, ' + "Modifiers"']) : "modelModifiers";
    props.push(createObjectProperty(modifiersKey, createSimpleExpression("{ ".concat(modifiers, " }"), false, dir.loc, 2
    /* CAN_HOIST */
    )));
  }

  return createTransformProps(props);
};

function createTransformProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    props: props
  };
}

var validDivisionCharRE = /[\w).+\-_$\]]/;

var transformFilter = function transformFilter(node, context) {
  if (!isCompatEnabled("COMPILER_FILTER"
  /* COMPILER_FILTERS */
  , context)) {
    return;
  }

  if (node.type === 5
  /* INTERPOLATION */
  ) {
    // filter rewrite is applied before expression transform so only
    // simple expressions are possible at this stage
    rewriteFilter(node.content, context);
  }

  if (node.type === 1
  /* ELEMENT */
  ) {
    node.props.forEach(function (prop) {
      if (prop.type === 7
      /* DIRECTIVE */
      && prop.name !== 'for' && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};

function rewriteFilter(node, context) {
  if (node.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
    parseFilter(node, context);
  } else {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (_typeof(child) !== 'object') continue;

      if (child.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
        parseFilter(child, context);
      } else if (child.type === 8
      /* COMPOUND_EXPRESSION */
      ) {
        rewriteFilter(node, context);
      } else if (child.type === 5
      /* INTERPOLATION */
      ) {
        rewriteFilter(child.content, context);
      }
    }
  }
}

function parseFilter(node, context) {
  var exp = node.content;
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c,
      prev,
      i,
      expression,
      filters = [];

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5c) inSingle = false;
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5c) inDouble = false;
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5c) inTemplateString = false;
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5c) inRegex = false;
    } else if (c === 0x7c && // pipe
    exp.charCodeAt(i + 1) !== 0x7c && exp.charCodeAt(i - 1) !== 0x7c && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5b:
          square++;
          break;
        // [

        case 0x5d:
          square--;
          break;
        // ]

        case 0x7b:
          curly++;
          break;
        // {

        case 0x7d:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') break;
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters.length) {
     true && warnDeprecation("COMPILER_FILTER"
    /* COMPILER_FILTERS */
    , context, node.loc);

    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }

    node.content = expression;
  }
}

function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  var i = filter.indexOf('(');

  if (i < 0) {
    context.filters.add(filter);
    return "".concat(toValidAssetId(filter, 'filter'), "(").concat(exp, ")");
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    context.filters.add(name);
    return "".concat(toValidAssetId(name, 'filter'), "(").concat(exp).concat(args !== ')' ? ',' + args : args);
  }
}

var seen$1 = new WeakSet();

var transformMemo = function transformMemo(node, context) {
  if (node.type === 1
  /* ELEMENT */
  ) {
    var dir = findDir(node, 'memo');

    if (!dir || seen$1.has(node)) {
      return;
    }

    seen$1.add(node);
    return function () {
      var codegenNode = node.codegenNode || context.currentNode.codegenNode;

      if (codegenNode && codegenNode.type === 13
      /* VNODE_CALL */
      ) {
        // non-component sub tree should be turned into a block
        if (node.tagType !== 1
        /* COMPONENT */
        ) {
          makeBlock(codegenNode, context);
        }

        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [dir.exp, createFunctionExpression(undefined, codegenNode), "_cache", String(context.cached++)]);
      }
    };
  }
};

function getBaseTransformPreset(prefixIdentifiers) {
  return [[transformOnce, transformIf, transformMemo, transformFor].concat([transformFilter], _toConsumableArray( true ? [transformExpression] : 0), [transformSlotOutlet, transformElement, trackSlotScopes, transformText]), {
    on: transformOn,
    bind: transformBind,
    model: transformModel
  }];
} // we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.


function baseCompile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var onError = options.onError || defaultOnError;
  var isModuleMode = options.mode === 'module';
  /* istanbul ignore if */

  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(46
      /* X_PREFIX_ID_NOT_SUPPORTED */
      ));
    } else if (isModuleMode) {
      onError(createCompilerError(47
      /* X_MODULE_MODE_NOT_SUPPORTED */
      ));
    }
  }
  var prefixIdentifiers = !true;

  if (options.cacheHandlers) {
    onError(createCompilerError(48
    /* X_CACHE_HANDLER_NOT_SUPPORTED */
    ));
  }

  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(49
    /* X_SCOPE_ID_NOT_SUPPORTED */
    ));
  }

  var ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;

  var _getBaseTransformPres = getBaseTransformPreset(),
      _getBaseTransformPres2 = _slicedToArray(_getBaseTransformPres, 2),
      nodeTransforms = _getBaseTransformPres2[0],
      directiveTransforms = _getBaseTransformPres2[1];

  transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers,
    nodeTransforms: [].concat(_toConsumableArray(nodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
    )
  }));
  return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers
  }));
}

var noopDirectiveTransform = function noopDirectiveTransform() {
  return {
    props: []
  };
};



/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "makeBlock": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _registerRuntimeHelpe, _DOMErrorMessages;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var V_MODEL_RADIO = Symbol( true ? "vModelRadio" : 0);
var V_MODEL_CHECKBOX = Symbol( true ? "vModelCheckbox" : 0);
var V_MODEL_TEXT = Symbol( true ? "vModelText" : 0);
var V_MODEL_SELECT = Symbol( true ? "vModelSelect" : 0);
var V_MODEL_DYNAMIC = Symbol( true ? "vModelDynamic" : 0);
var V_ON_WITH_MODIFIERS = Symbol( true ? "vOnModifiersGuard" : 0);
var V_ON_WITH_KEYS = Symbol( true ? "vOnKeysGuard" : 0);
var V_SHOW = Symbol( true ? "vShow" : 0);
var TRANSITION = Symbol( true ? "Transition" : 0);
var TRANSITION_GROUP = Symbol( true ? "TransitionGroup" : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)((_registerRuntimeHelpe = {}, _defineProperty(_registerRuntimeHelpe, V_MODEL_RADIO, "vModelRadio"), _defineProperty(_registerRuntimeHelpe, V_MODEL_CHECKBOX, "vModelCheckbox"), _defineProperty(_registerRuntimeHelpe, V_MODEL_TEXT, "vModelText"), _defineProperty(_registerRuntimeHelpe, V_MODEL_SELECT, "vModelSelect"), _defineProperty(_registerRuntimeHelpe, V_MODEL_DYNAMIC, "vModelDynamic"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_MODIFIERS, "withModifiers"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_KEYS, "withKeys"), _defineProperty(_registerRuntimeHelpe, V_SHOW, "vShow"), _defineProperty(_registerRuntimeHelpe, TRANSITION, "Transition"), _defineProperty(_registerRuntimeHelpe, TRANSITION_GROUP, "TransitionGroup"), _registerRuntimeHelpe));
/* eslint-disable no-restricted-globals */

var decoder;

function decodeHtmlBrowser(raw) {
  var asAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!decoder) {
    decoder = document.createElement('div');
  }

  if (asAttr) {
    decoder.innerHTML = "<div foo=\"".concat(raw.replace(/"/g, '&quot;'), "\">");
    return decoder.children[0].getAttribute('foo');
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

var isRawTextContainer = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
var parserOptions = {
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
  isNativeTag: function isNativeTag(tag) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
  },
  isPreTag: function isPreTag(tag) {
    return tag === 'pre';
  },
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: function isBuiltInComponent(tag) {
    if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "Transition")) {
      return TRANSITION;
    } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "TransitionGroup")) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace: function getNamespace(tag, parent) {
    var ns = parent ? parent.ns : 0
    /* HTML */
    ;

    if (parent && ns === 2
    /* MATH_ML */
    ) {
      if (parent.tag === 'annotation-xml') {
        if (tag === 'svg') {
          return 1
          /* SVG */
          ;
        }

        if (parent.props.some(function (a) {
          return a.type === 6
          /* ATTRIBUTE */
          && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml');
        })) {
          ns = 0
          /* HTML */
          ;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {
        ns = 0
        /* HTML */
        ;
      }
    } else if (parent && ns === 1
    /* SVG */
    ) {
      if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {
        ns = 0
        /* HTML */
        ;
      }
    }

    if (ns === 0
    /* HTML */
    ) {
      if (tag === 'svg') {
        return 1
        /* SVG */
        ;
      }

      if (tag === 'math') {
        return 2
        /* MATH_ML */
        ;
      }
    }

    return ns;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode: function getTextMode(_ref) {
    var tag = _ref.tag,
        ns = _ref.ns;

    if (ns === 0
    /* HTML */
    ) {
      if (tag === 'textarea' || tag === 'title') {
        return 1
        /* RCDATA */
        ;
      }

      if (isRawTextContainer(tag)) {
        return 2
        /* RAWTEXT */
        ;
      }
    }

    return 0
    /* DATA */
    ;
  }
}; // Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.

var transformStyle = function transformStyle(node) {
  if (node.type === 1
  /* ELEMENT */
  ) {
    node.props.forEach(function (p, i) {
      if (p.type === 6
      /* ATTRIBUTE */
      && p.name === 'style' && p.value) {
        // replace p with an expression node
        node.props[i] = {
          type: 7
          /* DIRECTIVE */
          ,
          name: "bind",
          arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("style", true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};

var parseInlineCSS = function parseInlineCSS(cssText, loc) {
  var normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3
  /* CAN_STRINGIFY */
  );
};

function createDOMCompilerError(code, loc) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}

var DOMErrorMessages = (_DOMErrorMessages = {}, _defineProperty(_DOMErrorMessages, 50
/* X_V_HTML_NO_EXPRESSION */
, "v-html is missing expression."), _defineProperty(_DOMErrorMessages, 51
/* X_V_HTML_WITH_CHILDREN */
, "v-html will override element children."), _defineProperty(_DOMErrorMessages, 52
/* X_V_TEXT_NO_EXPRESSION */
, "v-text is missing expression."), _defineProperty(_DOMErrorMessages, 53
/* X_V_TEXT_WITH_CHILDREN */
, "v-text will override element children."), _defineProperty(_DOMErrorMessages, 54
/* X_V_MODEL_ON_INVALID_ELEMENT */
, "v-model can only be used on <input>, <textarea> and <select> elements."), _defineProperty(_DOMErrorMessages, 55
/* X_V_MODEL_ARG_ON_ELEMENT */
, "v-model argument is not supported on plain elements."), _defineProperty(_DOMErrorMessages, 56
/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
, "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead."), _defineProperty(_DOMErrorMessages, 57
/* X_V_MODEL_UNNECESSARY_VALUE */
, "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior."), _defineProperty(_DOMErrorMessages, 58
/* X_V_SHOW_NO_EXPRESSION */
, "v-show is missing expression."), _defineProperty(_DOMErrorMessages, 59
/* X_TRANSITION_INVALID_CHILDREN */
, "<Transition> expects exactly one child element or component."), _defineProperty(_DOMErrorMessages, 60
/* X_IGNORED_SIDE_EFFECT_TAG */
, "Tags with side effect (<script> and <style>) are ignored in client component templates."), _DOMErrorMessages);

var transformVHtml = function transformVHtml(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(50
    /* X_V_HTML_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(51
    /* X_V_HTML_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("innerHTML", true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformVText = function transformVText(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(52
    /* X_V_TEXT_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(53
    /* X_V_TEXT_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("textContent", true), exp ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformModel = function transformModel(dir, node, context) {
  var baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context); // base transform has errors OR component v-model (only need props)

  if (!baseResult.props.length || node.tagType === 1
  /* COMPONENT */
  ) {
    return baseResult;
  }

  if (dir.arg) {
    context.onError(createDOMCompilerError(55
    /* X_V_MODEL_ARG_ON_ELEMENT */
    , dir.arg.loc));
  }

  function checkDuplicatedValue() {
    var value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');

    if (value) {
      context.onError(createDOMCompilerError(57
      /* X_V_MODEL_UNNECESSARY_VALUE */
      , value.loc));
    }
  }

  var tag = node.tag;
  var isCustomElement = context.isCustomElement(tag);

  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {
    var directiveToUse = V_MODEL_TEXT;
    var isInvalidType = false;

    if (tag === 'input' || isCustomElement) {
      var type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, "type");

      if (type) {
        if (type.type === 7
        /* DIRECTIVE */
        ) {
          // :type="foo"
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO;
              break;

            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX;
              break;

            case 'file':
              isInvalidType = true;
              context.onError(createDOMCompilerError(56
              /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
              , dir.loc));
              break;

            default:
              // text type
               true && checkDuplicatedValue();
              break;
          }
        }
      } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        // text type
         true && checkDuplicatedValue();
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT;
    } else {
      // textarea
       true && checkDuplicatedValue();
    } // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.


    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(54
    /* X_V_MODEL_ON_INVALID_ELEMENT */
    , dir.loc));
  } // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.


  baseResult.props = baseResult.props.filter(function (p) {
    return !(p.key.type === 4
    /* SIMPLE_EXPRESSION */
    && p.key.content === 'modelValue');
  });
  return baseResult;
};

var isEventOptionModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("passive,once,capture");
var isNonKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)( // event propagation management
"stop,prevent,self," + // system modifiers + exact
"ctrl,shift,alt,meta,exact," + // mouse
"middle"); // left & right could be mouse or key modifiers based on event type

var maybeKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
var isKeyboardEvent = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("onkeyup,onkeydown,onkeypress", true);

var resolveModifiers = function resolveModifiers(key, modifiers, context, loc) {
  var keyModifiers = [];
  var nonKeyModifiers = [];
  var eventOptionModifiers = [];

  for (var i = 0; i < modifiers.length; i++) {
    var modifier = modifiers[i];

    if (modifier === 'native' && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE"
    /* COMPILER_V_ON_NATIVE */
    , context, loc)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier);
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }

  return {
    keyModifiers: keyModifiers,
    nonKeyModifiers: nonKeyModifiers,
    eventOptionModifiers: eventOptionModifiers
  };
};

var transformClick = function transformClick(key, event) {
  var isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
  return isStaticClick ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true) : key.type !== 4
  /* SIMPLE_EXPRESSION */
  ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") === \"onClick\" ? \"".concat(event, "\" : ("), key, ")"]) : key;
};

var transformOn = function transformOn(dir, node, context) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, function (baseResult) {
    var modifiers = dir.modifiers;
    if (!modifiers.length) return baseResult;
    var _baseResult$props$ = baseResult.props[0],
        key = _baseResult$props$.key,
        handlerExp = _baseResult$props$.value;

    var _resolveModifiers = resolveModifiers(key, modifiers, context, dir.loc),
        keyModifiers = _resolveModifiers.keyModifiers,
        nonKeyModifiers = _resolveModifiers.nonKeyModifiers,
        eventOptionModifiers = _resolveModifiers.eventOptionModifiers; // normalize click.right and click.middle since they don't actually fire


    if (nonKeyModifiers.includes('right')) {
      key = transformClick(key, "onContextmenu");
    }

    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, "onMouseup");
    }

    if (nonKeyModifiers.length) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);
    }

    if (keyModifiers.length && ( // if event name is dynamic, always wrap with keys guard
    !(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);
    }

    if (eventOptionModifiers.length) {
      var modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
      key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("".concat(key.content).concat(modifierPostfix), true) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") + \"".concat(modifierPostfix, "\"")]);
    }

    return {
      props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
    };
  });
};

var transformShow = function transformShow(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(58
    /* X_V_SHOW_NO_EXPRESSION */
    , loc));
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

var warnTransitionChildren = function warnTransitionChildren(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 1
  /* COMPONENT */
  ) {
    var component = context.isBuiltInComponent(node.tag);

    if (component === TRANSITION) {
      return function () {
        if (node.children.length && hasMultipleChildren(node)) {
          context.onError(createDOMCompilerError(59
          /* X_TRANSITION_INVALID_CHILDREN */
          , {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ''
          }));
        }
      };
    }
  }
};

function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  var children = node.children = node.children.filter(function (c) {
    return c.type !== 3
    /* COMMENT */
    && !(c.type === 2
    /* TEXT */
    && !c.content.trim());
  });
  var child = children[0];
  return children.length !== 1 || child.type === 11
  /* FOR */
  || child.type === 9
  /* IF */
  && child.branches.some(hasMultipleChildren);
}

var ignoreSideEffectTags = function ignoreSideEffectTags(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 0
  /* ELEMENT */
  && (node.tag === 'script' || node.tag === 'style')) {
    context.onError(createDOMCompilerError(60
    /* X_IGNORED_SIDE_EFFECT_TAG */
    , node.loc));
    context.removeNode();
  }
};

var DOMNodeTransforms = [transformStyle].concat(_toConsumableArray( true ? [warnTransitionChildren] : 0));
var DOMDirectiveTransforms = {
  cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};

function compile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
    nodeTransforms: [// ignore <script> and <tag>
    // this is not put inside DOMNodeTransforms because that list is used
    // by compiler-ssr to generate vnode fallback branches
    ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}

function parse(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}



/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "deferredComputed": () => (/* binding */ deferredComputed),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



function warn(msg) {
  var _console;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  (_console = console).warn.apply(_console, ["[Vue warn] ".concat(msg)].concat(args));
}

var activeEffectScope;

var EffectScope = /*#__PURE__*/function () {
  function EffectScope() {
    var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, EffectScope);

    this.active = true;
    this.effects = [];
    this.cleanups = [];

    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }

  _createClass(EffectScope, [{
    key: "run",
    value: function run(fn) {
      if (this.active) {
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = this.parent;
        }
      } else if (true) {
        warn("cannot run an inactive effect scope.");
      }
    }
  }, {
    key: "on",
    value: function on() {
      activeEffectScope = this;
    }
  }, {
    key: "off",
    value: function off() {
      activeEffectScope = this.parent;
    }
  }, {
    key: "stop",
    value: function stop(fromParent) {
      if (this.active) {
        var i, l;

        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }

        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }

        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        } // nested scope, dereference from parent to avoid memory leaks


        if (this.parent && !fromParent) {
          // optimized O(1) removal
          var last = this.parent.scopes.pop();

          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }

        this.active = false;
      }
    }
  }]);

  return EffectScope;
}();

function effectScope(detached) {
  return new EffectScope(detached);
}

function recordEffectScope(effect) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeEffectScope;

  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}

function getCurrentScope() {
  return activeEffectScope;
}

function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (true) {
    warn("onScopeDispose() is called when there is no active effect scope" + " to be associated with.");
  }
}

var createDep = function createDep(effects) {
  var dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};

var wasTracked = function wasTracked(dep) {
  return (dep.w & trackOpBit) > 0;
};

var newTracked = function newTracked(dep) {
  return (dep.n & trackOpBit) > 0;
};

var initDepMarkers = function initDepMarkers(_ref) {
  var deps = _ref.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit; // set was tracked
    }
  }
};

var finalizeDepMarkers = function finalizeDepMarkers(effect) {
  var deps = effect.deps;

  if (deps.length) {
    var ptr = 0;

    for (var i = 0; i < deps.length; i++) {
      var dep = deps[i];

      if (wasTracked(dep) && !newTracked(dep)) {
        dep["delete"](effect);
      } else {
        deps[ptr++] = dep;
      } // clear bits


      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }

    deps.length = ptr;
  }
};

var targetMap = new WeakMap(); // The number of effects currently being tracked recursively.

var effectTrackDepth = 0;
var trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */

var maxMarkerBits = 30;
var activeEffect;
var ITERATE_KEY = Symbol( true ? 'iterate' : 0);
var MAP_KEY_ITERATE_KEY = Symbol( true ? 'Map key iterate' : 0);

var ReactiveEffect = /*#__PURE__*/function () {
  function ReactiveEffect(fn) {
    var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var scope = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, ReactiveEffect);

    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = undefined;
    recordEffectScope(this, scope);
  }

  _createClass(ReactiveEffect, [{
    key: "run",
    value: function run() {
      if (!this.active) {
        return this.fn();
      }

      var parent = activeEffect;
      var lastShouldTrack = shouldTrack;

      while (parent) {
        if (parent === this) {
          return;
        }

        parent = parent.parent;
      }

      try {
        this.parent = activeEffect;
        activeEffect = this;
        shouldTrack = true;
        trackOpBit = 1 << ++effectTrackDepth;

        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }

        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }

        trackOpBit = 1 << --effectTrackDepth;
        activeEffect = this.parent;
        shouldTrack = lastShouldTrack;
        this.parent = undefined;
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.active) {
        cleanupEffect(this);

        if (this.onStop) {
          this.onStop();
        }

        this.active = false;
      }
    }
  }]);

  return ReactiveEffect;
}();

function cleanupEffect(effect) {
  var deps = effect.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i]["delete"](effect);
    }

    deps.length = 0;
  }
}

function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }

  var _effect = new ReactiveEffect(fn);

  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }

  if (!options || !options.lazy) {
    _effect.run();
  }

  var runner = _effect.run.bind(_effect);

  runner.effect = _effect;
  return runner;
}

function stop(runner) {
  runner.effect.stop();
}

var shouldTrack = true;
var trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  var last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    var depsMap = targetMap.get(target);

    if (!depsMap) {
      targetMap.set(target, depsMap = new Map());
    }

    var dep = depsMap.get(key);

    if (!dep) {
      depsMap.set(key, dep = createDep());
    }

    var eventInfo =  true ? {
      effect: activeEffect,
      target: target,
      type: type,
      key: key
    } : 0;
    trackEffects(dep, eventInfo);
  }
}

function trackEffects(dep, debuggerEventExtraInfo) {
  var shouldTrack = false;

  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit; // set newly tracked

      shouldTrack = !wasTracked(dep);
    }
  } else {
    // Full cleanup mode.
    shouldTrack = !dep.has(activeEffect);
  }

  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);

    if ( true && activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({
        effect: activeEffect
      }, debuggerEventExtraInfo));
    }
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  var depsMap = targetMap.get(target);

  if (!depsMap) {
    // never been tracked
    return;
  }

  var deps = [];

  if (type === "clear"
  /* CLEAR */
  ) {
    // collection being cleared
    // trigger all effects for target
    deps = _toConsumableArray(depsMap.values());
  } else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    depsMap.forEach(function (dep, key) {
      if (key === 'length' || key >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    } // also run for iteration key on ADD | DELETE | Map.SET


    switch (type) {
      case "add"
      /* ADD */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
          // new index added to array -> length changes
          deps.push(depsMap.get('length'));
        }

        break;

      case "delete"
      /* DELETE */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }

        break;

      case "set"
      /* SET */
      :
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }

        break;
    }
  }

  var eventInfo =  true ? {
    target: target,
    type: type,
    key: key,
    newValue: newValue,
    oldValue: oldValue,
    oldTarget: oldTarget
  } : 0;

  if (deps.length === 1) {
    if (deps[0]) {
      if (true) {
        triggerEffects(deps[0], eventInfo);
      } else {}
    }
  } else {
    var effects = [];

    var _iterator = _createForOfIteratorHelper(deps),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var dep = _step.value;

        if (dep) {
          effects.push.apply(effects, _toConsumableArray(dep));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (true) {
      triggerEffects(createDep(effects), eventInfo);
    } else {}
  }
}

function triggerEffects(dep, debuggerEventExtraInfo) {
  // spread into array for stabilization
  var _iterator2 = _createForOfIteratorHelper((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : _toConsumableArray(dep)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _effect2 = _step2.value;

      if (_effect2 !== activeEffect || _effect2.allowRecurse) {
        if ( true && _effect2.onTrigger) {
          _effect2.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({
            effect: _effect2
          }, debuggerEventExtraInfo));
        }

        if (_effect2.scheduler) {
          _effect2.scheduler();
        } else {
          _effect2.run();
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}

var isNonTrackableKeys = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("__proto__,__v_isRef,__isVue");
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) {
  return Symbol[key];
}).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
var get = /*#__PURE__*/createGetter();
var shallowGet = /*#__PURE__*/createGetter(false, true);
var readonlyGet = /*#__PURE__*/createGetter(true);
var shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);
var arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();

function createArrayInstrumentations() {
  var instrumentations = {};
  ['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {
    instrumentations[key] = function () {
      var arr = toRaw(this);

      for (var i = 0, l = this.length; i < l; i++) {
        track(arr, "get"
        /* GET */
        , i + '');
      } // we run the method using the original args first (which may be reactive)


      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var res = arr[key].apply(arr, args);

      if (res === -1 || res === false) {
        // if that didn't work, run it again using raw values.
        return arr[key].apply(arr, _toConsumableArray(args.map(toRaw)));
      } else {
        return res;
      }
    };
  });
  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {
    instrumentations[key] = function () {
      pauseTracking();

      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}

function createGetter() {
  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function get(target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
      return !isReadonly;
    } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
      return isReadonly;
    } else if (key === "__v_isShallow"
    /* IS_SHALLOW */
    ) {
      return shallow;
    } else if (key === "__v_raw"
    /* RAW */
    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }

    var targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);

    if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }

    var res = Reflect.get(target, key, receiver);

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, "get"
      /* GET */
      , key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      var shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
      return shouldUnwrap ? res.value : res;
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

var set = /*#__PURE__*/createSetter();
var shallowSet = /*#__PURE__*/createSetter(true);

function createSetter() {
  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }

    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }

    var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    var result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add"
        /* ADD */
        , key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set"
        /* SET */
        , key, value, oldValue);
      }
    }

    return result;
  };
}

function deleteProperty(target, key) {
  var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
  var oldValue = target[key];
  var result = Reflect.deleteProperty(target, key);

  if (result && hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function has(target, key) {
  var result = Reflect.has(target, key);

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
    track(target, "has"
    /* HAS */
    , key);
  }

  return result;
}

function ownKeys(target) {
  track(target, "iterate"
  /* ITERATE */
  , (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

var mutableHandlers = {
  get: get,
  set: set,
  deleteProperty: deleteProperty,
  has: has,
  ownKeys: ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set: function set(target, key) {
    if (true) {
      console.warn("Set operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  },
  deleteProperty: function deleteProperty(target, key) {
    if (true) {
      console.warn("Delete operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  }
};
var shallowReactiveHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
}); // Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.

var shallowReadonlyHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
  get: shallowReadonlyGet
});

var toShallow = function toShallow(value) {
  return value;
};

var getProto = function getProto(v) {
  return Reflect.getPrototypeOf(v);
};

function get$1(target, key) {
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = target["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get"
    /* GET */
    , key);
  }

  !isReadonly && track(rawTarget, "get"
  /* GET */
  , rawKey);

  var _getProto = getProto(rawTarget),
      has = _getProto.has;

  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;

  if (has.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
  }
}

function has$1(key) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var target = this["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has"
    /* HAS */
    , key);
  }

  !isReadonly && track(rawTarget, "has"
  /* HAS */
  , rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  target = target["__v_raw"
  /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate"
  /* ITERATE */
  , ITERATE_KEY);
  return Reflect.get(target, 'size', target);
}

function add(value) {
  value = toRaw(value);
  var target = toRaw(this);
  var proto = getProto(target);
  var hadKey = proto.has.call(target, value);

  if (!hadKey) {
    target.add(value);
    trigger(target, "add"
    /* ADD */
    , value, value);
  }

  return this;
}

function set$1(key, value) {
  value = toRaw(value);
  var target = toRaw(this);

  var _getProto2 = getProto(target),
      has = _getProto2.has,
      get = _getProto2.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get.call(target, key);
  target.set(key, value);

  if (!hadKey) {
    trigger(target, "add"
    /* ADD */
    , key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
    trigger(target, "set"
    /* SET */
    , key, value, oldValue);
  }

  return this;
}

function deleteEntry(key) {
  var target = toRaw(this);

  var _getProto3 = getProto(target),
      has = _getProto3.has,
      get = _getProto3.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions

  var result = target["delete"](key);

  if (hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function clear() {
  var target = toRaw(this);
  var hadItems = target.size !== 0;
  var oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0; // forward the operation before queueing reactions

  var result = target.clear();

  if (hadItems) {
    trigger(target, "clear"
    /* CLEAR */
    , undefined, undefined, oldTarget);
  }

  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    var observed = this;
    var target = observed["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , ITERATE_KEY);
    return target.forEach(function (value, key) {
      // important: make sure the callback is
      // 1. invoked with the reactive map as `this` and 3rd arg
      // 2. the value received should be a corresponding reactive/readonly.
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function () {
    var target = this["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
    var isKeyOnly = method === 'keys' && targetIsMap;
    var innerIterator = target[method].apply(target, arguments);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator

    return _defineProperty({
      // iterator protocol
      next: function next() {
        var _innerIterator$next = innerIterator.next(),
            value = _innerIterator$next.value,
            done = _innerIterator$next.done;

        return done ? {
          value: value,
          done: done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done
        };
      }
    }, Symbol.iterator, function () {
      return this;
    });
  };
}

function createReadonlyMethod(type) {
  return function () {
    if (true) {
      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? "on key \"".concat(arguments.length <= 0 ? undefined : arguments[0], "\" ") : "";
      console.warn("".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type), " operation ").concat(key, "failed: target is readonly."), toRaw(this));
    }

    return type === "delete"
    /* DELETE */
    ? false : this;
  };
}

function createInstrumentations() {
  var mutableInstrumentations = {
    get: function get(key) {
      return get$1(this, key);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add: add,
    set: set$1,
    "delete": deleteEntry,
    clear: clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get: function get(key) {
      return get$1(this, key, false, true);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add: add,
    set: set$1,
    "delete": deleteEntry,
    clear: clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get: function get(key) {
      return get$1(this, key, true);
    },

    get size() {
      return size(this, true);
    },

    has: function has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    "delete": createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get: function get(key) {
      return get$1(this, key, true, true);
    },

    get size() {
      return size(this, true);
    },

    has: function has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    "delete": createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
  iteratorMethods.forEach(function (method) {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];
}

var _createInstrumentatio = /* #__PURE__*/createInstrumentations(),
    _createInstrumentatio2 = _slicedToArray(_createInstrumentatio, 4),
    mutableInstrumentations = _createInstrumentatio2[0],
    readonlyInstrumentations = _createInstrumentatio2[1],
    shallowInstrumentations = _createInstrumentatio2[2],
    shallowReadonlyInstrumentations = _createInstrumentatio2[3];

function createInstrumentationGetter(isReadonly, shallow) {
  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return function (target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
      return !isReadonly;
    } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
      return isReadonly;
    } else if (key === "__v_raw"
    /* RAW */
    ) {
      return target;
    }

    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}

var mutableCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, true)
};

function checkIdentityKeys(target, has, key) {
  var rawKey = toRaw(key);

  if (rawKey !== key && has.call(target, rawKey)) {
    var type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    console.warn("Reactive ".concat(type, " contains both the raw and reactive ") + "versions of the same object".concat(type === "Map" ? " as keys" : "", ", ") + "which can lead to inconsistencies. " + "Avoid differentiating between the raw and reactive versions " + "of an object and only use the reactive version if possible.");
  }
}

var reactiveMap = new WeakMap();
var shallowReactiveMap = new WeakMap();
var readonlyMap = new WeakMap();
var shallowReadonlyMap = new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return 1
      /* COMMON */
      ;

    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
      /* COLLECTION */
      ;

    default:
      return 0
      /* INVALID */
      ;
  }
}

function getTargetType(value) {
  return value["__v_skip"
  /* SKIP */
  ] || !Object.isExtensible(value) ? 0
  /* INVALID */
  : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}

function reactive(target) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (isReadonly(target)) {
    return target;
  }

  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */


function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */


function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */


function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      console.warn("value cannot be made reactive: ".concat(String(target)));
    }

    return target;
  } // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object


  if (target["__v_raw"
  /* RAW */
  ] && !(isReadonly && target["__v_isReactive"
  /* IS_REACTIVE */
  ])) {
    return target;
  } // target already has corresponding Proxy


  var existingProxy = proxyMap.get(target);

  if (existingProxy) {
    return existingProxy;
  } // only a whitelist of value types can be observed.


  var targetType = getTargetType(target);

  if (targetType === 0
  /* INVALID */
  ) {
    return target;
  }

  var proxy = new Proxy(target, targetType === 2
  /* COLLECTION */
  ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"
    /* RAW */
    ]);
  }

  return !!(value && value["__v_isReactive"
  /* IS_REACTIVE */
  ]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"
  /* IS_READONLY */
  ]);
}

function isShallow(value) {
  return !!(value && value["__v_isShallow"
  /* IS_SHALLOW */
  ]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  var raw = observed && observed["__v_raw"
  /* RAW */
  ];
  return raw ? toRaw(raw) : observed;
}

function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip"
  /* SKIP */
  , true);
  return value;
}

var toReactive = function toReactive(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
};

var toReadonly = function toReadonly(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
};

function trackRefValue(ref) {
  if (shouldTrack && activeEffect) {
    ref = toRaw(ref);

    if (true) {
      trackEffects(ref.dep || (ref.dep = createDep()), {
        target: ref,
        type: "get"
        /* GET */
        ,
        key: 'value'
      });
    } else {}
  }
}

function triggerRefValue(ref, newVal) {
  ref = toRaw(ref);

  if (ref.dep) {
    if (true) {
      triggerEffects(ref.dep, {
        target: ref,
        type: "set"
        /* SET */
        ,
        key: 'value',
        newValue: newVal
      });
    } else {}
  }
}

function isRef(r) {
  return !!(r && r.__v_isRef === true);
}

function ref(value) {
  return createRef(value, false);
}

function shallowRef(value) {
  return createRef(value, true);
}

function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }

  return new RefImpl(rawValue, shallow);
}

var RefImpl = /*#__PURE__*/function () {
  function RefImpl(value, __v_isShallow) {
    _classCallCheck(this, RefImpl);

    this.__v_isShallow = __v_isShallow;
    this.dep = undefined;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }

  _createClass(RefImpl, [{
    key: "value",
    get: function get() {
      trackRefValue(this);
      return this._value;
    },
    set: function set(newVal) {
      newVal = this.__v_isShallow ? newVal : toRaw(newVal);

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = this.__v_isShallow ? newVal : toReactive(newVal);
        triggerRefValue(this, newVal);
      }
    }
  }]);

  return RefImpl;
}();

function triggerRef(ref) {
  triggerRefValue(ref,  true ? ref.value : 0);
}

function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}

var shallowUnwrapHandlers = {
  get: function get(target, key, receiver) {
    return unref(Reflect.get(target, key, receiver));
  },
  set: function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

var CustomRefImpl = /*#__PURE__*/function () {
  function CustomRefImpl(factory) {
    var _this = this;

    _classCallCheck(this, CustomRefImpl);

    this.dep = undefined;
    this.__v_isRef = true;

    var _factory = factory(function () {
      return trackRefValue(_this);
    }, function () {
      return triggerRefValue(_this);
    }),
        get = _factory.get,
        set = _factory.set;

    this._get = get;
    this._set = set;
  }

  _createClass(CustomRefImpl, [{
    key: "value",
    get: function get() {
      return this._get();
    },
    set: function set(newVal) {
      this._set(newVal);
    }
  }]);

  return CustomRefImpl;
}();

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  if ( true && !isProxy(object)) {
    console.warn("toRefs() expects a reactive object but received a plain one.");
  }

  var ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};

  for (var key in object) {
    ret[key] = toRef(object, key);
  }

  return ret;
}

var ObjectRefImpl = /*#__PURE__*/function () {
  function ObjectRefImpl(_object, _key, _defaultValue) {
    _classCallCheck(this, ObjectRefImpl);

    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }

  _createClass(ObjectRefImpl, [{
    key: "value",
    get: function get() {
      var val = this._object[this._key];
      return val === undefined ? this._defaultValue : val;
    },
    set: function set(newVal) {
      this._object[this._key] = newVal;
    }
  }]);

  return ObjectRefImpl;
}();

function toRef(object, key, defaultValue) {
  var val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}

var ComputedRefImpl = /*#__PURE__*/function () {
  function ComputedRefImpl(getter, _setter, isReadonly, isSSR) {
    var _this2 = this;

    _classCallCheck(this, ComputedRefImpl);

    this._setter = _setter;
    this.dep = undefined;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, function () {
      if (!_this2._dirty) {
        _this2._dirty = true;
        triggerRefValue(_this2);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"
    /* IS_READONLY */
    ] = isReadonly;
  }

  _createClass(ComputedRefImpl, [{
    key: "value",
    get: function get() {
      // the computed ref may get wrapped by other proxies e.g. readonly() #3376
      var self = toRaw(this);
      trackRefValue(self);

      if (self._dirty || !self._cacheable) {
        self._dirty = false;
        self._value = self.effect.run();
      }

      return self._value;
    },
    set: function set(newValue) {
      this._setter(newValue);
    }
  }]);

  return ComputedRefImpl;
}();

function computed(getterOrOptions, debugOptions) {
  var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var getter;
  var setter;
  var onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);

  if (onlyGetter) {
    getter = getterOrOptions;
    setter =  true ? function () {
      console.warn('Write operation failed: computed value is readonly');
    } : 0;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  var cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);

  if ( true && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }

  return cRef;
}

var _a;

var tick = Promise.resolve();
var queue = [];
var queued = false;

var scheduler = function scheduler(fn) {
  queue.push(fn);

  if (!queued) {
    queued = true;
    tick.then(flush);
  }
};

var flush = function flush() {
  for (var i = 0; i < queue.length; i++) {
    queue[i]();
  }

  queue.length = 0;
  queued = false;
};

var DeferredComputedRefImpl = /*#__PURE__*/function () {
  function DeferredComputedRefImpl(getter) {
    var _this3 = this;

    _classCallCheck(this, DeferredComputedRefImpl);

    this.dep = undefined;
    this._dirty = true;
    this.__v_isRef = true;
    this[_a] = true;
    var compareTarget;
    var hasCompareTarget = false;
    var scheduled = false;
    this.effect = new ReactiveEffect(getter, function (computedTrigger) {
      if (_this3.dep) {
        if (computedTrigger) {
          compareTarget = _this3._value;
          hasCompareTarget = true;
        } else if (!scheduled) {
          var valueToCompare = hasCompareTarget ? compareTarget : _this3._value;
          scheduled = true;
          hasCompareTarget = false;
          scheduler(function () {
            if (_this3.effect.active && _this3._get() !== valueToCompare) {
              triggerRefValue(_this3);
            }

            scheduled = false;
          });
        } // chained upstream computeds are notified synchronously to ensure
        // value invalidation in case of sync access; normal effects are
        // deferred to be triggered in scheduler.


        var _iterator3 = _createForOfIteratorHelper(_this3.dep),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var e = _step3.value;

            if (e.computed instanceof DeferredComputedRefImpl) {
              e.scheduler(true
              /* computedTrigger */
              );
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      _this3._dirty = true;
    });
    this.effect.computed = this;
  }

  _createClass(DeferredComputedRefImpl, [{
    key: "_get",
    value: function _get() {
      if (this._dirty) {
        this._dirty = false;
        return this._value = this.effect.run();
      }

      return this._value;
    }
  }, {
    key: "value",
    get: function get() {
      trackRefValue(this); // the computed ref may get wrapped by other proxies e.g. readonly() #3376

      return toRaw(this)._get();
    }
  }]);

  return DeferredComputedRefImpl;
}();

_a = "__v_isReadonly"
/* IS_READONLY */
;

function deferredComputed(getter) {
  return new DeferredComputedRefImpl(getter);
}



/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* binding */ createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _ErrorTypeStrings;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





var stack = [];

function pushWarningContext(vnode) {
  stack.push(vnode);
}

function popWarningContext() {
  stack.pop();
}

function warn(msg) {
  // avoid props formatting or warn handler tracking deps that might be mutated
  // during patch, leading to infinite recursion.
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  var instance = stack.length ? stack[stack.length - 1].component : null;
  var appWarnHandler = instance && instance.appContext.config.warnHandler;
  var trace = getComponentTrace();

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11
    /* APP_WARN_HANDLER */
    , [msg + args.join(''), instance && instance.proxy, trace.map(function (_ref) {
      var vnode = _ref.vnode;
      return "at <".concat(formatComponentName(instance, vnode.type), ">");
    }).join('\n'), trace]);
  } else {
    var _console;

    var warnArgs = ["[Vue warn]: ".concat(msg)].concat(args);
    /* istanbul ignore if */

    if (trace.length && // avoid spamming console during tests
    !false) {
      warnArgs.push.apply(warnArgs, ["\n"].concat(_toConsumableArray(formatTrace(trace))));
    }

    (_console = console).warn.apply(_console, _toConsumableArray(warnArgs));
  }

  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}

function getComponentTrace() {
  var currentVNode = stack[stack.length - 1];

  if (!currentVNode) {
    return [];
  } // we can't just use the stack because it will be incomplete during updates
  // that did not start from the root. Re-construct the parent chain using
  // instance parent pointers.


  var normalizedStack = [];

  while (currentVNode) {
    var last = normalizedStack[0];

    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }

    var parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }

  return normalizedStack;
}
/* istanbul ignore next */


function formatTrace(trace) {
  var logs = [];
  trace.forEach(function (entry, i) {
    logs.push.apply(logs, _toConsumableArray(i === 0 ? [] : ["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));
  });
  return logs;
}

function formatTraceEntry(_ref2) {
  var vnode = _ref2.vnode,
      recurseCount = _ref2.recurseCount;
  var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
  var isRoot = vnode.component ? vnode.component.parent == null : false;
  var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
  var close = ">" + postfix;
  return vnode.props ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [close]) : [open + close];
}
/* istanbul ignore next */


function formatProps(props) {
  var res = [];
  var keys = Object.keys(props);
  keys.slice(0, 3).forEach(function (key) {
    res.push.apply(res, _toConsumableArray(formatProp(key, props[key])));
  });

  if (keys.length > 3) {
    res.push(" ...");
  }

  return res;
}
/* istanbul ignore next */


function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : ["".concat(key, "=Ref<"), value, ">"];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return ["".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : ["".concat(key, "="), value];
  }
}

var ErrorTypeStrings = (_ErrorTypeStrings = {}, _defineProperty(_ErrorTypeStrings, "sp"
/* SERVER_PREFETCH */
, 'serverPrefetch hook'), _defineProperty(_ErrorTypeStrings, "bc"
/* BEFORE_CREATE */
, 'beforeCreate hook'), _defineProperty(_ErrorTypeStrings, "c"
/* CREATED */
, 'created hook'), _defineProperty(_ErrorTypeStrings, "bm"
/* BEFORE_MOUNT */
, 'beforeMount hook'), _defineProperty(_ErrorTypeStrings, "m"
/* MOUNTED */
, 'mounted hook'), _defineProperty(_ErrorTypeStrings, "bu"
/* BEFORE_UPDATE */
, 'beforeUpdate hook'), _defineProperty(_ErrorTypeStrings, "u"
/* UPDATED */
, 'updated'), _defineProperty(_ErrorTypeStrings, "bum"
/* BEFORE_UNMOUNT */
, 'beforeUnmount hook'), _defineProperty(_ErrorTypeStrings, "um"
/* UNMOUNTED */
, 'unmounted hook'), _defineProperty(_ErrorTypeStrings, "a"
/* ACTIVATED */
, 'activated hook'), _defineProperty(_ErrorTypeStrings, "da"
/* DEACTIVATED */
, 'deactivated hook'), _defineProperty(_ErrorTypeStrings, "ec"
/* ERROR_CAPTURED */
, 'errorCaptured hook'), _defineProperty(_ErrorTypeStrings, "rtc"
/* RENDER_TRACKED */
, 'renderTracked hook'), _defineProperty(_ErrorTypeStrings, "rtg"
/* RENDER_TRIGGERED */
, 'renderTriggered hook'), _defineProperty(_ErrorTypeStrings, 0
/* SETUP_FUNCTION */
, 'setup function'), _defineProperty(_ErrorTypeStrings, 1
/* RENDER_FUNCTION */
, 'render function'), _defineProperty(_ErrorTypeStrings, 2
/* WATCH_GETTER */
, 'watcher getter'), _defineProperty(_ErrorTypeStrings, 3
/* WATCH_CALLBACK */
, 'watcher callback'), _defineProperty(_ErrorTypeStrings, 4
/* WATCH_CLEANUP */
, 'watcher cleanup function'), _defineProperty(_ErrorTypeStrings, 5
/* NATIVE_EVENT_HANDLER */
, 'native event handler'), _defineProperty(_ErrorTypeStrings, 6
/* COMPONENT_EVENT_HANDLER */
, 'component event handler'), _defineProperty(_ErrorTypeStrings, 7
/* VNODE_HOOK */
, 'vnode hook'), _defineProperty(_ErrorTypeStrings, 8
/* DIRECTIVE_HOOK */
, 'directive hook'), _defineProperty(_ErrorTypeStrings, 9
/* TRANSITION_HOOK */
, 'transition hook'), _defineProperty(_ErrorTypeStrings, 10
/* APP_ERROR_HANDLER */
, 'app errorHandler'), _defineProperty(_ErrorTypeStrings, 11
/* APP_WARN_HANDLER */
, 'app warnHandler'), _defineProperty(_ErrorTypeStrings, 12
/* FUNCTION_REF */
, 'ref function'), _defineProperty(_ErrorTypeStrings, 13
/* ASYNC_COMPONENT_LOADER */
, 'async component loader'), _defineProperty(_ErrorTypeStrings, 14
/* SCHEDULER */
, 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'), _ErrorTypeStrings);

function callWithErrorHandling(fn, instance, type, args) {
  var res;

  try {
    res = args ? fn.apply(void 0, _toConsumableArray(args)) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }

  return res;
}

function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    var res = callWithErrorHandling(fn, instance, type, args);

    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res["catch"](function (err) {
        handleError(err, instance, type);
      });
    }

    return res;
  }

  var values = [];

  for (var i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }

  return values;
}

function handleError(err, instance, type) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var contextVNode = instance ? instance.vnode : null;

  if (instance) {
    var cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x

    var exposedInstance = instance.proxy; // in production the hook receives only the error code

    var errorInfo =  true ? ErrorTypeStrings[type] : 0;

    while (cur) {
      var errorCapturedHooks = cur.ec;

      if (errorCapturedHooks) {
        for (var i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }

      cur = cur.parent;
    } // app-level handling


    var appErrorHandler = instance.appContext.config.errorHandler;

    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10
      /* APP_ERROR_HANDLER */
      , [err, exposedInstance, errorInfo]);
      return;
    }
  }

  logError(err, type, contextVNode, throwInDev);
}

function logError(err, type, contextVNode) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (true) {
    var info = ErrorTypeStrings[type];

    if (contextVNode) {
      pushWarningContext(contextVNode);
    }

    warn("Unhandled error".concat(info ? " during execution of ".concat(info) : ""));

    if (contextVNode) {
      popWarningContext();
    } // crash in dev by default so it's more noticeable


    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}

var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPreFlushCbs = [];
var activePreFlushCbs = null;
var preFlushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = Promise.resolve();
var currentFlushPromise = null;
var currentPreFlushParentJob = null;
var RECURSION_LIMIT = 100;

function nextTick(fn) {
  var p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
} // #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.


function findInsertionIndex(id) {
  // the start index should be `flushIndex + 1`
  var start = flushIndex + 1;
  var end = queue.length;

  while (start < end) {
    var middle = start + end >>> 1;
    var middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }

  return start;
}

function queueJob(job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }

    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

function invalidateJob(job) {
  var i = queue.indexOf(job);

  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}

function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push.apply(pendingQueue, _toConsumableArray(cb));
  }

  queueFlush();
}

function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

function flushPreFlushCbs(seen) {
  var parentJob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = _toConsumableArray(new Set(pendingPreFlushCbs));
    pendingPreFlushCbs.length = 0;

    if (true) {
      seen = seen || new Map();
    }

    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }

      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null; // recursively flush until it drains

    flushPreFlushCbs(seen, parentJob);
  }
}

function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    var deduped = _toConsumableArray(new Set(pendingPostFlushCbs));

    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call

    if (activePostFlushCbs) {
      var _activePostFlushCbs;

      (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _toConsumableArray(deduped));

      return;
    }

    activePostFlushCbs = deduped;

    if (true) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort(function (a, b) {
      return getId(a) - getId(b);
    });

    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }

      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}

var getId = function getId(job) {
  return job.id == null ? Infinity : job.id;
};

function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;

  if (true) {
    seen = seen || new Map();
  }

  flushPreFlushCbs(seen); // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.

  queue.sort(function (a, b) {
    return getId(a) - getId(b);
  }); // conditional usage of checkRecursiveUpdate must be determined out of
  // try ... catch block since Rollup by default de-optimizes treeshaking
  // inside try-catch. This can leave all warning code unshaked. Although
  // they would get eventually shaken by a minifier like terser, some minifiers
  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)

  var check =  true ? function (job) {
    return checkRecursiveUpdates(seen, job);
  } : 0;

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      var job = queue[flushIndex];

      if (job && job.active !== false) {
        if ( true && check(job)) {
          continue;
        } // console.log(`running:`, job.id)


        callWithErrorHandling(job, null, 14
        /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null; // some postFlushCb queued jobs!
    // keep flushing until it drains.

    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}

function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    var count = seen.get(fn);

    if (count > RECURSION_LIMIT) {
      var instance = fn.ownerInstance;
      var componentName = instance && getComponentName(instance.type);
      warn("Maximum recursive updates exceeded".concat(componentName ? " in component <".concat(componentName, ">") : "", ". ") + "This means you have a reactive effect that is mutating its own " + "dependencies and thus recursively triggering itself. Possible sources " + "include component template, render function, updated hook or " + "watcher source function.");
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
/* eslint-disable no-restricted-globals */


var isHmrUpdating = false;
var hmrDirtyComponents = new Set(); // Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.

if (true) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}

var map = new Map();

function registerHMR(instance) {
  var id = instance.type.__hmrId;
  var record = map.get(id);

  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }

  record.instances.add(instance);
}

function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances["delete"](instance);
}

function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }

  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: new Set()
  });
  return true;
}

function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}

function rerender(id, newRender) {
  var record = map.get(id);

  if (!record) {
    return;
  } // update initial record (for not-yet-rendered component)


  record.initialDef.render = newRender;

  _toConsumableArray(record.instances).forEach(function (instance) {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }

    instance.renderCache = []; // this flag forces child components with slot content to update

    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}

function reload(id, newComp) {
  var record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp); // update initial def (for not-yet-rendered components)

  updateComponentDef(record.initialDef, newComp); // create a snapshot which avoids the set being mutated during updates

  var instances = _toConsumableArray(record.instances);

  var _iterator = _createForOfIteratorHelper(instances),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var instance = _step.value;
      var oldComp = normalizeClassComponent(instance.type);

      if (!hmrDirtyComponents.has(oldComp)) {
        // 1. Update existing comp definition to match new one
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        } // 2. mark definition dirty. This forces the renderer to replace the
        // component on patch.


        hmrDirtyComponents.add(oldComp);
      } // 3. invalidate options resolution cache


      instance.appContext.optionsCache["delete"](instance.type); // 4. actually update

      if (instance.ceReload) {
        // custom element
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents["delete"](oldComp);
      } else if (instance.parent) {
        // 4. Force the parent instance to re-render. This will cause all updated
        // components to be unmounted and re-mounted. Queue the update so that we
        // don't end up forcing the same parent to re-render multiple times.
        queueJob(instance.parent.update); // instance is the inner component of an async custom element
        // invoke to reset styles

        if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
          instance.parent.ceReload(newComp.styles);
        }
      } else if (instance.appContext.reload) {
        // root instance mounted via createApp() has a reload method
        instance.appContext.reload();
      } else if (typeof window !== 'undefined') {
        // root instance inside tree created via raw render(). Force reload.
        window.location.reload();
      } else {
        console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
      }
    } // 5. make sure to cleanup dirty hmr components after update

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  queuePostFlushCb(function () {
    var _iterator2 = _createForOfIteratorHelper(instances),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var instance = _step2.value;
        hmrDirtyComponents["delete"](normalizeClassComponent(instance.type));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  });
}

function updateComponentDef(oldComp, newComp) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);

  for (var key in oldComp) {
    if (key !== '__file' && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn("[HMR] Something went wrong during Vue component hot-reload. " + "Full reload required.");
    }
  };
}

var devtools;
var buffer = [];
var devtoolsNotInstalled = false;

function emit(event) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (devtools) {
    var _devtools;

    (_devtools = devtools).emit.apply(_devtools, [event].concat(args));
  } else if (!devtoolsNotInstalled) {
    buffer.push({
      event: event,
      args: args
    });
  }
}

function setDevtoolsHook(hook, target) {
  var _a, _b;

  devtools = hook;

  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(function (_ref3) {
      var _devtools2;

      var event = _ref3.event,
          args = _ref3.args;
      return (_devtools2 = devtools).emit.apply(_devtools2, [event].concat(_toConsumableArray(args)));
    });
    buffer = [];
  } else if ( // handle late devtools injection - only do this if we are in an actual
  // browser environment to avoid the timer handle stalling test runner exit
  // (#4815)
  // eslint-disable-next-line no-restricted-globals
  typeof window !== 'undefined' && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
    var replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push(function (newHook) {
      setDevtoolsHook(newHook, target);
    }); // clear buffer after 3s - the user probably doesn't have devtools installed
    // at all, and keeping the buffer will cause memory leaks (#4738)

    setTimeout(function () {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3000);
  } else {
    // non-browser env, assume not installed
    devtoolsNotInstalled = true;
    buffer = [];
  }
}

function devtoolsInitApp(app, version) {
  emit("app:init"
  /* APP_INIT */
  , app, version, {
    Fragment: Fragment,
    Text: Text,
    Comment: Comment,
    Static: Static
  });
}

function devtoolsUnmountApp(app) {
  emit("app:unmount"
  /* APP_UNMOUNT */
  , app);
}

var devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook("component:added"
/* COMPONENT_ADDED */
);
var devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook("component:updated"
/* COMPONENT_UPDATED */
);
var devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook("component:removed"
/* COMPONENT_REMOVED */
);

function createDevtoolsComponentHook(hook) {
  return function (component) {
    emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
  };
}

var devtoolsPerfStart = /*#__PURE__*/createDevtoolsPerformanceHook("perf:start"
/* PERFORMANCE_START */
);
var devtoolsPerfEnd = /*#__PURE__*/createDevtoolsPerformanceHook("perf:end"
/* PERFORMANCE_END */
);

function createDevtoolsPerformanceHook(hook) {
  return function (component, type, time) {
    emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}

function devtoolsComponentEmit(component, event, params) {
  emit("component:emit"
  /* COMPONENT_EMIT */
  , component.appContext.app, component, event, params);
}

function emit$1(instance, event) {
  var props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  for (var _len3 = arguments.length, rawArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    rawArgs[_key3 - 2] = arguments[_key3];
  }

  if (true) {
    var emitsOptions = instance.emitsOptions,
        _instance$propsOption = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption[0];

    if (emitsOptions) {
      if (!(event in emitsOptions) && !false) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
          warn("Component emitted event \"".concat(event, "\" but it is neither declared in ") + "the emits option nor as an \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event), "\" prop."));
        }
      } else {
        var validator = emitsOptions[event];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          var isValid = validator.apply(void 0, rawArgs);

          if (!isValid) {
            warn("Invalid event arguments: event validation failed for event \"".concat(event, "\"."));
          }
        }
      }
    }
  }

  var args = rawArgs;
  var isModelListener = event.startsWith('update:'); // for v-model update:xxx events, apply modifiers on args

  var modelArg = isModelListener && event.slice(7);

  if (modelArg && modelArg in props) {
    var modifiersKey = "".concat(modelArg === 'modelValue' ? 'model' : modelArg, "Modifiers");

    var _ref4 = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        number = _ref4.number,
        trim = _ref4.trim;

    if (trim) {
      args = rawArgs.map(function (a) {
        return a.trim();
      });
    } else if (number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
    }
  }

  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }

  if (true) {
    var lowerCaseEvent = event.toLowerCase();

    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") + "".concat(formatComponentName(instance, instance.type), " but the handler is registered for \"").concat(event, "\". ") + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), "\" instead of \"").concat(event, "\"."));
    }
  }

  var handlerName;
  var handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))]; // for v-model update:xxx events, also trigger kebab-case equivalent
  // for props passed via kebab-case

  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }

  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }

  var onceHandler = props[handlerName + "Once"];

  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }

    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }
}

function normalizeEmitsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.emitsCache;
  var cached = cache.get(comp);

  if (cached !== undefined) {
    return cached;
  }

  var raw = comp.emits;
  var normalized = {}; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendEmits = function extendEmits(raw) {
      var normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);

      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }

    if (comp["extends"]) {
      extendEmits(comp["extends"]);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach(function (key) {
      return normalized[key] = null;
    });
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }

  cache.set(comp, normalized);
  return normalized;
} // Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.


function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }

  key = key.slice(2).replace(/Once$/, '');
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */


var currentRenderingInstance = null;
var currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */

function setCurrentRenderingInstance(instance) {
  var prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */


function pushScopeId(id) {
  currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */


function popScopeId() {
  currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */


var withScopeId = function withScopeId(_id) {
  return withCtx;
};
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */


function withCtx(fn) {
  var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
  var isNonScopedSlot // false only
  = arguments.length > 2 ? arguments[2] : undefined;
  if (!ctx) return fn; // already normalized

  if (fn._n) {
    return fn;
  }

  var renderFnWithContext = function renderFnWithContext() {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }

    var prevInstance = setCurrentRenderingInstance(ctx);
    var res = fn.apply(void 0, arguments);
    setCurrentRenderingInstance(prevInstance);

    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }

    if (true) {
      devtoolsComponentUpdated(ctx);
    }

    return res;
  }; // mark normalized to avoid duplicated wrapping


  renderFnWithContext._n = true; // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.

  renderFnWithContext._c = true; // disable block tracking by default

  renderFnWithContext._d = true;
  return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */


var accessedAttrs = false;

function markAttrsAccessed() {
  accessedAttrs = true;
}

function renderComponentRoot(instance) {
  var Component = instance.type,
      vnode = instance.vnode,
      proxy = instance.proxy,
      withProxy = instance.withProxy,
      props = instance.props,
      _instance$propsOption2 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption2[0],
      slots = instance.slots,
      attrs = instance.attrs,
      emit = instance.emit,
      render = instance.render,
      renderCache = instance.renderCache,
      data = instance.data,
      setupState = instance.setupState,
      ctx = instance.ctx,
      inheritAttrs = instance.inheritAttrs;

  var result;
  var fallthroughAttrs;
  var prev = setCurrentRenderingInstance(instance);

  if (true) {
    accessedAttrs = false;
  }

  try {
    if (vnode.shapeFlag & 4
    /* STATEFUL_COMPONENT */
    ) {
      // withProxy is a proxy with a different `has` trap only for
      // runtime-compiled render functions using `with` block.
      var proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      // functional
      var _render = Component; // in dev, mark attrs accessed if optional props (attrs === props)

      if ( true && attrs === props) {
        markAttrsAccessed();
      }

      result = normalizeVNode(_render.length > 1 ? _render(props,  true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },

        slots: slots,
        emit: emit
      } : 0) : _render(props, null
      /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1
    /* RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  } // attr merging
  // in dev mode, comments are preserved, and it's possible for a template
  // to have comments along side the root element which makes it a fragment


  var root = result;
  var setRoot = undefined;

  if ( true && result.patchFlag > 0 && result.patchFlag & 2048
  /* DEV_ROOT_FRAGMENT */
  ) {
    var _getChildRoot = getChildRoot(result);

    var _getChildRoot2 = _slicedToArray(_getChildRoot, 2);

    root = _getChildRoot2[0];
    setRoot = _getChildRoot2[1];
  }

  if (fallthroughAttrs && inheritAttrs !== false) {
    var keys = Object.keys(fallthroughAttrs);
    var _root = root,
        shapeFlag = _root.shapeFlag;

    if (keys.length) {
      if (shapeFlag & (1
      /* ELEMENT */
      | 6
      /* COMPONENT */
      )) {
        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
          // If a v-model listener (onUpdate:xxx) has a corresponding declared
          // prop, it indicates this component expects to handle v-model and
          // it should not fallthrough.
          // related: #1543, #1643, #1989
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }

        root = cloneVNode(root, fallthroughAttrs);
      } else if ( true && !accessedAttrs && root.type !== Comment) {
        var allAttrs = Object.keys(attrs);
        var eventAttrs = [];
        var extraAttrs = [];

        for (var i = 0, l = allAttrs.length; i < l; i++) {
          var key = allAttrs[i];

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            // ignore v-model handlers when they fail to fallthrough
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
              // remove `on`, lowercase first letter to reflect event casing
              // accurately
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }

        if (extraAttrs.length) {
          warn("Extraneous non-props attributes (" + "".concat(extraAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes.");
        }

        if (eventAttrs.length) {
          warn("Extraneous non-emits event listeners (" + "".concat(eventAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes. " + "If the listener is intended to be a component custom event listener only, " + "declare it using the \"emits\" option.");
        }
      }
    }
  } // inherit directives


  if (vnode.dirs) {
    if ( true && !isElementRoot(root)) {
      warn("Runtime directive used on component with non-element root node. " + "The directives will not function as intended.");
    }

    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  } // inherit transition data


  if (vnode.transition) {
    if ( true && !isElementRoot(root)) {
      warn("Component inside <Transition> renders non-element root node " + "that cannot be animated.");
    }

    root.transition = vnode.transition;
  }

  if ( true && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }

  setCurrentRenderingInstance(prev);
  return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */


var getChildRoot = function getChildRoot(vnode) {
  var rawChildren = vnode.children;
  var dynamicChildren = vnode.dynamicChildren;
  var childRoot = filterSingleRoot(rawChildren);

  if (!childRoot) {
    return [vnode, undefined];
  }

  var index = rawChildren.indexOf(childRoot);
  var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;

  var setRoot = function setRoot(updatedRoot) {
    rawChildren[index] = updatedRoot;

    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [].concat(_toConsumableArray(dynamicChildren), [updatedRoot]);
      }
    }
  };

  return [normalizeVNode(childRoot), setRoot];
};

function filterSingleRoot(children) {
  var singleRoot;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment || child.children === 'v-if') {
        if (singleRoot) {
          // has more than 1 non-comment child, return now
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }

  return singleRoot;
}

var getFunctionalFallthrough = function getFunctionalFallthrough(attrs) {
  var res;

  for (var key in attrs) {
    if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }

  return res;
};

var filterModelListeners = function filterModelListeners(attrs, props) {
  var res = {};

  for (var key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }

  return res;
};

var isElementRoot = function isElementRoot(vnode) {
  return vnode.shapeFlag & (6
  /* COMPONENT */
  | 1
  /* ELEMENT */
  ) || vnode.type === Comment // potential v-if branch switch
  ;
};

function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  var prevProps = prevVNode.props,
      prevChildren = prevVNode.children,
      component = prevVNode.component;
  var nextProps = nextVNode.props,
      nextChildren = nextVNode.children,
      patchFlag = nextVNode.patchFlag;
  var emits = component.emitsOptions; // Parent component's render function was hot-updated. Since this may have
  // caused the child component's slots content to have changed, we need to
  // force the child to update as well.

  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  } // force child update for runtime directive or transition on component vnode.


  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }

  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024
    /* DYNAMIC_SLOTS */
    ) {
      // slot content that references values that might have changed,
      // e.g. in a v-for
      return true;
    }

    if (patchFlag & 16
    /* FULL_PROPS */
    ) {
      if (!prevProps) {
        return !!nextProps;
      } // presence of this flag indicates props are always non-null


      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8
    /* PROPS */
    ) {
      var dynamicProps = nextVNode.dynamicProps;

      for (var i = 0; i < dynamicProps.length; i++) {
        var key = dynamicProps[i];

        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    // this path is only taken by manually written render functions
    // so presence of any children leads to a forced update
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }

    if (prevProps === nextProps) {
      return false;
    }

    if (!prevProps) {
      return !!nextProps;
    }

    if (!nextProps) {
      return true;
    }

    return hasPropsChanged(prevProps, nextProps, emits);
  }

  return false;
}

function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  var nextKeys = Object.keys(nextProps);

  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }

  for (var i = 0; i < nextKeys.length; i++) {
    var key = nextKeys[i];

    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }

  return false;
}

function updateHOCHostEl(_ref5, el // HostNode
) {
  var vnode = _ref5.vnode,
      parent = _ref5.parent;

  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}

var isSuspense = function isSuspense(type) {
  return type.__isSuspense;
}; // Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.


var SuspenseImpl = {
  name: 'Suspense',
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
  rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}; // Force-casted public typing for h and TSX props inference

var Suspense = SuspenseImpl;

function triggerEvent(vnode, name) {
  var eventListener = vnode.props && vnode.props[name];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
    eventListener();
  }
}

function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  var patch = rendererInternals.p,
      createElement = rendererInternals.o.createElement;
  var hiddenContainer = createElement('div');
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals); // start mounting the content subtree in an off-dom container

  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds); // now check if we have encountered any async deps

  if (suspense.deps > 0) {
    // has async
    // invoke @fallback event
    triggerEvent(vnode, 'onPending');
    triggerEvent(vnode, 'onFallback'); // mount the fallback tree

    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, _ref6) {
  var patch = _ref6.p,
      unmount = _ref6.um,
      createElement = _ref6.o.createElement;
  var suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  var newBranch = n2.ssContent;
  var newFallback = n2.ssFallback;
  var activeBranch = suspense.activeBranch,
      pendingBranch = suspense.pendingBranch,
      isInFallback = suspense.isInFallback,
      isHydrating = suspense.isHydrating;

  if (pendingBranch) {
    suspense.pendingBranch = newBranch;

    if (isSameVNodeType(newBranch, pendingBranch)) {
      // same root type but content may have changed.
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      // toggled before pending tree is resolved
      suspense.pendingId++;

      if (isHydrating) {
        // if toggled before hydration is finished, the current DOM tree is
        // no longer valid. set it as the active branch so it will be unmounted
        // when resolved
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      } // increment pending ID. this is used to invalidate async callbacks
      // reset suspense state


      suspense.deps = 0; // discard effects from pending branch

      suspense.effects.length = 0; // discard previous container

      suspense.hiddenContainer = createElement('div');

      if (isInFallback) {
        // already in fallback state
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // toggled "back" to current active branch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized); // force resolve

        suspense.resolve(true);
      } else {
        // switched to a 3rd branch
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      // root did not change, just normal patch
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      // root node toggled
      // invoke @pending event
      triggerEvent(n2, 'onPending'); // mount pending branch in off-dom container

      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        // incoming branch has no async deps, resolve now.
        suspense.resolve();
      } else {
        var timeout = suspense.timeout,
            pendingId = suspense.pendingId;

        if (timeout > 0) {
          setTimeout(function () {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}

var hasWarned = false;

function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals) {
  var isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;

  /* istanbul ignore if */
  if ( true && !hasWarned) {
    hasWarned = true; // @ts-ignore `console.info` cannot be null error

    console[console.info ? 'info' : 'log']("<Suspense> is an experimental feature and its API will likely change.");
  }

  var patch = rendererInternals.p,
      _move = rendererInternals.m,
      _unmount2 = rendererInternals.um,
      _next = rendererInternals.n,
      _rendererInternals$o = rendererInternals.o,
      parentNode = _rendererInternals$o.parentNode,
      remove = _rendererInternals$o.remove;
  var timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
  var suspense = {
    vnode: vnode,
    parent: parent,
    parentComponent: parentComponent,
    isSVG: isSVG,
    container: container,
    hiddenContainer: hiddenContainer,
    anchor: anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === 'number' ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating: isHydrating,
    isUnmounted: false,
    effects: [],
    resolve: function resolve() {
      var resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error("suspense.resolve() is called without a pending branch.");
        }

        if (suspense.isUnmounted) {
          throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");
        }
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          pendingBranch = suspense.pendingBranch,
          pendingId = suspense.pendingId,
          effects = suspense.effects,
          parentComponent = suspense.parentComponent,
          container = suspense.container;

      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        var delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';

        if (delayEnter) {
          activeBranch.transition.afterLeave = function () {
            if (pendingId === suspense.pendingId) {
              _move(pendingBranch, container, _anchor, 0
              /* ENTER */
              );
            }
          };
        } // this is initial anchor on mount


        var _anchor = suspense.anchor; // unmount current active tree

        if (activeBranch) {
          // if the fallback tree was mounted, it may have been moved
          // as part of a parent suspense. get the latest anchor for insertion
          _anchor = _next(activeBranch);

          _unmount2(activeBranch, parentComponent, suspense, true);
        }

        if (!delayEnter) {
          // move content from off-dom container to actual container
          _move(pendingBranch, container, _anchor, 0
          /* ENTER */
          );
        }
      }

      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false; // flush buffered effects
      // check if there is a pending parent suspense

      var parent = suspense.parent;
      var hasUnresolvedAncestor = false;

      while (parent) {
        if (parent.pendingBranch) {
          var _parent$effects;

          // found a pending parent suspense, merge buffered post jobs
          // into that parent
          (_parent$effects = parent.effects).push.apply(_parent$effects, _toConsumableArray(effects));

          hasUnresolvedAncestor = true;
          break;
        }

        parent = parent.parent;
      } // no pending parent suspense, flush all jobs


      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }

      suspense.effects = []; // invoke @resolve event

      triggerEvent(vnode, 'onResolve');
    },
    fallback: function fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          parentComponent = suspense.parentComponent,
          container = suspense.container,
          isSVG = suspense.isSVG; // invoke @fallback event

      triggerEvent(vnode, 'onFallback');

      var anchor = _next(activeBranch);

      var mountFallback = function mountFallback() {
        if (!suspense.isInFallback) {
          return;
        } // mount the fallback tree


        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };

      var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';

      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }

      suspense.isInFallback = true; // unmount current active branch

      _unmount2(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
      true // shouldRemove
      );

      if (!delayEnter) {
        mountFallback();
      }
    },
    move: function move(container, anchor, type) {
      suspense.activeBranch && _move(suspense.activeBranch, container, anchor, type);
      suspense.container = container;
    },
    next: function next() {
      return suspense.activeBranch && _next(suspense.activeBranch);
    },
    registerDep: function registerDep(instance, setupRenderEffect) {
      var isInPendingSuspense = !!suspense.pendingBranch;

      if (isInPendingSuspense) {
        suspense.deps++;
      }

      var hydratedEl = instance.vnode.el;
      instance.asyncDep["catch"](function (err) {
        handleError(err, instance, 0
        /* SETUP_FUNCTION */
        );
      }).then(function (asyncSetupResult) {
        // retry when the setup() promise resolves.
        // component may have been unmounted before resolve.
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        } // retry from this component


        instance.asyncResolved = true;
        var vnode = instance.vnode;

        if (true) {
          pushWarningContext(vnode);
        }

        handleSetupResult(instance, asyncSetupResult, false);

        if (hydratedEl) {
          // vnode may have been replaced if an update happened before the
          // async dep is resolved.
          vnode.el = hydratedEl;
        }

        var placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode, // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : _next(instance.subTree), suspense, isSVG, optimized);

        if (placeholder) {
          remove(placeholder);
        }

        updateHOCHostEl(instance, vnode.el);

        if (true) {
          popWarningContext();
        } // only decrease deps count if suspense is not already resolved


        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount: function unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;

      if (suspense.activeBranch) {
        _unmount2(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }

      if (suspense.pendingBranch) {
        _unmount2(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}

function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  /* eslint-disable no-restricted-globals */
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */
  ); // there are two possible scenarios for server-rendered suspense:
  // - success: ssr content should be fully resolved
  // - failure: ssr content should be the fallback branch.
  // however, on the client we don't really know if it has failed or not
  // attempt to hydrate the DOM assuming it has succeeded, but we still
  // need to construct a suspense boundary first

  var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);

  if (suspense.deps === 0) {
    suspense.resolve();
  }

  return result;
  /* eslint-enable no-restricted-globals */
}

function normalizeSuspenseChildren(vnode) {
  var shapeFlag = vnode.shapeFlag,
      children = vnode.children;
  var isSlotChildren = shapeFlag & 32
  /* SLOTS_CHILDREN */
  ;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children["default"] : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}

function normalizeSuspenseSlot(s) {
  var block;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    var trackBlock = isBlockTreeEnabled && s._c;

    if (trackBlock) {
      // disableTracking: false
      // allow block tracking for compiled slots
      // (see ./componentRenderContext.ts)
      s._d = false;
      openBlock();
    }

    s = s();

    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    var singleChild = filterSingleRoot(s);

    if ( true && !singleChild) {
      warn("<Suspense> slots expect a single root node.");
    }

    s = singleChild;
  }

  s = normalizeVNode(s);

  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter(function (c) {
      return c !== s;
    });
  }

  return s;
}

function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      var _suspense$effects;

      (_suspense$effects = suspense.effects).push.apply(_suspense$effects, _toConsumableArray(fn));
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  var vnode = suspense.vnode,
      parentComponent = suspense.parentComponent;
  var el = vnode.el = branch.el; // in case suspense is the root node of a component,
  // recursively update the HOC el

  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}

function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn("provide() can only be used inside setup().");
    }
  } else {
    var provides = currentInstance.provides; // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.

    var parentProvides = currentInstance.parent && currentInstance.parent.provides;

    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    } // TS doesn't allow symbol as index type


    provides[key] = value;
  }
}

function inject(key, defaultValue) {
  var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  var instance = currentInstance || currentRenderingInstance;

  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the instance is at root
    var provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;

    if (provides && key in provides) {
      // TS doesn't allow symbol as index type
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else if (true) {
      warn("injection \"".concat(String(key), "\" not found."));
    }
  } else if (true) {
    warn("inject() can only be used inside setup() or functional components.");
  }
} // Simple effect.


function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}

function watchPostEffect(effect, options) {
  return doWatch(effect, null,  true ? Object.assign(options || {}, {
    flush: 'post'
  }) : 0);
}

function watchSyncEffect(effect, options) {
  return doWatch(effect, null,  true ? Object.assign(options || {}, {
    flush: 'sync'
  }) : 0);
} // initial value for watchers to trigger on undefined initial values


var INITIAL_WATCHER_VALUE = {}; // implementation

function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn("`watch(fn, options?)` signature has been moved to a separate API. " + "Use `watchEffect(fn, options?)` instead. `watch` now only " + "supports `watch(source, cb, options?) signature.");
  }

  return doWatch(source, cb, options);
}

function doWatch(source, cb) {
  var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
      immediate = _ref7.immediate,
      deep = _ref7.deep,
      flush = _ref7.flush,
      onTrack = _ref7.onTrack,
      onTrigger = _ref7.onTrigger;

  if ( true && !cb) {
    if (immediate !== undefined) {
      warn("watch() \"immediate\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }

    if (deep !== undefined) {
      warn("watch() \"deep\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }
  }

  var warnInvalidSource = function warnInvalidSource(s) {
    warn("Invalid watch source: ", s, "A watch source can only be a getter/effect function, a ref, " + "a reactive object, or an array of these types.");
  };

  var instance = currentInstance;
  var getter;
  var forceTrigger = false;
  var isMultiSource = false;

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
    getter = function getter() {
      return source.value;
    };

    forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
    getter = function getter() {
      return source;
    };

    deep = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);

    getter = function getter() {
      return source.map(function (s) {
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
          return s.value;
        } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
          return traverse(s);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
          return callWithErrorHandling(s, instance, 2
          /* WATCH_GETTER */
          );
        } else {
           true && warnInvalidSource(s);
        }
      });
    };
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    if (cb) {
      // getter with cb
      getter = function getter() {
        return callWithErrorHandling(source, instance, 2
        /* WATCH_GETTER */
        );
      };
    } else {
      // no cb -> simple effect
      getter = function getter() {
        if (instance && instance.isUnmounted) {
          return;
        }

        if (cleanup) {
          cleanup();
        }

        return callWithAsyncErrorHandling(source, instance, 3
        /* WATCH_CALLBACK */
        , [onCleanup]);
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
     true && warnInvalidSource(source);
  }

  if (cb && deep) {
    var baseGetter = getter;

    getter = function getter() {
      return traverse(baseGetter());
    };
  }

  var cleanup;

  var onCleanup = function onCleanup(fn) {
    cleanup = effect.onStop = function () {
      callWithErrorHandling(fn, instance, 4
      /* WATCH_CLEANUP */
      );
    };
  }; // in SSR there is no need to setup an actual effect, and it should be noop
  // unless it's eager


  if (isInSSRComponentSetup) {
    // we will also not call the invalidate callback (+ runner is not set up)
    onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3
      /* WATCH_CALLBACK */
      , [getter(), isMultiSource ? [] : undefined, onCleanup]);
    }

    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
  }

  var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;

  var job = function job() {
    if (!effect.active) {
      return;
    }

    if (cb) {
      // watch(source, cb)
      var newValue = effect.run();

      if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]);
      }) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) || false) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup();
        }

        callWithAsyncErrorHandling(cb, instance, 3
        /* WATCH_CALLBACK */
        , [newValue, // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onCleanup]);
        oldValue = newValue;
      }
    } else {
      // watchEffect
      effect.run();
    }
  }; // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)


  job.allowRecurse = !!cb;
  var scheduler;

  if (flush === 'sync') {
    scheduler = job; // the scheduler function gets called directly
  } else if (flush === 'post') {
    scheduler = function scheduler() {
      return queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else {
    // default: 'pre'
    scheduler = function scheduler() {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }

  var effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);

  if (true) {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  } // initial run


  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }

  return function () {
    effect.stop();

    if (instance && instance.scope) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
    }
  };
} // this.$watch


function instanceWatch(source, value, options) {
  var publicThis = this.proxy;
  var getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : function () {
    return publicThis[source];
  } : source.bind(publicThis, publicThis);
  var cb;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }

  var cur = currentInstance;
  setCurrentInstance(this);
  var res = doWatch(getter, cb.bind(publicThis), options);

  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }

  return res;
}

function createPathGetter(ctx, path) {
  var segments = path.split('.');
  return function () {
    var cur = ctx;

    for (var i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }

    return cur;
  };
}

function traverse(value, seen) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip"
  /* SKIP */
  ]) {
    return value;
  }

  seen = seen || new Set();

  if (seen.has(value)) {
    return value;
  }

  seen.add(value);

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    traverse(value.value, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    for (var i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
    value.forEach(function (v) {
      traverse(v, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
    for (var key in value) {
      traverse(value[key], seen);
    }
  }

  return value;
}

function useTransitionState() {
  var state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(function () {
    state.isMounted = true;
  });
  onBeforeUnmount(function () {
    state.isUnmounting = true;
  });
  return state;
}

var TransitionHookValidator = [Function, Array];
var BaseTransitionImpl = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup: function setup(props, _ref8) {
    var slots = _ref8.slots;
    var instance = getCurrentInstance();
    var state = useTransitionState();
    var prevTransitionKey;
    return function () {
      var children = slots["default"] && getTransitionRawChildren(slots["default"](), true);

      if (!children || !children.length) {
        return;
      } // warn multiple elements


      if ( true && children.length > 1) {
        warn('<transition> can only be used on a single element or component. Use ' + '<transition-group> for lists.');
      } // there's no need to track reactivity for these props so use the raw
      // props for a bit better perf


      var rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      var mode = rawProps.mode; // check mode

      if ( true && mode && mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') {
        warn("invalid <transition> mode: ".concat(mode));
      } // at this point children has a guaranteed length of 1.


      var child = children[0];

      if (state.isLeaving) {
        return emptyPlaceholder(child);
      } // in the case of <transition><keep-alive/></transition>, we need to
      // compare the type of the kept-alive children.


      var innerChild = getKeepAliveChild(child);

      if (!innerChild) {
        return emptyPlaceholder(child);
      }

      var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      var oldChild = instance.subTree;
      var oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      var transitionKeyChanged = false;
      var getTransitionKey = innerChild.type.getTransitionKey;

      if (getTransitionKey) {
        var key = getTransitionKey();

        if (prevTransitionKey === undefined) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      } // handle mode


      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition

        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views

        if (mode === 'out-in') {
          state.isLeaving = true; // return placeholder node and queue update when leave finishes

          leavingHooks.afterLeave = function () {
            state.isLeaving = false;
            instance.update();
          };

          return emptyPlaceholder(child);
        } else if (mode === 'in-out' && innerChild.type !== Comment) {
          leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
            var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback

            el._leaveCb = function () {
              earlyRemove();
              el._leaveCb = undefined;
              delete enterHooks.delayedLeave;
            };

            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }

      return child;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(state, vnode) {
  var leavingVNodes = state.leavingVNodes;
  var leavingVNodesCache = leavingVNodes.get(vnode.type);

  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }

  return leavingVNodesCache;
} // The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.


function resolveTransitionHooks(vnode, props, state, instance) {
  var appear = props.appear,
      mode = props.mode,
      _props$persisted = props.persisted,
      persisted = _props$persisted === void 0 ? false : _props$persisted,
      onBeforeEnter = props.onBeforeEnter,
      onEnter = props.onEnter,
      onAfterEnter = props.onAfterEnter,
      onEnterCancelled = props.onEnterCancelled,
      onBeforeLeave = props.onBeforeLeave,
      onLeave = props.onLeave,
      onAfterLeave = props.onAfterLeave,
      onLeaveCancelled = props.onLeaveCancelled,
      onBeforeAppear = props.onBeforeAppear,
      onAppear = props.onAppear,
      onAfterAppear = props.onAfterAppear,
      onAppearCancelled = props.onAppearCancelled;
  var key = String(vnode.key);
  var leavingVNodesCache = getLeavingNodesForType(state, vnode);

  var callHook = function callHook(hook, args) {
    hook && callWithAsyncErrorHandling(hook, instance, 9
    /* TRANSITION_HOOK */
    , args);
  };

  var hooks = {
    mode: mode,
    persisted: persisted,
    beforeEnter: function beforeEnter(el) {
      var hook = onBeforeEnter;

      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      } // for same element (v-show)


      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */
        );
      } // for toggled element with same key (v-if)


      var leavingVNode = leavingVNodesCache[key];

      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        // force early removal (not cancelled)
        leavingVNode.el._leaveCb();
      }

      callHook(hook, [el]);
    },
    enter: function enter(el) {
      var hook = onEnter;
      var afterHook = onAfterEnter;
      var cancelHook = onEnterCancelled;

      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }

      var called = false;

      var done = el._enterCb = function (cancelled) {
        if (called) return;
        called = true;

        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }

        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }

        el._enterCb = undefined;
      };

      if (hook) {
        hook(el, done);

        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave: function leave(el, remove) {
      var key = String(vnode.key);

      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */
        );
      }

      if (state.isUnmounting) {
        return remove();
      }

      callHook(onBeforeLeave, [el]);
      var called = false;

      var done = el._leaveCb = function (cancelled) {
        if (called) return;
        called = true;
        remove();

        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }

        el._leaveCb = undefined;

        if (leavingVNodesCache[key] === vnode) {
          delete leavingVNodesCache[key];
        }
      };

      leavingVNodesCache[key] = vnode;

      if (onLeave) {
        onLeave(el, done);

        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone: function clone(vnode) {
      return resolveTransitionHooks(vnode, props, state, instance);
    }
  };
  return hooks;
} // the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.


function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}

function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}

function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6
  /* COMPONENT */
  && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}

function getTransitionRawChildren(children) {
  var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var ret = [];
  var keyedFragmentCount = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // handle fragment children case, e.g. v-for

    if (child.type === Fragment) {
      if (child.patchFlag & 128
      /* KEYED_FRAGMENT */
      ) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } // comment placeholders should be skipped, e.g. v-if
    else if (keepComment || child.type !== Comment) {
      ret.push(child);
    }
  } // #1126 if a transition children list contains multiple sub fragments, these
  // fragments will be merged into a flat children array. Since each v-for
  // fragment may contain different static bindings inside, we need to de-op
  // these children to force full diffs to ensure correct behavior.


  if (keyedFragmentCount > 1) {
    for (var _i2 = 0; _i2 < ret.length; _i2++) {
      ret[_i2].patchFlag = -2
      /* BAIL */
      ;
    }
  }

  return ret;
} // implementation, close to no-op


function defineComponent(options) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? {
    setup: options,
    name: options.name
  } : options;
}

var isAsyncWrapper = function isAsyncWrapper(i) {
  return !!i.type.__asyncLoader;
};

function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = {
      loader: source
    };
  }

  var _source = source,
      loader = _source.loader,
      loadingComponent = _source.loadingComponent,
      errorComponent = _source.errorComponent,
      _source$delay = _source.delay,
      delay = _source$delay === void 0 ? 200 : _source$delay,
      timeout = _source.timeout,
      _source$suspensible = _source.suspensible,
      suspensible = _source$suspensible === void 0 ? true : _source$suspensible,
      userOnError = _source.onError;
  var pendingRequest = null;
  var resolvedComp;
  var retries = 0;

  var retry = function retry() {
    retries++;
    pendingRequest = null;
    return load();
  };

  var load = function load() {
    var thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader()["catch"](function (err) {
      err = err instanceof Error ? err : new Error(String(err));

      if (userOnError) {
        return new Promise(function (resolve, reject) {
          var userRetry = function userRetry() {
            return resolve(retry());
          };

          var userFail = function userFail() {
            return reject(err);
          };

          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(function (comp) {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }

      if ( true && !comp) {
        warn("Async component loader resolved to undefined. " + "If you are using retry(), make sure to return its return value.");
      } // interop module default


      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
        comp = comp["default"];
      }

      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error("Invalid async component load result: ".concat(comp));
      }

      resolvedComp = comp;
      return comp;
    }));
  };

  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: load,

    get __asyncResolved() {
      return resolvedComp;
    },

    setup: function setup() {
      var instance = currentInstance; // already resolved

      if (resolvedComp) {
        return function () {
          return createInnerComp(resolvedComp, instance);
        };
      }

      var onError = function onError(err) {
        pendingRequest = null;
        handleError(err, instance, 13
        /* ASYNC_COMPONENT_LOADER */
        , !errorComponent
        /* do not throw in dev if user provided error component */
        );
      }; // suspense-controlled or SSR.


      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then(function (comp) {
          return function () {
            return createInnerComp(comp, instance);
          };
        })["catch"](function (err) {
          onError(err);
          return function () {
            return errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          };
        });
      }

      var loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      var error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      var delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);

      if (delay) {
        setTimeout(function () {
          delayed.value = false;
        }, delay);
      }

      if (timeout != null) {
        setTimeout(function () {
          if (!loaded.value && !error.value) {
            var err = new Error("Async component timed out after ".concat(timeout, "ms."));
            onError(err);
            error.value = err;
          }
        }, timeout);
      }

      load().then(function () {
        loaded.value = true;

        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          // parent is keep-alive, force update so the loaded component's
          // name is taken into account
          queueJob(instance.parent.update);
        }
      })["catch"](function (err) {
        onError(err);
        error.value = err;
      });
      return function () {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}

function createInnerComp(comp, _ref9) {
  var _ref9$vnode = _ref9.vnode,
      ref = _ref9$vnode.ref,
      props = _ref9$vnode.props,
      children = _ref9$vnode.children;
  var vnode = createVNode(comp, props, children); // ensure inner component inherits the async wrapper's ref owner

  vnode.ref = ref;
  return vnode;
}

var isKeepAlive = function isKeepAlive(vnode) {
  return vnode.type.__isKeepAlive;
};

var KeepAliveImpl = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup: function setup(props, _ref10) {
    var slots = _ref10.slots;
    var instance = getCurrentInstance(); // KeepAlive communicates with the instantiated renderer via the
    // ctx where the renderer passes in its internals,
    // and the KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.

    var sharedContext = instance.ctx; // if the internal renderer is not registered, it indicates that this is server-side rendering,
    // for KeepAlive, we just need to render its children

    if (!sharedContext.renderer) {
      return slots["default"];
    }

    var cache = new Map();
    var keys = new Set();
    var current = null;

    if (true) {
      instance.__v_cache = cache;
    }

    var parentSuspense = instance.suspense;
    var _sharedContext$render = sharedContext.renderer,
        patch = _sharedContext$render.p,
        move = _sharedContext$render.m,
        _unmount = _sharedContext$render.um,
        createElement = _sharedContext$render.o.createElement;
    var storageContainer = createElement('div');

    sharedContext.activate = function (vnode, container, anchor, isSVG, optimized) {
      var instance = vnode.component;
      move(vnode, container, anchor, 0
      /* ENTER */
      , parentSuspense); // in case props have changed

      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(function () {
        instance.isDeactivated = false;

        if (instance.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeMounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    sharedContext.deactivate = function (vnode) {
      var instance = vnode.component;
      move(vnode, storageContainer, null, 1
      /* LEAVE */
      , parentSuspense);
      queuePostRenderEffect(function () {
        if (instance.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }

        instance.isDeactivated = true;
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    function unmount(vnode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode);

      _unmount(vnode, instance, parentSuspense, true);
    }

    function pruneCache(filter) {
      cache.forEach(function (vnode, key) {
        var name = getComponentName(vnode.type);

        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }

    function pruneCacheEntry(key) {
      var cached = cache.get(key);

      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        resetShapeFlag(current);
      }

      cache["delete"](key);
      keys["delete"](key);
    } // prune cache on include/exclude prop change


    watch(function () {
      return [props.include, props.exclude];
    }, function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
          include = _ref12[0],
          exclude = _ref12[1];

      include && pruneCache(function (name) {
        return matches(include, name);
      });
      exclude && pruneCache(function (name) {
        return !matches(exclude, name);
      });
    }, // prune post-render after `current` has been updated
    {
      flush: 'post',
      deep: true
    }); // cache sub tree after render

    var pendingCacheKey = null;

    var cacheSubtree = function cacheSubtree() {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };

    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(function () {
      cache.forEach(function (cached) {
        var subTree = instance.subTree,
            suspense = instance.suspense;
        var vnode = getInnerChild(subTree);

        if (cached.type === vnode.type) {
          // current instance will be unmounted as part of keep-alive's unmount
          resetShapeFlag(vnode); // but invoke its deactivated hook here

          var da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }

        unmount(cached);
      });
    });
    return function () {
      pendingCacheKey = null;

      if (!slots["default"]) {
        return null;
      }

      var children = slots["default"]();
      var rawVNode = children[0];

      if (children.length > 1) {
        if (true) {
          warn("KeepAlive should contain exactly one component child.");
        }

        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4
      /* STATEFUL_COMPONENT */
      ) && !(rawVNode.shapeFlag & 128
      /* SUSPENSE */
      )) {
        current = null;
        return rawVNode;
      }

      var vnode = getInnerChild(rawVNode);
      var comp = vnode.type; // for async components, name check should be based in its loaded
      // inner component if available

      var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      var include = props.include,
          exclude = props.exclude,
          max = props.max;

      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }

      var key = vnode.key == null ? comp : vnode.key;
      var cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it

      if (vnode.el) {
        vnode = cloneVNode(vnode);

        if (rawVNode.shapeFlag & 128
        /* SUSPENSE */
        ) {
          rawVNode.ssContent = vnode;
        }
      } // #1513 it's possible for the returned vnode to be cloned due to attr
      // fallthrough or scopeId, so the vnode here may not be the final vnode
      // that is mounted. Instead of caching it directly, we store the pending
      // key and cache `instance.subTree` (the normalized vnode) in
      // beforeMount/beforeUpdate hooks.


      pendingCacheKey = key;

      if (cachedVNode) {
        // copy over mounted state
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;

        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition);
        } // avoid vnode being mounted as fresh


        vnode.shapeFlag |= 512
        /* COMPONENT_KEPT_ALIVE */
        ; // make this key the freshest

        keys["delete"](key);
        keys.add(key);
      } else {
        keys.add(key); // prune oldest entry

        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      } // avoid vnode being unmounted


      vnode.shapeFlag |= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
      current = vnode;
      return rawVNode;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var KeepAlive = KeepAliveImpl;

function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some(function (p) {
      return matches(p, name);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(',').includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a"
  /* ACTIVATED */
  , target);
}

function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da"
  /* DEACTIVATED */
  , target);
}

function registerKeepAliveHook(hook, type) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;

  // cache the deactivate branch check wrapper for injected hooks so the same
  // hook can be properly deduped by the scheduler. "__wdc" stands for "with
  // deactivation check".
  var wrappedHook = hook.__wdc || (hook.__wdc = function () {
    // only fire the hook if the target instance is NOT in a deactivated branch.
    var current = target;

    while (current) {
      if (current.isDeactivated) {
        return;
      }

      current = current.parent;
    }

    return hook();
  });

  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent
  // chain and register it on all ancestor instances that are keep-alive roots.
  // This avoids the need to walk the entire component tree when invoking these
  // hooks, and more importantly, avoids the need to track child components in
  // arrays.

  if (target) {
    var current = target.parent;

    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }

      current = current.parent;
    }
  }
}

function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  // injectHook wraps the original for error handling, so make sure to remove
  // the wrapped version.
  var injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */
  );
  onUnmounted(function () {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}

function resetShapeFlag(vnode) {
  var shapeFlag = vnode.shapeFlag;

  if (shapeFlag & 256
  /* COMPONENT_SHOULD_KEEP_ALIVE */
  ) {
    shapeFlag -= 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ;
  }

  if (shapeFlag & 512
  /* COMPONENT_KEPT_ALIVE */
  ) {
    shapeFlag -= 512
    /* COMPONENT_KEPT_ALIVE */
    ;
  }

  vnode.shapeFlag = shapeFlag;
}

function getInnerChild(vnode) {
  return vnode.shapeFlag & 128
  /* SUSPENSE */
  ? vnode.ssContent : vnode;
}

function injectHook(type, hook) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
  var prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (target) {
    var hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook
    // can be properly deduped by the scheduler. "__weh" stands for "with error
    // handling".

    var wrappedHook = hook.__weh || (hook.__weh = function () {
      if (target.isUnmounted) {
        return;
      } // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.


      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // Set currentInstance during hook invocation.
      // This assumes the hook does not synchronously trigger other hooks, which
      // can only be false when the user does something really funky.

      setCurrentInstance(target);

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });

    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }

    return wrappedHook;
  } else if (true) {
    var apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
    warn("".concat(apiName, " is called when there is no active component instance to be ") + "associated with. " + "Lifecycle injection APIs can only be used during execution of setup()." + (" If you are using async setup(), make sure to register lifecycle " + "hooks before the first await statement."));
  }
}

var createHook = function createHook(lifecycle) {
  return function (hook) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
    return (// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp"
      /* SERVER_PREFETCH */
      ) && injectHook(lifecycle, hook, target)
    );
  };
};

var onBeforeMount = createHook("bm"
/* BEFORE_MOUNT */
);
var onMounted = createHook("m"
/* MOUNTED */
);
var onBeforeUpdate = createHook("bu"
/* BEFORE_UPDATE */
);
var onUpdated = createHook("u"
/* UPDATED */
);
var onBeforeUnmount = createHook("bum"
/* BEFORE_UNMOUNT */
);
var onUnmounted = createHook("um"
/* UNMOUNTED */
);
var onServerPrefetch = createHook("sp"
/* SERVER_PREFETCH */
);
var onRenderTriggered = createHook("rtg"
/* RENDER_TRIGGERED */
);
var onRenderTracked = createHook("rtc"
/* RENDER_TRACKED */
);

function onErrorCaptured(hook) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
  injectHook("ec"
  /* ERROR_CAPTURED */
  , hook, target);
}

function createDuplicateChecker() {
  var cache = Object.create(null);
  return function (type, key) {
    if (cache[key]) {
      warn("".concat(type, " property \"").concat(key, "\" is already defined in ").concat(cache[key], "."));
    } else {
      cache[key] = type;
    }
  };
}

var shouldCacheAccess = true;

function applyOptions(instance) {
  var options = resolveMergedOptions(instance);
  var publicThis = instance.proxy;
  var ctx = instance.ctx; // do not cache property access on public proxy during state initialization

  shouldCacheAccess = false; // call beforeCreate first before accessing other options since
  // the hook may mutate resolved options (#2791)

  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc"
    /* BEFORE_CREATE */
    );
  }

  var dataOptions = options.data,
      computedOptions = options.computed,
      methods = options.methods,
      watchOptions = options.watch,
      provideOptions = options.provide,
      injectOptions = options.inject,
      created = options.created,
      beforeMount = options.beforeMount,
      mounted = options.mounted,
      beforeUpdate = options.beforeUpdate,
      updated = options.updated,
      activated = options.activated,
      deactivated = options.deactivated,
      beforeDestroy = options.beforeDestroy,
      beforeUnmount = options.beforeUnmount,
      destroyed = options.destroyed,
      unmounted = options.unmounted,
      render = options.render,
      renderTracked = options.renderTracked,
      renderTriggered = options.renderTriggered,
      errorCaptured = options.errorCaptured,
      serverPrefetch = options.serverPrefetch,
      expose = options.expose,
      inheritAttrs = options.inheritAttrs,
      components = options.components,
      directives = options.directives,
      filters = options.filters;
  var checkDuplicateProperties =  true ? createDuplicateChecker() : 0;

  if (true) {
    var _instance$propsOption3 = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption3[0];

    if (propsOptions) {
      for (var key in propsOptions) {
        checkDuplicateProperties("Props"
        /* PROPS */
        , key);
      }
    }
  } // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data (deferred since it relies on `this` access)
  // - computed
  // - watch (deferred since it relies on `this` access)


  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }

  if (methods) {
    for (var _key5 in methods) {
      var methodHandler = methods[_key5];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define
        // methods to the proxy target, and those are read-only but
        // reconfigurable, so it needs to be redefined here
        if (true) {
          Object.defineProperty(ctx, _key5, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}

        if (true) {
          checkDuplicateProperties("Methods"
          /* METHODS */
          , _key5);
        }
      } else if (true) {
        warn("Method \"".concat(_key5, "\" has type \"").concat(_typeof(methodHandler), "\" in the component definition. ") + "Did you reference the function correctly?");
      }
    }
  }

  if (dataOptions) {
    (function () {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
        warn("The data option must be a function. " + "Plain object usage is no longer supported.");
      }

      var data = dataOptions.call(publicThis, publicThis);

      if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
        warn("data() returned a Promise - note data() cannot be async; If you " + "intend to perform data fetching before component renders, use " + "async setup() + <Suspense>.");
      }

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
         true && warn("data() should return an object.");
      } else {
        instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);

        if (true) {
          var _loop = function _loop(_key6) {
            checkDuplicateProperties("Data"
            /* DATA */
            , _key6); // expose data on ctx during dev

            if (_key6[0] !== '$' && _key6[0] !== '_') {
              Object.defineProperty(ctx, _key6, {
                configurable: true,
                enumerable: true,
                get: function get() {
                  return data[_key6];
                },
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
              });
            }
          };

          for (var _key6 in data) {
            _loop(_key6);
          }
        }
      }
    })();
  } // state initialization complete at this point - start caching access


  shouldCacheAccess = true;

  if (computedOptions) {
    var _loop2 = function _loop2(_key7) {
      var opt = computedOptions[_key7];
      var get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn("Computed property \"".concat(_key7, "\" has no getter."));
      }

      var set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? function () {
        warn("Write operation failed: computed property \"".concat(_key7, "\" is readonly."));
      } : 0;
      var c = computed({
        get: get,
        set: set
      });
      Object.defineProperty(ctx, _key7, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return c.value;
        },
        set: function set(v) {
          return c.value = v;
        }
      });

      if (true) {
        checkDuplicateProperties("Computed"
        /* COMPUTED */
        , _key7);
      }
    };

    for (var _key7 in computedOptions) {
      _loop2(_key7);
    }
  }

  if (watchOptions) {
    for (var _key8 in watchOptions) {
      createWatcher(watchOptions[_key8], ctx, publicThis, _key8);
    }
  }

  if (provideOptions) {
    var provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(function (key) {
      provide(key, provides[key]);
    });
  }

  if (created) {
    callHook(created, instance, "c"
    /* CREATED */
    );
  }

  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach(function (_hook) {
        return register(_hook.bind(publicThis));
      });
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }

  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      var exposed = instance.exposed || (instance.exposed = {});
      expose.forEach(function (key) {
        Object.defineProperty(exposed, key, {
          get: function get() {
            return publicThis[key];
          },
          set: function set(val) {
            return publicThis[key] = val;
          }
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  } // options that are handled when creating the instance but also need to be
  // applied from mixins


  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }

  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  } // asset options.


  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}

function resolveInjections(injectOptions, ctx) {
  var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
  var unwrapRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }

  var _loop3 = function _loop3(key) {
    var opt = injectOptions[key];
    var injected = void 0;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ('default' in opt) {
        injected = inject(opt.from || key, opt["default"], true
        /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }

    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
      // TODO remove the check in 3.3
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: function get() {
            return injected.value;
          },
          set: function set(v) {
            return injected.value = v;
          }
        });
      } else {
        if (true) {
          warn("injected property \"".concat(key, "\" is a ref and will be auto-unwrapped ") + "and no longer needs `.value` in the next minor release. " + "To opt-in to the new behavior now, " + "set `app.config.unwrapInjectedRef = true` (this config is " + "temporary and will not be needed in the future.)");
        }

        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }

    if (true) {
      checkDuplicateProperties("Inject"
      /* INJECT */
      , key);
    }
  };

  for (var key in injectOptions) {
    _loop3(key);
  }
}

function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map(function (h) {
    return h.bind(instance.proxy);
  }) : hook.bind(instance.proxy), instance, type);
}

function createWatcher(raw, ctx, publicThis, key) {
  var getter = key.includes('.') ? createPathGetter(publicThis, key) : function () {
    return publicThis[key];
  };

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    var handler = ctx[raw];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      watch(getter, handler);
    } else if (true) {
      warn("Invalid watch handler specified by key \"".concat(raw, "\""), handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach(function (r) {
        return createWatcher(r, ctx, publicThis, key);
      });
    } else {
      var _handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_handler)) {
        watch(getter, _handler, raw);
      } else if (true) {
        warn("Invalid watch handler specified by key \"".concat(raw.handler, "\""), _handler);
      }
    }
  } else if (true) {
    warn("Invalid watch option: \"".concat(key, "\""), raw);
  }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */


function resolveMergedOptions(instance) {
  var base = instance.type;
  var mixins = base.mixins,
      extendsOptions = base["extends"];
  var _instance$appContext = instance.appContext,
      globalMixins = _instance$appContext.mixins,
      cache = _instance$appContext.optionsCache,
      optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
  var cached = cache.get(base);
  var resolved;

  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};

    if (globalMixins.length) {
      globalMixins.forEach(function (m) {
        return mergeOptions(resolved, m, optionMergeStrategies, true);
      });
    }

    mergeOptions(resolved, base, optionMergeStrategies);
  }

  cache.set(base, resolved);
  return resolved;
}

function mergeOptions(to, from, strats) {
  var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var mixins = from.mixins,
      extendsOptions = from["extends"];

  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }

  if (mixins) {
    mixins.forEach(function (m) {
      return mergeOptions(to, m, strats, true);
    });
  }

  for (var key in from) {
    if (asMixin && key === 'expose') {
       true && warn("\"expose\" option is ignored when declared in mixins or extends. " + "It should only be declared in the base component itself.");
    } else {
      var strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }

  return to;
}

var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};

function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }

  if (!to) {
    return from;
  }

  return function mergedDataFn() {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
  };
}

function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}

function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    var res = {};

    for (var i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }

    return res;
  }

  return raw;
}

function mergeAsArray(to, from) {
  return to ? _toConsumableArray(new Set([].concat(to, from))) : from;
}

function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}

function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  var merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);

  for (var key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }

  return merged;
}

function initProps(instance, rawProps, isStateful) {
  var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var props = {};
  var attrs = {};
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs); // ensure all declared prop keys are present

  for (var key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = undefined;
    }
  } // validation


  if (true) {
    validateProps(rawProps || {}, props, instance);
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional w/ declared props
      instance.props = props;
    }
  }

  instance.attrs = attrs;
}

function updateProps(instance, rawProps, rawPrevProps, optimized) {
  var props = instance.props,
      attrs = instance.attrs,
      patchFlag = instance.vnode.patchFlag;
  var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);

  var _instance$propsOption4 = _slicedToArray(instance.propsOptions, 1),
      options = _instance$propsOption4[0];

  var hasAttrsChanged = false;

  if ( // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  !( true && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16
  /* FULL_PROPS */
  )) {
    if (patchFlag & 8
    /* PROPS */
    ) {
      // Compiler-generated props & no keys change, just set the updated
      // the props.
      var propsToUpdate = instance.vnode.dynamicProps;

      for (var i = 0; i < propsToUpdate.length; i++) {
        var key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null

        var value = rawProps[key];

        if (options) {
          // attr / props separation was done on init and will be consistent
          // in this code path, so just check if attrs have it.
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            var camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
            /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    // full props update.
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    } // in case of dynamic props, check if we need to delete keys from
    // the props object


    var kebabKey;

    for (var _key9 in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key9) && ( // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(_key9)) === _key9 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && ( // for camelCase
          rawPrevProps[_key9] !== undefined || // for kebab-case
          rawPrevProps[kebabKey] !== undefined)) {
            props[_key9] = resolvePropValue(options, rawCurrentProps, _key9, undefined, instance, true
            /* isAbsent */
            );
          }
        } else {
          delete props[_key9];
        }
      }
    } // in the case of functional component w/o props declaration, props and
    // attrs point to the same object so it should already have been updated.


    if (attrs !== rawCurrentProps) {
      for (var _key10 in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key10) && !false) {
          delete attrs[_key10];
          hasAttrsChanged = true;
        }
      }
    }
  } // trigger updates for $attrs in case it's used in component slots


  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set"
    /* SET */
    , '$attrs');
  }

  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}

function setFullProps(instance, rawProps, props, attrs) {
  var _instance$propsOption5 = _slicedToArray(instance.propsOptions, 2),
      options = _instance$propsOption5[0],
      needCastKeys = _instance$propsOption5[1];

  var hasAttrsChanged = false;
  var rawCastValues;

  if (rawProps) {
    for (var key in rawProps) {
      // key, ref are reserved and never passed down
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }

      var value = rawProps[key]; // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.

      var camelKey = void 0;

      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }

  if (needCastKeys) {
    var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    var castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

    for (var i = 0; i < needCastKeys.length; i++) {
      var _key11 = needCastKeys[i];
      props[_key11] = resolvePropValue(options, rawCurrentProps, _key11, castValues[_key11], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, _key11));
    }
  }

  return hasAttrsChanged;
}

function resolvePropValue(options, props, key, value, instance, isAbsent) {
  var opt = options[key];

  if (opt != null) {
    var hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default'); // default values

    if (hasDefault && value === undefined) {
      var defaultValue = opt["default"];

      if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        var propsDefaults = instance.propsDefaults;

        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    } // boolean casting


    if (opt[0
    /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1
      /* shouldCastTrue */
      ] && (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }

  return value;
}

function normalizePropsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.propsCache;
  var cached = cache.get(comp);

  if (cached) {
    return cached;
  }

  var raw = comp.props;
  var normalized = {};
  var needCastKeys = []; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendProps = function extendProps(raw) {
      hasExtends = true;

      var _normalizePropsOption = normalizePropsOptions(raw, appContext, true),
          _normalizePropsOption2 = _slicedToArray(_normalizePropsOption, 2),
          props = _normalizePropsOption2[0],
          keys = _normalizePropsOption2[1];

      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push.apply(needCastKeys, _toConsumableArray(keys));
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }

    if (comp["extends"]) {
      extendProps(comp["extends"]);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (var i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn("props must be strings when using array syntax.", raw[i]);
      }

      var normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);

      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn("invalid props options", raw);
    }

    for (var key in raw) {
      var _normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);

      if (validatePropName(_normalizedKey)) {
        var opt = raw[key];
        var prop = normalized[_normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? {
          type: opt
        } : opt;

        if (prop) {
          var booleanIndex = getTypeIndex(Boolean, prop.type);
          var stringIndex = getTypeIndex(String, prop.type);
          prop[0
          /* shouldCast */
          ] = booleanIndex > -1;
          prop[1
          /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value

          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
            needCastKeys.push(_normalizedKey);
          }
        }
      }
    }
  }

  var res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}

function validatePropName(key) {
  if (key[0] !== '$') {
    return true;
  } else if (true) {
    warn("Invalid prop name: \"".concat(key, "\" is a reserved property."));
  }

  return false;
} // use function string name to check type constructors
// so that it works across vms / iframes.


function getType(ctor) {
  var match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? 'null' : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
    return expectedTypes.findIndex(function (t) {
      return isSameType(t, type);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  return -1;
}
/**
 * dev only
 */


function validateProps(rawProps, props, instance) {
  var resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  var options = instance.propsOptions[0];

  for (var key in options) {
    var opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
  }
}
/**
 * dev only
 */


function validateProp(name, value, prop, isAbsent) {
  var type = prop.type,
      required = prop.required,
      validator = prop.validator; // required!

  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  } // missing but optional


  if (value == null && !prop.required) {
    return;
  } // type check


  if (type != null && type !== true) {
    var isValid = false;
    var types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    var expectedTypes = []; // value is valid as long as one of the specified types match

    for (var i = 0; i < types.length && !isValid; i++) {
      var _assertType = assertType(value, types[i]),
          valid = _assertType.valid,
          expectedType = _assertType.expectedType;

      expectedTypes.push(expectedType || '');
      isValid = valid;
    }

    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  } // custom validator


  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}

var isSimpleType = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (isSimpleType(expectedType)) {
    var t = _typeof(value);

    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === 'Array') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else if (expectedType === 'null') {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * dev only
 */


function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") + " Expected ".concat(expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | '));
  var expectedType = expectedTypes[0];
  var receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value ".concat(expectedValue);
  }

  message += ", got ".concat(receivedType, " "); // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value ".concat(receivedValue, ".");
  }

  return message;
}
/**
 * dev only
 */


function styleValue(value, type) {
  if (type === 'String') {
    return "\"".concat(value, "\"");
  } else if (type === 'Number') {
    return "".concat(Number(value));
  } else {
    return "".concat(value);
  }
}
/**
 * dev only
 */


function isExplicable(type) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return type.toLowerCase() === elem;
  });
}
/**
 * dev only
 */


function isBoolean() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key12 = 0; _key12 < _len5; _key12++) {
    args[_key12] = arguments[_key12];
  }

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}

var isInternalKey = function isInternalKey(key) {
  return key[0] === '_' || key === '$stable';
};

var normalizeSlotValue = function normalizeSlotValue(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
};

var normalizeSlot = function normalizeSlot(key, rawSlot, ctx) {
  var normalized = withCtx(function () {
    if ( true && currentInstance) {
      warn("Slot \"".concat(key, "\" invoked outside of the render function: ") + "this will not track dependencies used in the slot. " + "Invoke the slot function inside the render function instead.");
    }

    return normalizeSlotValue(rawSlot.apply(void 0, arguments));
  }, ctx);
  normalized._c = false;
  return normalized;
};

var normalizeObjectSlots = function normalizeObjectSlots(rawSlots, slots, instance) {
  var ctx = rawSlots._ctx;

  for (var key in rawSlots) {
    if (isInternalKey(key)) continue;
    var value = rawSlots[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      (function () {
        if (true) {
          warn("Non-function value encountered for slot \"".concat(key, "\". ") + "Prefer function slots for better performance.");
        }

        var normalized = normalizeSlotValue(value);

        slots[key] = function () {
          return normalized;
        };
      })();
    }
  }
};

var normalizeVNodeSlots = function normalizeVNodeSlots(instance, children) {
  if ( true && !isKeepAlive(instance.vnode) && !false) {
    warn("Non-function value encountered for default slot. " + "Prefer function slots for better performance.");
  }

  var normalized = normalizeSlotValue(children);

  instance.slots["default"] = function () {
    return normalized;
  };
};

var initSlots = function initSlots(instance, children) {
  if (instance.vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
    var type = children._;

    if (type) {
      // users can get the shallow readonly version of the slots object through `this.$slots`,
      // we should avoid the proxy object polluting the slots of the internal instance
      instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children); // make compiler marker non-enumerable

      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};

    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }

  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};

var updateSlots = function updateSlots(instance, children, optimized) {
  var vnode = instance.vnode,
      slots = instance.slots;
  var needDeletionCheck = true;
  var deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  if (vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
    var type = children._;

    if (type) {
      // compiled slots.
      if ( true && isHmrUpdating) {
        // Parent was HMR updated so slot content may have changed.
        // force update slots and mark instance for hmr as well
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
      } else if (optimized && type === 1
      /* STABLE */
      ) {
        // compiled AND stable.
        // no need to update, and skip stale slots removal.
        needDeletionCheck = false;
      } else {
        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
        // normalization.
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children); // #2893
        // when rendering the optimized slots by manually written render function,
        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
        // i.e. let the `renderSlot` create the bailed Fragment

        if (!optimized && type === 1
        /* STABLE */
        ) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }

    deletionComparisonTarget = children;
  } else if (children) {
    // non slot object children (direct value) passed to a component
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      "default": 1
    };
  } // delete stale slots


  if (needDeletionCheck) {
    for (var key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/


function validateDirectiveName(name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
    warn('Do not use built-in directive ids as custom directive id: ' + name);
  }
}
/**
 * Adds directives to a VNode.
 */


function withDirectives(vnode, directives) {
  var internalInstance = currentRenderingInstance;

  if (internalInstance === null) {
     true && warn("withDirectives can only be used inside render functions.");
    return vnode;
  }

  var instance = internalInstance.proxy;
  var bindings = vnode.dirs || (vnode.dirs = []);

  for (var i = 0; i < directives.length; i++) {
    var _directives$i = _slicedToArray(directives[i], 4),
        dir = _directives$i[0],
        value = _directives$i[1],
        arg = _directives$i[2],
        _directives$i$ = _directives$i[3],
        modifiers = _directives$i$ === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : _directives$i$;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }

    if (dir.deep) {
      traverse(value);
    }

    bindings.push({
      dir: dir,
      instance: instance,
      value: value,
      oldValue: void 0,
      arg: arg,
      modifiers: modifiers
    });
  }

  return vnode;
}

function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  var bindings = vnode.dirs;
  var oldBindings = prevVNode && prevVNode.dirs;

  for (var i = 0; i < bindings.length; i++) {
    var binding = bindings[i];

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }

    var hook = binding.dir[name];

    if (hook) {
      // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8
      /* DIRECTIVE_HOOK */
      , [vnode.el, binding, vnode, prevVNode]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: undefined,
      warnHandler: undefined,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}

var uid = 0;

function createAppAPI(render, hydrate) {
  return function createApp(rootComponent) {
    var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn("root props passed to app.mount() must be an object.");
      rootProps = null;
    }

    var context = createAppContext();
    var installedPlugins = new Set();
    var isMounted = false;
    var app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version,

      get config() {
        return context.config;
      },

      set config(v) {
        if (true) {
          warn("app.config cannot be replaced. Modify individual options instead.");
        }
      },

      use: function use(plugin) {
        for (var _len6 = arguments.length, options = new Array(_len6 > 1 ? _len6 - 1 : 0), _key13 = 1; _key13 < _len6; _key13++) {
          options[_key13 - 1] = arguments[_key13];
        }

        if (installedPlugins.has(plugin)) {
           true && warn("Plugin has already been applied to target app.");
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install.apply(plugin, [app].concat(options));
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin.apply(void 0, [app].concat(options));
        } else if (true) {
          warn("A plugin must either be a function or an object with an \"install\" " + "function.");
        }

        return app;
      },
      mixin: function mixin(_mixin) {
        if (true) {
          if (!context.mixins.includes(_mixin)) {
            context.mixins.push(_mixin);
          } else if (true) {
            warn('Mixin has already been applied to target app' + (_mixin.name ? ": ".concat(_mixin.name) : ''));
          }
        } else {}

        return app;
      },
      component: function component(name, _component) {
        if (true) {
          validateComponentName(name, context.config);
        }

        if (!_component) {
          return context.components[name];
        }

        if ( true && context.components[name]) {
          warn("Component \"".concat(name, "\" has already been registered in target app."));
        }

        context.components[name] = _component;
        return app;
      },
      directive: function directive(name, _directive) {
        if (true) {
          validateDirectiveName(name);
        }

        if (!_directive) {
          return context.directives[name];
        }

        if ( true && context.directives[name]) {
          warn("Directive \"".concat(name, "\" has already been registered in target app."));
        }

        context.directives[name] = _directive;
        return app;
      },
      mount: function mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          var vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.
          // this will be set on the root instance on initial mount.

          vnode.appContext = context; // HMR root reload

          if (true) {
            context.reload = function () {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }

          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }

          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;

          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }

          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (true) {
          warn("App has already been mounted.\n" + "If you want to remount the same app, move your app creation logic " + "into a factory function and create fresh app instances for each " + "mount - e.g. `const createMyApp = () => createApp(App)`");
        }
      },
      unmount: function unmount() {
        if (isMounted) {
          render(null, app._container);

          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }

          delete app._container.__vue_app__;
        } else if (true) {
          warn("Cannot unmount an app that is not mounted.");
        }
      },
      provide: function provide(key, value) {
        if ( true && key in context.provides) {
          warn("App already provides property with key \"".concat(String(key), "\". ") + "It will be overwritten with the new value.");
        } // TypeScript doesn't allow symbols as index type
        // https://github.com/Microsoft/TypeScript/issues/24587


        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
/**
 * Function for handling a template ref
 */


function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
  var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach(function (r, i) {
      return setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
    });
    return;
  }

  if (isAsyncWrapper(vnode) && !isUnmount) {
    // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
  }

  var refValue = vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  var value = isUnmount ? null : refValue;
  var owner = rawRef.i,
      ref = rawRef.r;

  if ( true && !owner) {
    warn("Missing ref owner context. ref cannot be used on hoisted vnodes. " + "A vnode with ref must be created inside the render function.");
    return;
  }

  var oldRef = oldRawRef && oldRawRef.r;
  var refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  var setupState = owner.setupState; // dynamic ref changed. unset old ref

  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12
    /* FUNCTION_REF */
    , [value, refs]);
  } else {
    var _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);

    var _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);

    if (_isString || _isRef) {
      var doSet = function doSet() {
        if (rawRef.f) {
          var existing = _isString ? refs[ref] : ref.value;

          if (isUnmount) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
          } else {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (true) {
          warn('Invalid template ref type:', ref, "(".concat(_typeof(ref), ")"));
        }
      };

      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (true) {
      warn('Invalid template ref type:', ref, "(".concat(_typeof(ref), ")"));
    }
  }
}

var hasMismatch = false;

var isSVGContainer = function isSVGContainer(container) {
  return /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
};

var isComment = function isComment(node) {
  return node.nodeType === 8;
}
/* COMMENT */
; // Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.


function createHydrationFunctions(rendererInternals) {
  var mountComponent = rendererInternals.mt,
      patch = rendererInternals.p,
      _rendererInternals$o2 = rendererInternals.o,
      patchProp = _rendererInternals$o2.patchProp,
      nextSibling = _rendererInternals$o2.nextSibling,
      parentNode = _rendererInternals$o2.parentNode,
      remove = _rendererInternals$o2.remove,
      insert = _rendererInternals$o2.insert,
      createComment = _rendererInternals$o2.createComment;

  var hydrate = function hydrate(vnode, container) {
    if (!container.hasChildNodes()) {
       true && warn("Attempting to hydrate existing markup but container is empty. " + "Performing full mount instead.");
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }

    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();

    if (hasMismatch && !false) {
      // this error should show up in production
      console.error("Hydration completed but contains mismatches.");
    }
  };

  var hydrateNode = function hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
    var optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var isFragmentStart = isComment(node) && node.data === '[';

    var onMismatch = function onMismatch() {
      return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    };

    var type = vnode.type,
        ref = vnode.ref,
        shapeFlag = vnode.shapeFlag;
    var domType = node.nodeType;
    vnode.el = node;
    var nextNode = null;

    switch (type) {
      case Text:
        if (domType !== 3
        /* TEXT */
        ) {
          nextNode = onMismatch();
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             true && warn("Hydration text mismatch:" + "\n- Client: ".concat(JSON.stringify(node.data)) + "\n- Server: ".concat(JSON.stringify(vnode.children)));
            node.data = vnode.children;
          }

          nextNode = nextSibling(node);
        }

        break;

      case Comment:
        if (domType !== 8
        /* COMMENT */
        || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }

        break;

      case Static:
        if (domType !== 1
        /* ELEMENT */
        ) {
          nextNode = onMismatch();
        } else {
          // determine anchor, adopt content
          nextNode = node; // if the static vnode has its content stripped during build,
          // adopt it from the server-rendered HTML.

          var needToAdoptContent = !vnode.children.length;

          for (var i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;

            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }

            nextNode = nextSibling(nextNode);
          }

          return nextNode;
        }

        break;

      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
          if (domType !== 1
          /* ELEMENT */
          || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
          // when setting up the render effect, if the initial vnode already
          // has .el set, the component will perform hydration instead of mount
          // on its sub-tree.
          vnode.slotScopeIds = slotScopeIds;
          var container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized); // component may be async, so in the case of fragments we cannot rely
          // on component's rendered output to determine the end of the fragment
          // instead, we do a lookahead to find the end anchor node.

          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node); // #3787
          // if component is async, it may get moved / unmounted before its
          // inner component is loaded, so we need to give it a placeholder
          // vnode that matches its adopted DOM.

          if (isAsyncWrapper(vnode)) {
            var subTree;

            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
            }

            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
          if (domType !== 8
          /* COMMENT */
          ) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else if (true) {
          warn('Invalid HostVNode type:', type, "(".concat(_typeof(type), ")"));
        }

    }

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }

    return nextNode;
  };

  var hydrateElement = function hydrateElement(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!vnode.dynamicChildren;
    var type = vnode.type,
        props = vnode.props,
        patchFlag = vnode.patchFlag,
        shapeFlag = vnode.shapeFlag,
        dirs = vnode.dirs; // #4006 for form elements with non-string v-model value bindings
    // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">

    var forcePatchValue = type === 'input' && dirs || type === 'option'; // skip props & children if this is hoisted static nodes
    // #5405 in dev, always hydrate children for HMR

    if (true
    /* HOISTED */
    ) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16
        /* FULL_PROPS */
        | 32
        /* HYDRATE_EVENTS */
        )) {
          for (var key in props) {
            if (forcePatchValue && key.endsWith('value') || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
              patchProp(el, key, null, props[key], false, undefined, parentComponent);
            }
          }
        } else if (props.onClick) {
          // Fast path for click listeners (which is most often) to avoid
          // iterating through props.
          patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
        }
      } // vnode / directive hooks


      var vnodeHooks;

      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
      }

      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(function () {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
        }, parentSuspense);
      } // children


      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        var _hasWarned = false;

        while (next) {
          hasMismatch = true;

          if ( true && !_hasWarned) {
            warn("Hydration children mismatch in <".concat(vnode.type, ">: ") + "server rendered element contains more child nodes than client vdom.");
            _hasWarned = true;
          } // The SSRed DOM contains more nodes than it should. Remove them.


          var cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
           true && warn("Hydration text content mismatch in <".concat(vnode.type, ">:\n") + "- Client: ".concat(el.textContent, "\n") + "- Server: ".concat(vnode.children));
          el.textContent = vnode.children;
        }
      }
    }

    return el.nextSibling;
  };

  var hydrateChildren = function hydrateChildren(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!parentVNode.dynamicChildren;
    var children = parentVNode.children;
    var l = children.length;
    var hasWarned = false;

    for (var i = 0; i < l; i++) {
      var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);

      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;

        if ( true && !hasWarned) {
          warn("Hydration children mismatch in <".concat(container.tagName.toLowerCase(), ">: ") + "server rendered element contains fewer child nodes than client vdom.");
          hasWarned = true;
        } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.


        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }

    return node;
  };

  var hydrateFragment = function hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    var fragmentSlotScopeIds = vnode.slotScopeIds;

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    var container = parentNode(node);
    var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);

    if (next && isComment(next) && next.data === ']') {
      return nextSibling(vnode.anchor = next);
    } else {
      // fragment didn't hydrate successfully, since we didn't get a end anchor
      // back. This should have led to node/children mismatch warnings.
      hasMismatch = true; // since the anchor is missing, we need to create one and insert it

      insert(vnode.anchor = createComment("]"), container, next);
      return next;
    }
  };

  var handleMismatch = function handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
    hasMismatch = true;
     true && warn("Hydration node mismatch:\n- Client vnode:", vnode.type, "\n- Server rendered DOM:", node, node.nodeType === 3
    /* TEXT */
    ? "(text)" : isComment(node) && node.data === '[' ? "(start of fragment)" : "");
    vnode.el = null;

    if (isFragment) {
      // remove excessive fragment nodes
      var end = locateClosingAsyncAnchor(node);

      while (true) {
        var _next2 = nextSibling(node);

        if (_next2 && _next2 !== end) {
          remove(_next2);
        } else {
          break;
        }
      }
    }

    var next = nextSibling(node);
    var container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };

  var locateClosingAsyncAnchor = function locateClosingAsyncAnchor(node) {
    var match = 0;

    while (node) {
      node = nextSibling(node);

      if (node && isComment(node)) {
        if (node.data === '[') match++;

        if (node.data === ']') {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }

    return node;
  };

  return [hydrate, hydrateNode];
}
/* eslint-disable no-restricted-globals */


var supported;
var perf;

function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark("vue-".concat(type, "-").concat(instance.uid));
  }

  if (true) {
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
  }
}

function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    var startTag = "vue-".concat(type, "-").concat(instance.uid);
    var endTag = startTag + ":end";
    perf.mark(endTag);
    perf.measure("<".concat(formatComponentName(instance, instance.type), "> ").concat(type), startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }

  if (true) {
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
  }
}

function isSupported() {
  if (supported !== undefined) {
    return supported;
  }

  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }

  return supported;
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */


function initFeatureFlags() {
  var needWarn = [];

  if (false) {}

  if (false) {}

  if ( true && needWarn.length) {
    var multi = needWarn.length > 1;
    console.warn("Feature flag".concat(multi ? "s" : "", " ").concat(needWarn.join(', '), " ").concat(multi ? "are" : "is", " not explicitly defined. You are running the esm-bundler build of Vue, ") + "which expects these compile-time feature flags to be globally injected " + "via the bundler config in order to get better tree-shaking in the " + "production bundle.\n\n" + "For more details, see https://link.vuejs.org/feature-flags.");
  }
}

var queuePostRenderEffect = queueEffectWithSuspense;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */

function createRenderer(options) {
  return baseCreateRenderer(options);
} // Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.


function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
} // implementation


function baseCreateRenderer(options, createHydrationFns) {
  // compile-time feature flags check
  {
    initFeatureFlags();
  }
  var target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  target.__VUE__ = true;

  if (true) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }

  var hostInsert = options.insert,
      hostRemove = options.remove,
      hostPatchProp = options.patchProp,
      hostCreateElement = options.createElement,
      hostCreateText = options.createText,
      hostCreateComment = options.createComment,
      hostSetText = options.setText,
      hostSetElementText = options.setElementText,
      hostParentNode = options.parentNode,
      hostNextSibling = options.nextSibling,
      _options$setScopeId = options.setScopeId,
      hostSetScopeId = _options$setScopeId === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP : _options$setScopeId,
      hostCloneNode = options.cloneNode,
      hostInsertStaticContent = options.insertStaticContent; // Note: functions inside this closure should use `const xxx = () => {}`
  // style in order to prevent being inlined by minifiers.

  var patch = function patch(n1, n2, container) {
    var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var isSVG = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] :  true && isHmrUpdating ? false : !!n2.dynamicChildren;

    if (n1 === n2) {
      return;
    } // patching & not same type, unmount old tree


    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }

    if (n2.patchFlag === -2
    /* BAIL */
    ) {
      optimized = false;
      n2.dynamicChildren = null;
    }

    var type = n2.type,
        ref = n2.ref,
        shapeFlag = n2.shapeFlag;

    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;

      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;

      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (true) {
          patchStaticNode(n1, n2, container, isSVG);
        }

        break;

      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (true) {
          warn('Invalid VNode type:', type, "(".concat(_typeof(type), ")"));
        }

    } // set ref


    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };

  var processText = function processText(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      var el = n2.el = n1.el;

      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };

  var processCommentNode = function processCommentNode(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el;
    }
  };

  var mountStaticNode = function mountStaticNode(n2, container, anchor, isSVG) {
    var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);

    var _hostInsertStaticCont2 = _slicedToArray(_hostInsertStaticCont, 2);

    n2.el = _hostInsertStaticCont2[0];
    n2.anchor = _hostInsertStaticCont2[1];
  };
  /**
   * Dev / HMR only
   */


  var patchStaticNode = function patchStaticNode(n1, n2, container, isSVG) {
    // static nodes are only patched during dev for HMR
    if (n2.children !== n1.children) {
      var anchor = hostNextSibling(n1.anchor); // remove existing

      removeStaticNode(n1);

      var _hostInsertStaticCont3 = hostInsertStaticContent(n2.children, container, anchor, isSVG);

      var _hostInsertStaticCont4 = _slicedToArray(_hostInsertStaticCont3, 2);

      n2.el = _hostInsertStaticCont4[0];
      n2.anchor = _hostInsertStaticCont4[1];
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };

  var moveStaticNode = function moveStaticNode(_ref13, container, nextSibling) {
    var el = _ref13.el,
        anchor = _ref13.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }

    hostInsert(anchor, container, nextSibling);
  };

  var removeStaticNode = function removeStaticNode(_ref14) {
    var el = _ref14.el,
        anchor = _ref14.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }

    hostRemove(anchor);
  };

  var processElement = function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    isSVG = isSVG || n2.type === 'svg';

    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var mountElement = function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el;
    var vnodeHook;
    var type = vnode.type,
        props = vnode.props,
        shapeFlag = vnode.shapeFlag,
        transition = vnode.transition,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs;

    if (false
    /* HOISTED */
    ) {} else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props); // mount children first, since some props may rely on child content
      // being already rendered, e.g. `<select value>`

      if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
      }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        for (var key in props) {
          if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        /**
         * Special case for setting value on DOM elements:
         * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
         * - it needs to be forced (#1471)
         * #2353 proposes adding another renderer option to configure this, but
         * the properties affects are so finite it is worth special casing it
         * here to reduce the complexity. (Special casing it also should not
         * affect non-DOM renderers)
         */


        if ('value' in props) {
          hostPatchProp(el, 'value', null, props.value);
        }

        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      } // scopeId


      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }

    if (true) {
      Object.defineProperty(el, '__vnode', {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, '__vueParentComponent', {
        value: parentComponent,
        enumerable: false
      });
    }

    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
    // #1689 For inside suspense + suspense resolved case, just call it


    var needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;

    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }

    hostInsert(el, container, anchor);

    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
      }, parentSuspense);
    }
  };

  var setScopeId = function setScopeId(el, vnode, scopeId, slotScopeIds, parentComponent) {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }

    if (slotScopeIds) {
      for (var i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }

    if (parentComponent) {
      var subTree = parentComponent.subTree;

      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048
      /* DEV_ROOT_FRAGMENT */
      ) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }

      if (vnode === subTree) {
        var parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };

  var mountChildren = function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

    for (var i = start; i < children.length; i++) {
      var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var patchElement = function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el = n2.el = n1.el;
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        dirs = n2.dirs; // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS

    patchFlag |= n1.patchFlag & 16
    /* FULL_PROPS */
    ;
    var oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var vnodeHook; // disable recurse in beforeUpdate hooks

    parentComponent && toggleRecurse(parentComponent, false);

    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }

    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
    }

    parentComponent && toggleRecurse(parentComponent, true);

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    var areChildrenSVG = isSVG && n2.type !== 'foreignObject';

    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);

      if ( true && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      // full diff
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }

    if (patchFlag > 0) {
      // the presence of a patchFlag means this element's render code was
      // generated by the compiler and can take the fast path.
      // in this path old node and new node are guaranteed to have the same shape
      // (i.e. at the exact same position in the source template)
      if (patchFlag & 16
      /* FULL_PROPS */
      ) {
        // element props contain dynamic keys, full diff needed
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        // class
        // this flag is matched when the element has dynamic class bindings.
        if (patchFlag & 2
        /* CLASS */
        ) {
          if (oldProps["class"] !== newProps["class"]) {
            hostPatchProp(el, 'class', null, newProps["class"], isSVG);
          }
        } // style
        // this flag is matched when the element has dynamic style bindings


        if (patchFlag & 4
        /* STYLE */
        ) {
          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
        } // props
        // This flag is matched when the element has dynamic prop/attr bindings
        // other than class and style. The keys of dynamic prop/attrs are saved for
        // faster iteration.
        // Note dynamic keys like :[foo]="bar" will cause this optimization to
        // bail out and go through a full diff because we need to unset the old key


        if (patchFlag & 8
        /* PROPS */
        ) {
          // if the flag is present then dynamicProps must be non-null
          var propsToUpdate = n2.dynamicProps;

          for (var i = 0; i < propsToUpdate.length; i++) {
            var key = propsToUpdate[i];
            var prev = oldProps[key];
            var next = newProps[key]; // #1471 force patch value

            if (next !== prev || key === 'value') {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      } // text
      // This flag is matched when the element has only dynamic text children.


      if (patchFlag & 1
      /* TEXT */
      ) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      // unoptimized, full diff
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }

    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
      }, parentSuspense);
    }
  }; // The fast path for blocks.


  var patchBlockChildren = function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    for (var i = 0; i < newChildren.length; i++) {
      var oldVNode = oldChildren[i];
      var newVNode = newChildren[i]; // Determine the container (parent element) for the patch.

      var container = // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && ( // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & (6
      /* COMPONENT */
      | 64
      /* TELEPORT */
      )) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };

  var patchProps = function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {
    if (oldProps !== newProps) {
      for (var key in newProps) {
        // empty string is not valid prop
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        var next = newProps[key];
        var prev = oldProps[key]; // defer patching value

        if (next !== prev && key !== 'value') {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }

      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (var _key14 in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(_key14) && !(_key14 in newProps)) {
            hostPatchProp(el, _key14, oldProps[_key14], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }

      if ('value' in newProps) {
        hostPatchProp(el, 'value', oldProps.value, newProps.value);
      }
    }
  };

  var processFragment = function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
    var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        fragmentSlotScopeIds = n2.slotScopeIds;

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    } // check if this is a slot fragment with :slotted scope ids


    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children
      // since they are either generated by the compiler, or implicitly created
      // from arrays.

      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);

        if ( true && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */
          );
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };

  var processComponent = function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    n2.slotScopeIds = slotScopeIds;

    if (n1 == null) {
      if (n2.shapeFlag & 512
      /* COMPONENT_KEPT_ALIVE */
      ) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };

  var mountComponent = function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
    var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);

    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }

    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, "mount");
    } // inject renderer internals for keepAlive


    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    } // resolve props and slots for setup context


    {
      if (true) {
        startMeasure(instance, "init");
      }

      setupComponent(instance);

      if (true) {
        endMeasure(instance, "init");
      }
    } // setup() is async. This component relies on async logic to be resolved
    // before proceeding

    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration
      // TODO handle self-defined fallback

      if (!initialVNode.el) {
        var placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }

      return;
    }

    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);

    if (true) {
      popWarningContext();
      endMeasure(instance, "mount");
    }
  };

  var updateComponent = function updateComponent(n1, n2, optimized) {
    var instance = n2.component = n1.component;

    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        // async & still pending - just update props and slots
        // since the component's reactive effect for render isn't set-up yet
        if (true) {
          pushWarningContext(n2);
        }

        updateComponentPreRender(instance, n2, optimized);

        if (true) {
          popWarningContext();
        }

        return;
      } else {
        // normal update
        instance.next = n2; // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.

        invalidateJob(instance.update); // instance.update is the reactive effect.

        instance.update();
      }
    } else {
      // no update needed. just copy over properties
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };

  var setupRenderEffect = function setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) {
    var componentUpdateFn = function componentUpdateFn() {
      if (!instance.isMounted) {
        var vnodeHook;
        var _initialVNode = initialVNode,
            el = _initialVNode.el,
            props = _initialVNode.props;
        var bm = instance.bm,
            m = instance.m,
            parent = instance.parent;
        var isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false); // beforeMount hook

        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        } // onVnodeBeforeMount


        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }

        toggleRecurse(instance, true);

        if (el && hydrateNode) {
          // vnode has adopted host node - perform hydration instead of mount.
          var hydrateSubTree = function hydrateSubTree() {
            if (true) {
              startMeasure(instance, "render");
            }

            instance.subTree = renderComponentRoot(instance);

            if (true) {
              endMeasure(instance, "render");
            }

            if (true) {
              startMeasure(instance, "hydrate");
            }

            hydrateNode(el, instance.subTree, instance, parentSuspense, null);

            if (true) {
              endMeasure(instance, "hydrate");
            }
          };

          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then( // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            function () {
              return !instance.isUnmounted && hydrateSubTree();
            });
          } else {
            hydrateSubTree();
          }
        } else {
          if (true) {
            startMeasure(instance, "render");
          }

          var subTree = instance.subTree = renderComponentRoot(instance);

          if (true) {
            endMeasure(instance, "render");
          }

          if (true) {
            startMeasure(instance, "patch");
          }

          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);

          if (true) {
            endMeasure(instance, "patch");
          }

          initialVNode.el = subTree.el;
        } // mounted hook


        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        } // onVnodeMounted


        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          var scopedInitialVNode = initialVNode;
          queuePostRenderEffect(function () {
            return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
          }, parentSuspense);
        } // activated hook for keep-alive roots.
        // #1742 activated hook must be accessed after first render
        // since the hook may be injected by a child keep-alive


        if (initialVNode.shapeFlag & 256
        /* COMPONENT_SHOULD_KEEP_ALIVE */
        ) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }

        instance.isMounted = true;

        if (true) {
          devtoolsComponentAdded(instance);
        } // #2458: deference mount-only object parameters to prevent memleaks


        initialVNode = container = anchor = null;
      } else {
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        var next = instance.next,
            bu = instance.bu,
            u = instance.u,
            _parent = instance.parent,
            vnode = instance.vnode;
        var originNext = next;

        var _vnodeHook;

        if (true) {
          pushWarningContext(next || instance.vnode);
        } // Disallow component effect recursion during pre-lifecycle hooks.


        toggleRecurse(instance, false);

        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        } // beforeUpdate hook


        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        } // onVnodeBeforeUpdate


        if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(_vnodeHook, _parent, next, vnode);
        }

        toggleRecurse(instance, true); // render

        if (true) {
          startMeasure(instance, "render");
        }

        var nextTree = renderComponentRoot(instance);

        if (true) {
          endMeasure(instance, "render");
        }

        var prevTree = instance.subTree;
        instance.subTree = nextTree;

        if (true) {
          startMeasure(instance, "patch");
        }

        patch(prevTree, nextTree, // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);

        if (true) {
          endMeasure(instance, "patch");
        }

        next.el = nextTree.el;

        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el);
        } // updated hook


        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        } // onVnodeUpdated


        if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(function () {
            return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
          }, parentSuspense);
        }

        if (true) {
          devtoolsComponentUpdated(instance);
        }

        if (true) {
          popWarningContext();
        }
      }
    }; // create reactive effect for rendering


    var effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, function () {
      return queueJob(instance.update);
    }, instance.scope // track it in component's effect scope
    );
    var update = instance.update = effect.run.bind(effect);
    update.id = instance.uid; // allowRecurse
    // #1801, #2043 component render effects should allow recursive updates

    toggleRecurse(instance, true);

    if (true) {
      effect.onTrack = instance.rtc ? function (e) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e);
      } : void 0;
      effect.onTrigger = instance.rtg ? function (e) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e);
      } : void 0; // @ts-ignore (for scheduler)

      update.ownerInstance = instance;
    }

    update();
  };

  var updateComponentPreRender = function updateComponentPreRender(instance, nextVNode, optimized) {
    nextVNode.component = instance;
    var prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // props update may have triggered pre-flush watchers.
    // flush them before the render update.

    flushPreFlushCbs(undefined, instance.update);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };

  var patchChildren = function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var c1 = n1 && n1.children;
    var prevShapeFlag = n1 ? n1.shapeFlag : 0;
    var c2 = n2.children;
    var patchFlag = n2.patchFlag,
        shapeFlag = n2.shapeFlag; // fast path

    if (patchFlag > 0) {
      if (patchFlag & 128
      /* KEYED_FRAGMENT */
      ) {
        // this could be either fully-keyed or mixed (some keyed some not)
        // presence of patchFlag means children are guaranteed to be arrays
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) {
        // unkeyed
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    } // children has 3 possibilities: text, array or no children.


    if (shapeFlag & 8
    /* TEXT_CHILDREN */
    ) {
      // text children fast path
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }

      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        // prev children was array
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          // two arrays, cannot assume anything, do full diff
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          // no new children, just unmount old
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
          hostSetElementText(container, '');
        } // mount new if array


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };

  var patchUnkeyedChildren = function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    var oldLength = c1.length;
    var newLength = c2.length;
    var commonLength = Math.min(oldLength, newLength);
    var i;

    for (i = 0; i < commonLength; i++) {
      var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }

    if (oldLength > newLength) {
      // remove old
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      // mount new
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  }; // can be all-keyed or mixed


  var patchKeyedChildren = function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var i = 0;
    var l2 = c2.length;
    var e1 = c1.length - 1; // prev ending index

    var e2 = l2 - 1; // next ending index
    // 1. sync from start
    // (a b) c
    // (a b) d e

    while (i <= e1 && i <= e2) {
      var n1 = c1[i];
      var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      i++;
    } // 2. sync from end
    // a (b c)
    // d e (b c)


    while (i <= e1 && i <= e2) {
      var _n2 = c1[e1];

      var _n3 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);

      if (isSameVNodeType(_n2, _n3)) {
        patch(_n2, _n3, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      e1--;
      e2--;
    } // 3. common sequence + mount
    // (a b)
    // (a b) c
    // i = 2, e1 = 1, e2 = 2
    // (a b)
    // c (a b)
    // i = 0, e1 = -1, e2 = 0


    if (i > e1) {
      if (i <= e2) {
        var nextPos = e2 + 1;
        var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;

        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } // 4. common sequence + unmount
    // (a b) c
    // (a b)
    // i = 2, e1 = 2, e2 = 1
    // a (b c)
    // (b c)
    // i = 0, e1 = 0, e2 = -1
    else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } // 5. unknown sequence
    // [i ... e1 + 1]: a b [c d e] f g
    // [i ... e2 + 1]: a b [e d c h] f g
    // i = 2, e1 = 4, e2 = 5
    else {
      var s1 = i; // prev starting index

      var s2 = i; // next starting index
      // 5.1 build key:index map for newChildren

      var keyToNewIndexMap = new Map();

      for (i = s2; i <= e2; i++) {
        var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

        if (nextChild.key != null) {
          if ( true && keyToNewIndexMap.has(nextChild.key)) {
            warn("Duplicate keys found during update:", JSON.stringify(nextChild.key), "Make sure keys are unique.");
          }

          keyToNewIndexMap.set(nextChild.key, i);
        }
      } // 5.2 loop through old children left to be patched and try to patch
      // matching nodes & remove nodes that are no longer present


      var j;
      var patched = 0;
      var toBePatched = e2 - s2 + 1;
      var moved = false; // used to track whether any node has moved

      var maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>
      // Note that oldIndex is offset by +1
      // and oldIndex = 0 is a special value indicating the new node has
      // no corresponding old node.
      // used for determining longest stable subsequence

      var newIndexToOldIndexMap = new Array(toBePatched);

      for (i = 0; i < toBePatched; i++) {
        newIndexToOldIndexMap[i] = 0;
      }

      for (i = s1; i <= e1; i++) {
        var prevChild = c1[i];

        if (patched >= toBePatched) {
          // all new children have been patched so this can only be a removal
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }

        var newIndex = void 0;

        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          // key-less node, try to locate a key-less node of the same type
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }

        if (newIndex === undefined) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;

          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }

          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      } // 5.3 move and mount
      // generate longest stable subsequence only when nodes have moved


      var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor

      for (i = toBePatched - 1; i >= 0; i--) {
        var nextIndex = s2 + i;
        var _nextChild = c2[nextIndex];

        var _anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;

        if (newIndexToOldIndexMap[i] === 0) {
          // mount new
          patch(null, _nextChild, container, _anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          // move if:
          // There is no stable subsequence (e.g. a reverse)
          // OR current node is not among the stable sequence
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(_nextChild, container, _anchor2, 2
            /* REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };

  var move = function move(vnode, container, anchor, moveType) {
    var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var el = vnode.el,
        type = vnode.type,
        transition = vnode.transition,
        children = vnode.children,
        shapeFlag = vnode.shapeFlag;

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
      type.move(vnode, container, anchor, internals);
      return;
    }

    if (type === Fragment) {
      hostInsert(el, container, anchor);

      for (var i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }

      hostInsert(vnode.anchor, container, anchor);
      return;
    }

    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    } // single nodes


    var needTransition = moveType !== 2
    /* REORDER */
    && shapeFlag & 1
    /* ELEMENT */
    && transition;

    if (needTransition) {
      if (moveType === 0
      /* ENTER */
      ) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(function () {
          return transition.enter(el);
        }, parentSuspense);
      } else {
        var leave = transition.leave,
            delayLeave = transition.delayLeave,
            afterLeave = transition.afterLeave;

        var _remove = function _remove() {
          return hostInsert(el, container, anchor);
        };

        var performLeave = function performLeave() {
          leave(el, function () {
            _remove();

            afterLeave && afterLeave();
          });
        };

        if (delayLeave) {
          delayLeave(el, _remove, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };

  var unmount = function unmount(vnode, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var type = vnode.type,
        props = vnode.props,
        ref = vnode.ref,
        children = vnode.children,
        dynamicChildren = vnode.dynamicChildren,
        shapeFlag = vnode.shapeFlag,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs; // unset ref

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }

    if (shapeFlag & 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }

    var shouldInvokeDirs = shapeFlag & 1
    /* ELEMENT */
    && dirs;
    var shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    var vnodeHook;

    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128
      /* SUSPENSE */
      ) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }

      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
      }

      if (shapeFlag & 64
      /* TELEPORT */
      ) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      )) {
        // fast path for block nodes: only need to unmount dynamic children.
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128
      /* KEYED_FRAGMENT */
      | 256
      /* UNKEYED_FRAGMENT */
      ) || !optimized && shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }

      if (doRemove) {
        remove(vnode);
      }
    }

    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
      }, parentSuspense);
    }
  };

  var remove = function remove(vnode) {
    var type = vnode.type,
        el = vnode.el,
        anchor = vnode.anchor,
        transition = vnode.transition;

    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }

    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }

    var performRemove = function performRemove() {
      hostRemove(el);

      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };

    if (vnode.shapeFlag & 1
    /* ELEMENT */
    && transition && !transition.persisted) {
      var leave = transition.leave,
          delayLeave = transition.delayLeave;

      var performLeave = function performLeave() {
        return leave(el, performRemove);
      };

      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };

  var removeFragment = function removeFragment(cur, end) {
    // For fragments, directly remove all contained DOM nodes.
    // (fragment child nodes cannot have transition)
    var next;

    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }

    hostRemove(end);
  };

  var unmountComponent = function unmountComponent(instance, parentSuspense, doRemove) {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }

    var bum = instance.bum,
        scope = instance.scope,
        update = instance.update,
        subTree = instance.subTree,
        um = instance.um; // beforeUnmount hook

    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    } // stop effects in component scope


    scope.stop(); // update may be null if a component is unmounted before its async
    // setup has resolved.

    if (update) {
      // so that scheduler will no longer invoke it
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    } // unmounted hook


    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }

    queuePostRenderEffect(function () {
      instance.isUnmounted = true;
    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before
    // its async dep resolves. This should remove the dep from the suspense, and
    // cause the suspense to resolve immediately if that was the last dep.

    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;

      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }

    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };

  var unmountChildren = function unmountChildren(children, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    for (var i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };

  var getNextHostNode = function getNextHostNode(vnode) {
    if (vnode.shapeFlag & 6
    /* COMPONENT */
    ) {
      return getNextHostNode(vnode.component.subTree);
    }

    if (vnode.shapeFlag & 128
    /* SUSPENSE */
    ) {
      return vnode.suspense.next();
    }

    return hostNextSibling(vnode.anchor || vnode.el);
  };

  var render = function render(vnode, container, isSVG) {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }

    flushPostFlushCbs();
    container._vnode = vnode;
  };

  var internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  var hydrate;
  var hydrateNode;

  if (createHydrationFns) {
    var _createHydrationFns = createHydrationFns(internals);

    var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2);

    hydrate = _createHydrationFns2[0];
    hydrateNode = _createHydrationFns2[1];
  }

  return {
    render: render,
    hydrate: hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}

function toggleRecurse(_ref15, allowed) {
  var effect = _ref15.effect,
      update = _ref15.update;
  effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */


function traverseStaticChildren(n1, n2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var ch1 = n1.children;
  var ch2 = n2.children;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (var i = 0; i < ch1.length; i++) {
      // this is only called in the optimized path so array children are
      // guaranteed to be vnodes
      var c1 = ch1[i];
      var c2 = ch2[i];

      if (c2.shapeFlag & 1
      /* ELEMENT */
      && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32
        /* HYDRATE_EVENTS */
        ) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }

        if (!shallow) traverseStaticChildren(c1, c2);
      } // also inherit for comment nodes, but not placeholders (e.g. v-if which
      // would have received .el during block patch)


      if ( true && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence


function getSequence(arr) {
  var p = arr.slice();
  var result = [0];
  var i, j, u, v, c;
  var len = arr.length;

  for (i = 0; i < len; i++) {
    var arrI = arr[i];

    if (arrI !== 0) {
      j = result[result.length - 1];

      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      u = 0;
      v = result.length - 1;

      while (u < v) {
        c = u + v >> 1;

        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }

      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }

        result[u] = i;
      }
    }
  }

  u = result.length;
  v = result[u - 1];

  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }

  return result;
}

var isTeleport = function isTeleport(type) {
  return type.__isTeleport;
};

var isTeleportDisabled = function isTeleportDisabled(props) {
  return props && (props.disabled || props.disabled === '');
};

var isTargetSVG = function isTargetSVG(target) {
  return typeof SVGElement !== 'undefined' && target instanceof SVGElement;
};

var resolveTarget = function resolveTarget(props, select) {
  var targetSelector = props && props.to;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn("Current renderer does not support string target for Teleports. " + "(missing querySelector renderer option)");
      return null;
    } else {
      var target = select(targetSelector);

      if (!target) {
         true && warn("Failed to locate Teleport target with selector \"".concat(targetSelector, "\". ") + "Note the target element must exist before the component is mounted - " + "i.e. the target cannot be rendered by the component itself, and " + "ideally should be outside of the entire Vue component tree.");
      }

      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn("Invalid Teleport target: ".concat(targetSelector));
    }

    return targetSelector;
  }
};

var TeleportImpl = {
  __isTeleport: true,
  process: function (_process) {
    function process(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    var mountChildren = internals.mc,
        patchChildren = internals.pc,
        patchBlockChildren = internals.pbc,
        _internals$o = internals.o,
        insert = _internals$o.insert,
        querySelector = _internals$o.querySelector,
        createText = _internals$o.createText,
        createComment = _internals$o.createComment;
    var disabled = isTeleportDisabled(n2.props);
    var shapeFlag = n2.shapeFlag,
        children = n2.children,
        dynamicChildren = n2.dynamicChildren; // #3302
    // HMR updated, force full diff

    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      // insert anchors in the main view
      var placeholder = n2.el =  true ? createComment('teleport start') : 0;
      var mainAnchor = n2.anchor =  true ? createComment('teleport end') : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      var target = n2.target = resolveTarget(n2.props, querySelector);
      var targetAnchor = n2.targetAnchor = createText('');

      if (target) {
        insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree

        isSVG = isSVG || isTargetSVG(target);
      } else if ( true && !disabled) {
        warn('Invalid Teleport target on mount:', target, "(".concat(_typeof(target), ")"));
      }

      var mount = function mount(container, anchor) {
        // Teleport *always* has Array children. This is enforced in both the
        // compiler and vnode children normalization.
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };

      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      // update content
      n2.el = n1.el;

      var _mainAnchor = n2.anchor = n1.anchor;

      var _target = n2.target = n1.target;

      var _targetAnchor = n2.targetAnchor = n1.targetAnchor;

      var wasDisabled = isTeleportDisabled(n1.props);
      var currentContainer = wasDisabled ? container : _target;
      var currentAnchor = wasDisabled ? _mainAnchor : _targetAnchor;
      isSVG = isSVG || isTargetSVG(_target);

      if (dynamicChildren) {
        // fast path when the teleport happens to be a block root
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds); // even in block tree mode we need to make sure all root-level nodes
        // in the teleport inherit previous DOM references so that they can
        // be moved in future patches.

        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }

      if (disabled) {
        if (!wasDisabled) {
          // enabled -> disabled
          // move into main container
          moveTeleport(n2, container, _mainAnchor, internals, 1
          /* TOGGLE */
          );
        }
      } else {
        // target changed
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          var nextTarget = n2.target = resolveTarget(n2.props, querySelector);

          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0
            /* TARGET_CHANGE */
            );
          } else if (true) {
            warn('Invalid Teleport target on update:', _target, "(".concat(_typeof(_target), ")"));
          }
        } else if (wasDisabled) {
          // disabled -> enabled
          // move into teleport target
          moveTeleport(n2, _target, _targetAnchor, internals, 1
          /* TOGGLE */
          );
        }
      }
    }
  }),
  remove: function remove(vnode, parentComponent, parentSuspense, optimized, _ref16, doRemove) {
    var unmount = _ref16.um,
        hostRemove = _ref16.o.remove;
    var shapeFlag = vnode.shapeFlag,
        children = vnode.children,
        anchor = vnode.anchor,
        targetAnchor = vnode.targetAnchor,
        target = vnode.target,
        props = vnode.props;

    if (target) {
      hostRemove(targetAnchor);
    } // an unmounted teleport should always remove its children if not disabled


    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);

      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};

function moveTeleport(vnode, container, parentAnchor, _ref17) {
  var insert = _ref17.o.insert,
      move = _ref17.m;
  var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;

  // move target anchor if this is a target change.
  if (moveType === 0
  /* TARGET_CHANGE */
  ) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }

  var el = vnode.el,
      anchor = vnode.anchor,
      shapeFlag = vnode.shapeFlag,
      children = vnode.children,
      props = vnode.props;
  var isReorder = moveType === 2
  /* REORDER */
  ; // move main view anchor if this is a re-order.

  if (isReorder) {
    insert(el, container, parentAnchor);
  } // if this is a re-order and teleport is enabled (content is in target)
  // do not move children. So the opposite is: only move children if this
  // is not a reorder, or the teleport is disabled


  if (!isReorder || isTeleportDisabled(props)) {
    // Teleport has either Array children or no children.
    if (shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
      for (var i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2
        /* REORDER */
        );
      }
    }
  } // move main view anchor if this is a re-order.


  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}

function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref18, hydrateChildren) {
  var _ref18$o = _ref18.o,
      nextSibling = _ref18$o.nextSibling,
      parentNode = _ref18$o.parentNode,
      querySelector = _ref18$o.querySelector;
  var target = vnode.target = resolveTarget(vnode.props, querySelector);

  if (target) {
    // if multiple teleports rendered to the same target element, we need to
    // pick up from where the last teleport finished instead of the first node
    var targetNode = target._lpa || target.firstChild;

    if (vnode.shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }

      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }

  return vnode.anchor && nextSibling(vnode.anchor);
} // Force-casted public typing for h and TSX props inference


var Teleport = TeleportImpl;
var COMPONENTS = 'components';
var DIRECTIVES = 'directives';
/**
 * @private
 */

function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}

var NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */

function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
/**
 * @private
 */


function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
} // implementation


function resolveAsset(type, name) {
  var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var instance = currentRenderingInstance || currentInstance;

  if (instance) {
    var Component = instance.type; // explicit self name has highest priority

    if (type === COMPONENTS) {
      var selfName = getComponentName(Component);

      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }

    var res = // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) || // global registration
    resolve(instance.appContext[type], name);

    if (!res && maybeSelfReference) {
      // fallback to implicit self-reference
      return Component;
    }

    if ( true && warnMissing && !res) {
      var extra = type === COMPONENTS ? "\nIf this is a native custom element, make sure to exclude it from " + "component resolution via compilerOptions.isCustomElement." : "";
      warn("Failed to resolve ".concat(type.slice(0, -1), ": ").concat(name).concat(extra));
    }

    return res;
  } else if (true) {
    warn("resolve".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1)), " ") + "can only be used in render() or setup().");
  }
}

function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

var Fragment = Symbol( true ? 'Fragment' : 0);
var Text = Symbol( true ? 'Text' : 0);
var Comment = Symbol( true ? 'Comment' : 0);
var Static = Symbol( true ? 'Static' : 0); // Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).

var blockStack = [];
var currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */

function openBlock() {
  var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  blockStack.push(currentBlock = disableTracking ? null : []);
}

function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
} // Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)


var isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */

function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}

function setupBlock(vnode) {
  // save current block children on the block vnode
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null; // close block

  closeBlock(); // a block is always going to be patched, so track it as a child of its
  // parent block

  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}
/**
 * @private
 */


function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true
  /* isBlock */
  ));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */


function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */
  ));
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}

function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6
  /* COMPONENT */
  && hmrDirtyComponents.has(n2.type)) {
    // HMR only: if the component has been hot-updated, force a reload.
    return false;
  }

  return n1.type === n2.type && n1.key === n2.key;
}

var vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */

function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}

var createVNodeWithArgsTransform = function createVNodeWithArgsTransform() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key15 = 0; _key15 < _len7; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return _createVNode.apply(void 0, _toConsumableArray(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};

var InternalObjectKey = "__vInternal";

var normalizeKey = function normalizeKey(_ref19) {
  var key = _ref19.key;
  return key != null ? key : null;
};

var normalizeRef = function normalizeRef(_ref20) {
  var ref = _ref20.ref,
      ref_key = _ref20.ref_key,
      ref_for = _ref20.ref_for;
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? {
    i: currentRenderingInstance,
    r: ref,
    k: ref_key,
    f: !!ref_for
  } : ref : null;
};

function createBaseVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var shapeFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : type === Fragment ? 0 : 1;
  var isBlockNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type,
    props: props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: shapeFlag,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    dynamicChildren: null,
    appContext: null
  };

  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children); // normalize suspense children

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
      type.normalize(vnode);
    }
  } else if (children) {
    // compiled element vnode - if children is passed, only possible types are
    // string or Array.
    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children) ? 8
    /* TEXT_CHILDREN */
    : 16
    /* ARRAY_CHILDREN */
    ;
  } // validate key


  if ( true && vnode.key !== vnode.key) {
    warn("VNode created with invalid key (NaN). VNode type:", vnode.type);
  } // track vnode for block tree


  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  vnode.patchFlag > 0 || shapeFlag & 6
  /* COMPONENT */
  ) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32
  /* HYDRATE_EVENTS */
  ) {
    currentBlock.push(vnode);
  }

  return vnode;
}

var createVNode =  true ? createVNodeWithArgsTransform : 0;

function _createVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn("Invalid vnode type when creating vnode: ".concat(type, "."));
    }

    type = Comment;
  }

  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    var cloned = cloneVNode(type, props, true
    /* mergeRef: true */
    );

    if (children) {
      normalizeChildren(cloned, children);
    }

    return cloned;
  } // class component normalization.


  if (isClassComponent(type)) {
    type = type.__vccOpts;
  } // class & style normalization.


  if (props) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    props = guardReactiveProps(props);
    var _props = props,
        klass = _props["class"],
        style = _props.style;

    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props["class"] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      // reactive state objects need to be cloned since they are likely to be
      // mutated
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }

      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  } // encode the vnode type information into a bitmap


  var shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1
  /* ELEMENT */
  : isSuspense(type) ? 128
  /* SUSPENSE */
  : isTeleport(type) ? 64
  /* TELEPORT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4
  /* STATEFUL_COMPONENT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2
  /* FUNCTIONAL_COMPONENT */
  : 0;

  if ( true && shapeFlag & 4
  /* STATEFUL_COMPONENT */
  && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn("Vue received a Component which was made a reactive object. This can " + "lead to unnecessary performance overhead, and should be avoided by " + "marking the component with `markRaw` or using `shallowRef` " + "instead of `ref`.", "\nComponent that was made reactive: ", type);
  }

  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}

function guardReactiveProps(props) {
  if (!props) return null;
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props) : props;
}

function cloneVNode(vnode, extraProps) {
  var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // This is intentionally NOT using spread or extend to avoid the runtime
  // key enumeration cost.
  var props = vnode.props,
      ref = vnode.ref,
      patchFlag = vnode.patchFlag,
      children = vnode.children;
  var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  var cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1
    /* HOISTED */
    && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
    ? 16
    /* FULL_PROPS */
    : patchFlag | 16
    /* FULL_PROPS */
    : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */


function deepCloneVNode(vnode) {
  var cloned = cloneVNode(vnode);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }

  return cloned;
}
/**
 * @private
 */


function createTextVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
  var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return createVNode(Text, null, text, flag);
}
/**
 * @private
 */


function createStaticVNode(content, numberOfNodes) {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  var vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
/**
 * @private
 */


function createCommentVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}

function normalizeVNode(child) {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (_typeof(child) === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child));
  }
} // optimized normalization for template-compiled render fns


function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}

function normalizeChildren(vnode, children) {
  var type = 0;
  var shapeFlag = vnode.shapeFlag;

  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16
    /* ARRAY_CHILDREN */
    ;
  } else if (_typeof(children) === 'object') {
    if (shapeFlag & (1
    /* ELEMENT */
    | 64
    /* TELEPORT */
    )) {
      // Normalize slot to plain children for plain element and Teleport
      var slot = children["default"];

      if (slot) {
        // _c marker is added by withCtx() indicating this is a compiled slot
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }

      return;
    } else {
      type = 32
      /* SLOTS_CHILDREN */
      ;
      var slotFlag = children._;

      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3
      /* FORWARDED */
      && currentRenderingInstance) {
        // a child component receives forwarded slots from the parent.
        // its slot type is determined by its parent's slot type.
        if (currentRenderingInstance.slots._ === 1
        /* STABLE */
        ) {
          children._ = 1
          /* STABLE */
          ;
        } else {
          children._ = 2
          /* DYNAMIC */
          ;
          vnode.patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = {
      "default": children,
      _ctx: currentRenderingInstance
    };
    type = 32
    /* SLOTS_CHILDREN */
    ;
  } else {
    children = String(children); // force teleport children to array so it can be moved around

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
      type = 16
      /* ARRAY_CHILDREN */
      ;
      children = [createTextVNode(children)];
    } else {
      type = 8
      /* TEXT_CHILDREN */
      ;
    }
  }

  vnode.children = children;
  vnode.shapeFlag |= type;
}

function mergeProps() {
  var ret = {};

  for (var i = 0; i < arguments.length; i++) {
    var toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];

    for (var key in toMerge) {
      if (key === 'class') {
        if (ret["class"] !== toMerge["class"]) {
          ret["class"] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret["class"], toMerge["class"]]);
        }
      } else if (key === 'style') {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        var existing = ret[key];
        var incoming = toMerge[key];

        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== '') {
        ret[key] = toMerge[key];
      }
    }
  }

  return ret;
}

function invokeVNodeHook(hook, instance, vnode) {
  var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  callWithAsyncErrorHandling(hook, instance, 7
  /* VNODE_HOOK */
  , [vnode, prevVNode]);
}
/**
 * Actual implementation
 */


function renderList(source, renderItem, cache, index) {
  var ret;
  var cached = cache && cache[index];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    ret = new Array(source.length);

    for (var i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
    }
  } else if (typeof source === 'number') {
    if ( true && !Number.isInteger(source)) {
      warn("The v-for range expect an integer value but got ".concat(source, "."));
      return [];
    }

    ret = new Array(source);

    for (var _i3 = 0; _i3 < source; _i3++) {
      ret[_i3] = renderItem(_i3 + 1, _i3, undefined, cached && cached[_i3]);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, function (item, i) {
        return renderItem(item, i, undefined, cached && cached[i]);
      });
    } else {
      var keys = Object.keys(source);
      ret = new Array(keys.length);

      for (var _i4 = 0, _l = keys.length; _i4 < _l; _i4++) {
        var key = keys[_i4];
        ret[_i4] = renderItem(source[key], key, _i4, cached && cached[_i4]);
      }
    }
  } else {
    ret = [];
  }

  if (cache) {
    cache[index] = ret;
  }

  return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */


function createSlots(slots, dynamicSlots) {
  for (var i = 0; i < dynamicSlots.length; i++) {
    var slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for="..." #[...]>

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (var j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn;
    }
  }

  return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */


function renderSlot(slots, name) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback = arguments.length > 3 ? arguments[3] : undefined;
  var noSlotted = arguments.length > 4 ? arguments[4] : undefined;

  if (currentRenderingInstance.isCE) {
    return createVNode('slot', name === 'default' ? null : {
      name: name
    }, fallback && fallback());
  }

  var slot = slots[name];

  if ( true && slot && slot.length > 1) {
    warn("SSR-optimized slot function detected in a non-SSR-optimized render " + "function. You need to mark this component with $dynamic-slots in the " + "parent template.");

    slot = function slot() {
      return [];
    };
  } // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.


  if (slot && slot._c) {
    slot._d = false;
  }

  openBlock();
  var validSlotContent = slot && ensureValidVNode(slot(props));
  var rendered = createBlock(Fragment, {
    key: props.key || "_".concat(name)
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1
  /* STABLE */
  ? 64
  /* STABLE_FRAGMENT */
  : -2
  /* BAIL */
  );

  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s'];
  }

  if (slot && slot._c) {
    slot._d = true;
  }

  return rendered;
}

function ensureValidVNode(vnodes) {
  return vnodes.some(function (child) {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */


function toHandlers(obj) {
  var ret = {};

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn("v-on with no argument expects an object value.");
    return ret;
  }

  for (var key in obj) {
    ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }

  return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */


var getPublicInstance = function getPublicInstance(i) {
  if (!i) return null;
  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};

var publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
  $: function $(i) {
    return i;
  },
  $el: function $el(i) {
    return i.vnode.el;
  },
  $data: function $data(i) {
    return i.data;
  },
  $props: function $props(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0;
  },
  $attrs: function $attrs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0;
  },
  $slots: function $slots(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0;
  },
  $refs: function $refs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0;
  },
  $parent: function $parent(i) {
    return getPublicInstance(i.parent);
  },
  $root: function $root(i) {
    return getPublicInstance(i.root);
  },
  $emit: function $emit(i) {
    return i.emit;
  },
  $options: function $options(i) {
    return  true ? resolveMergedOptions(i) : 0;
  },
  $forceUpdate: function $forceUpdate(i) {
    return function () {
      return queueJob(i.update);
    };
  },
  $nextTick: function $nextTick(i) {
    return nextTick.bind(i.proxy);
  },
  $watch: function $watch(i) {
    return  true ? instanceWatch.bind(i) : 0;
  }
});
var PublicInstanceProxyHandlers = {
  get: function get(_ref21, key) {
    var instance = _ref21._;
    var ctx = instance.ctx,
        setupState = instance.setupState,
        data = instance.data,
        props = instance.props,
        accessCache = instance.accessCache,
        type = instance.type,
        appContext = instance.appContext; // for internal formatters to know that this is a Vue instance

    if ( true && key === '__isVue') {
      return true;
    } // prioritize <script setup> bindings during dev.
    // this allows even properties that start with _ or $ to be used - so that
    // it aligns with the production behavior where the render fn is inlined and
    // indeed has access to all declared variables.


    if ( true && setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      return setupState[key];
    } // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.


    var normalizedProps;

    if (key[0] !== '$') {
      var n = accessCache[key];

      if (n !== undefined) {
        switch (n) {
          case 1
          /* SETUP */
          :
            return setupState[key];

          case 2
          /* DATA */
          :
            return data[key];

          case 4
          /* CONTEXT */
          :
            return ctx[key];

          case 3
          /* PROPS */
          :
            return props[key];
          // default: just fallthrough
        }
      } else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
        accessCache[key] = 1
        /* SETUP */
        ;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 2
        /* DATA */
        ;
        return data[key];
      } else if ( // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
        accessCache[key] = 3
        /* PROPS */
        ;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 4
        /* CONTEXT */
        ;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 0
        /* OTHER */
        ;
      }
    }

    var publicGetter = publicPropertiesMap[key];
    var cssModule, globalProperties; // public $xxx properties

    if (publicGetter) {
      if (key === '$attrs') {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get"
        /* GET */
        , key);
         true && markAttrsAccessed();
      }

      return publicGetter(instance);
    } else if ( // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      // user may set custom properties to `this` that start with `$`
      accessCache[key] = 4
      /* CONTEXT */
      ;
      return ctx[key];
    } else if ( // global properties
    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf('__v') !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn("Property ".concat(JSON.stringify(key), " must be accessed via $data because it starts with a reserved ") + "character (\"$\" or \"_\") and is not proxied on the render context.");
      } else if (instance === currentRenderingInstance) {
        warn("Property ".concat(JSON.stringify(key), " was accessed during render ") + "but is not defined on instance.");
      }
    }
  },
  set: function set(_ref22, key, value) {
    var instance = _ref22._;
    var data = instance.data,
        setupState = instance.setupState,
        ctx = instance.ctx;

    if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn("Attempting to mutate prop \"".concat(key, "\". Props are readonly."), instance);
      return false;
    }

    if (key[0] === '$' && key.slice(1) in instance) {
       true && warn("Attempting to mutate public property \"".concat(key, "\". ") + "Properties starting with $ are reserved and readonly.", instance);
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value
        });
      } else {
        ctx[key] = value;
      }
    }

    return true;
  },
  has: function has(_ref23, key) {
    var _ref23$_ = _ref23._,
        data = _ref23$_.data,
        setupState = _ref23$_.setupState,
        accessCache = _ref23$_.accessCache,
        ctx = _ref23$_.ctx,
        appContext = _ref23$_.appContext,
        propsOptions = _ref23$_.propsOptions;
    var normalizedProps;
    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  },
  defineProperty: function defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      this.set(target, key, descriptor.get(), null);
    } else if (descriptor.value != null) {
      this.set(target, key, descriptor.value, null);
    }

    return Reflect.defineProperty(target, key, descriptor);
  }
};

if (true) {
  PublicInstanceProxyHandlers.ownKeys = function (target) {
    warn("Avoid app logic that relies on enumerating keys on a component instance. " + "The keys will be empty in production mode to avoid performance overhead.");
    return Reflect.ownKeys(target);
  };
}

var RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get: function get(target, key) {
    // fast path for unscopables when using `with` block
    if (key === Symbol.unscopables) {
      return;
    }

    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has: function has(_, key) {
    var has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);

    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn("Property ".concat(JSON.stringify(key), " should not start with _ which is a reserved prefix for Vue internals."));
    }

    return has;
  }
}); // dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.

function createDevRenderContext(instance) {
  var target = {}; // expose internal instance for proxy handlers

  Object.defineProperty(target, "_", {
    configurable: true,
    enumerable: false,
    get: function get() {
      return instance;
    }
  }); // expose public properties

  Object.keys(publicPropertiesMap).forEach(function (key) {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: function get() {
        return publicPropertiesMap[key](instance);
      },
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
} // dev only


function exposePropsOnRenderContext(instance) {
  var ctx = instance.ctx,
      _instance$propsOption6 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption6[0];

  if (propsOptions) {
    Object.keys(propsOptions).forEach(function (key) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return instance.props[key];
        },
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
} // dev only


function exposeSetupStateOnRenderContext(instance) {
  var ctx = instance.ctx,
      setupState = instance.setupState;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(function (key) {
    if (!setupState.__isScriptSetup) {
      if (key[0] === '$' || key[0] === '_') {
        warn("setup() return property ".concat(JSON.stringify(key), " should not start with \"$\" or \"_\" ") + "which are reserved prefixes for Vue internals.");
        return;
      }

      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return setupState[key];
        },
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    }
  });
}

var emptyAppContext = createAppContext();
var uid$1 = 0;

function createComponentInstance(vnode, parent, suspense) {
  var type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode

  var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  var instance = {
    uid: uid$1++,
    vnode: vnode,
    type: type,
    parent: parent,
    appContext: appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true
    /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense: suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };

  if (true) {
    instance.ctx = createDevRenderContext(instance);
  } else {}

  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance); // apply custom element special handling

  if (vnode.ce) {
    vnode.ce(instance);
  }

  return instance;
}

var currentInstance = null;

var getCurrentInstance = function getCurrentInstance() {
  return currentInstance || currentRenderingInstance;
};

var setCurrentInstance = function setCurrentInstance(instance) {
  currentInstance = instance;
  instance.scope.on();
};

var unsetCurrentInstance = function unsetCurrentInstance() {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};

var isBuiltInTag = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');

function validateComponentName(name, config) {
  var appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;

  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component id: ' + name);
  }
}

function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ;
}

var isInSSRComponentSetup = false;

function setupComponent(instance) {
  var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  isInSSRComponentSetup = isSSR;
  var _instance$vnode = instance.vnode,
      props = _instance$vnode.props,
      children = _instance$vnode.children;
  var isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}

function setupStatefulComponent(instance, isSSR) {
  var Component = instance.type;

  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }

    if (Component.components) {
      var names = Object.keys(Component.components);

      for (var i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }

    if (Component.directives) {
      var _names = Object.keys(Component.directives);

      for (var _i5 = 0; _i5 < _names.length; _i5++) {
        validateDirectiveName(_names[_i5]);
      }
    }

    if (Component.compilerOptions && isRuntimeOnly()) {
      warn("\"compilerOptions\" is only supported when using a build of Vue that " + "includes the runtime compiler. Since you are using a runtime-only " + "build, the options should be passed via your build tool config instead.");
    }
  } // 0. create render proxy property access cache


  instance.accessCache = Object.create(null); // 1. create public instance / render proxy
  // also mark it raw so it's never observed

  instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));

  if (true) {
    exposePropsOnRenderContext(instance);
  } // 2. call setup()


  var setup = Component.setup;

  if (setup) {
    var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    var setupResult = callWithErrorHandling(setup, instance, 0
    /* SETUP_FUNCTION */
    , [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    unsetCurrentInstance();

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);

      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then(function (resolvedResult) {
          handleSetupResult(instance, resolvedResult, isSSR);
        })["catch"](function (e) {
          handleError(e, instance, 0
          /* SETUP_FUNCTION */
          );
        });
      } else {
        // async setup returned Promise.
        // bail here and wait for re-entry.
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}

function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    // setup returned an inline render function
    if (instance.type.__ssrInlineRender) {
      // when the function's name is `ssrRender` (compiled by SFC inline mode),
      // set it as ssrRender instead.
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn("setup() should not return VNodes directly - " + "return a render function instead.");
    } // setup returned bindings.
    // assuming a render function compiled from template is present.


    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }

    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);

    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== undefined) {
    warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : _typeof(setupResult)));
  }

  finishComponentSetup(instance, isSSR);
}

var compile;
var installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */

function registerRuntimeCompiler(_compile) {
  compile = _compile;

  installWithProxy = function installWithProxy(i) {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
} // dev only


var isRuntimeOnly = function isRuntimeOnly() {
  return !compile;
};

function finishComponentSetup(instance, isSSR, skipOptions) {
  var Component = instance.type; // template / render function normalization
  // could be already set when returned from setup()

  if (!instance.render) {
    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
    // is done by server-renderer
    if (!isSSR && compile && !Component.render) {
      var template = Component.template;

      if (template) {
        if (true) {
          startMeasure(instance, "compile");
        }

        var _instance$appContext$ = instance.appContext.config,
            isCustomElement = _instance$appContext$.isCustomElement,
            compilerOptions = _instance$appContext$.compilerOptions;
        var delimiters = Component.delimiters,
            componentCompilerOptions = Component.compilerOptions;
        var finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
          isCustomElement: isCustomElement,
          delimiters: delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);

        if (true) {
          endMeasure(instance, "compile");
        }
      }
    }

    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP; // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.

    if (installWithProxy) {
      installWithProxy(instance);
    }
  } // support for 2.x options


  if (true) {
    setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    applyOptions(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    unsetCurrentInstance();
  } // warn missing template/render
  // the runtime compilation of template in SSR is done by server-render


  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    /* istanbul ignore if */
    if (!compile && Component.template) {
      warn("Component provided template option but " + "runtime compilation is not supported in this build of Vue." + " Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\"."
      /* should not happen */
      );
    } else {
      warn("Component is missing template or render function.");
    }
  }
}

function createAttrsProxy(instance) {
  return new Proxy(instance.attrs,  true ? {
    get: function get(target, key) {
      markAttrsAccessed();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get"
      /* GET */
      , '$attrs');
      return target[key];
    },
    set: function set() {
      warn("setupContext.attrs is readonly.");
      return false;
    },
    deleteProperty: function deleteProperty() {
      warn("setupContext.attrs is readonly.");
      return false;
    }
  } : 0);
}

function createSetupContext(instance) {
  var expose = function expose(exposed) {
    if ( true && instance.exposed) {
      warn("expose() should be called only once per setup().");
    }

    instance.exposed = exposed || {};
  };

  var attrs;

  if (true) {
    // We use getters in dev in case libs like test-utils overwrite instance
    // properties (overwrites should not be done in prod)
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },

      get slots() {
        return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
      },

      get emit() {
        return function (event) {
          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key16 = 1; _key16 < _len8; _key16++) {
            args[_key16 - 1] = arguments[_key16];
          }

          return instance.emit.apply(instance, [event].concat(args));
        };
      },

      expose: expose
    });
  } else {}
}

function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
      get: function get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}

var classifyRE = /(?:^|[-_])(\w)/g;

var classify = function classify(str) {
  return str.replace(classifyRE, function (c) {
    return c.toUpperCase();
  }).replace(/[-_]/g, '');
};

function getComponentName(Component) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */


function formatComponentName(instance, Component) {
  var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var name = getComponentName(Component);

  if (!name && Component.__file) {
    var match = Component.__file.match(/([^/\\]+)\.\w+$/);

    if (match) {
      name = match[1];
    }
  }

  if (!name && instance && instance.parent) {
    // try to infer the name based on reverse resolution
    var inferFromRegistry = function inferFromRegistry(registry) {
      for (var key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };

    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }

  return name ? classify(name) : isRoot ? "App" : "Anonymous";
}

function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

var computed = function computed(getterOrOptions, debugOptions) {
  // @ts-ignore
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
}; // dev only


var warnRuntimeUsage = function warnRuntimeUsage(method) {
  return warn("".concat(method, "() is a compiler-hint helper that is only usable inside ") + "<script setup> of a single file component. Its arguments should be " + "compiled away and passing it at runtime has no effect.");
}; // implementation


function defineProps() {
  if (true) {
    warnRuntimeUsage("defineProps");
  }

  return null;
} // implementation


function defineEmits() {
  if (true) {
    warnRuntimeUsage("defineEmits");
  }

  return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */


function defineExpose(exposed) {
  if (true) {
    warnRuntimeUsage("defineExpose");
  }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */


function withDefaults(props, defaults) {
  if (true) {
    warnRuntimeUsage("withDefaults");
  }

  return null;
}

function useSlots() {
  return getContext().slots;
}

function useAttrs() {
  return getContext().attrs;
}

function getContext() {
  var i = getCurrentInstance();

  if ( true && !i) {
    warn("useContext() called without active instance.");
  }

  return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */


function mergeDefaults(raw, defaults) {
  var props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw) ? raw.reduce(function (normalized, p) {
    return normalized[p] = {}, normalized;
  }, {}) : raw;

  for (var key in defaults) {
    var opt = props[key];

    if (opt) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
        props[key] = {
          type: opt,
          "default": defaults[key]
        };
      } else {
        opt["default"] = defaults[key];
      }
    } else if (opt === null) {
      props[key] = {
        "default": defaults[key]
      };
    } else if (true) {
      warn("props default key \"".concat(key, "\" has no corresponding declaration."));
    }
  }

  return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */


function createPropsRestProxy(props, excludedKeys) {
  var ret = {};

  var _loop4 = function _loop4(key) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: function get() {
          return props[key];
        }
      });
    }
  };

  for (var key in props) {
    _loop4(key);
  }

  return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */


function withAsyncContext(getAwaitable) {
  var ctx = getCurrentInstance();

  if ( true && !ctx) {
    warn("withAsyncContext called without active current instance. " + "This is likely a bug.");
  }

  var awaitable = getAwaitable();
  unsetCurrentInstance();

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
    awaitable = awaitable["catch"](function (e) {
      setCurrentInstance(ctx);
      throw e;
    });
  }

  return [awaitable, function () {
    return setCurrentInstance(ctx);
  }];
} // Actual implementation


function h(type, propsOrChildren, children) {
  var l = arguments.length;

  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      // single vnode without props
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      } // props without children


      return createVNode(type, propsOrChildren);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }

    return createVNode(type, propsOrChildren, children);
  }
}

var ssrContextKey = Symbol( true ? "ssrContext" : 0);

var useSSRContext = function useSSRContext() {
  {
    var ctx = inject(ssrContextKey);

    if (!ctx) {
      warn("Server rendering context not provided. Make sure to only call " + "useSSRContext() conditionally in the server build.");
    }

    return ctx;
  }
};

function isShallow(value) {
  return !!(value && value["__v_isShallow"
  /* IS_SHALLOW */
  ]);
}

function initCustomFormatter() {
  /* eslint-disable no-restricted-globals */
  if ( false || typeof window === 'undefined') {
    return;
  }

  var vueStyle = {
    style: 'color:#3ba776'
  };
  var numberStyle = {
    style: 'color:#0b1bc9'
  };
  var stringStyle = {
    style: 'color:#b62e24'
  };
  var keywordStyle = {
    style: 'color:#9d288c'
  }; // custom formatter for Chrome
  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html

  var formatter = {
    header: function header(obj) {
      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }

      if (obj.__isVue) {
        return ['div', vueStyle, "VueInstance"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), ">"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'], '<', formatValue(obj), ">".concat((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? " (readonly)" : "")];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'], '<', formatValue(obj), '>'];
      }

      return null;
    },
    hasBody: function hasBody(obj) {
      return obj && obj.__isVue;
    },
    body: function body(obj) {
      if (obj && obj.__isVue) {
        return ['div', {}].concat(_toConsumableArray(formatInstance(obj.$)));
      }
    }
  };

  function formatInstance(instance) {
    var blocks = [];

    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }

    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('setup', instance.setupState));
    }

    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }

    var computed = extractKeys(instance, 'computed');

    if (computed) {
      blocks.push(createInstanceBlock('computed', computed));
    }

    var injected = extractKeys(instance, 'inject');

    if (injected) {
      blocks.push(createInstanceBlock('injected', injected));
    }

    blocks.push(['div', {}, ['span', {
      style: keywordStyle.style + ';opacity:0.66'
    }, '$ (internal): '], ['object', {
      object: instance
    }]]);
    return blocks;
  }

  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);

    if (!Object.keys(target).length) {
      return ['span', {}];
    }

    return ['div', {
      style: 'line-height:1.25em;margin-bottom:0.6em'
    }, ['div', {
      style: 'color:#476582'
    }, type], ['div', {
      style: 'padding-left:1.25em'
    }].concat(_toConsumableArray(Object.keys(target).map(function (key) {
      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];
    })))];
  }

  function formatValue(v) {
    var asRaw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (typeof v === 'number') {
      return ['span', numberStyle, v];
    } else if (typeof v === 'string') {
      return ['span', stringStyle, JSON.stringify(v)];
    } else if (typeof v === 'boolean') {
      return ['span', keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ['object', {
        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v
      }];
    } else {
      return ['span', stringStyle, String(v)];
    }
  }

  function extractKeys(instance, type) {
    var Comp = instance.type;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }

    var extracted = {};

    for (var key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }

    return extracted;
  }

  function isKeyOfType(Comp, key, type) {
    var opts = Comp[type];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }

    if (Comp["extends"] && isKeyOfType(Comp["extends"], key, type)) {
      return true;
    }

    if (Comp.mixins && Comp.mixins.some(function (m) {
      return isKeyOfType(m, key, type);
    })) {
      return true;
    }
  }

  function genRefFlag(v) {
    if (isShallow(v)) {
      return "ShallowRef";
    }

    if (v.effect) {
      return "ComputedRef";
    }

    return "Ref";
  }

  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}

function withMemo(memo, render, cache, index) {
  var cached = cache[index];

  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }

  var ret = render(); // shallow clone

  ret.memo = memo.slice();
  return cache[index] = ret;
}

function isMemoSame(cached, memo) {
  var prev = cached.memo;

  if (prev.length != memo.length) {
    return false;
  }

  for (var i = 0; i < prev.length; i++) {
    if (prev[i] !== memo[i]) {
      return false;
    }
  } // make sure to let parent block track it when returning cached


  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }

  return true;
} // Core API ------------------------------------------------------------------


var version = "3.2.31";
var _ssrUtils = {
  createComponentInstance: createComponentInstance,
  setupComponent: setupComponent,
  renderComponentRoot: renderComponentRoot,
  setCurrentRenderingInstance: setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode: normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */

var ssrUtils = _ssrUtils;
/**
 * @internal only exposed in compat builds
 */

var resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */

var compatUtils = null;


/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "VueElement": () => (/* binding */ VueElement),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "defineSSRCustomElement": () => (/* binding */ defineSSRCustomElement),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "initDirectivesForSSR": () => (/* binding */ initDirectivesForSSR),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var svgNS = 'http://www.w3.org/2000/svg';
var doc = typeof document !== 'undefined' ? document : null;
var templateContainer = doc && doc.createElement('template');
var nodeOps = {
  insert: function insert(child, parent, anchor) {
    parent.insertBefore(child, anchor || null);
  },
  remove: function remove(child) {
    var parent = child.parentNode;

    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: function createElement(tag, isSVG, is, props) {
    var el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is: is
    } : undefined);

    if (tag === 'select' && props && props.multiple != null) {
      el.setAttribute('multiple', props.multiple);
    }

    return el;
  },
  createText: function createText(text) {
    return doc.createTextNode(text);
  },
  createComment: function createComment(text) {
    return doc.createComment(text);
  },
  setText: function setText(node, text) {
    node.nodeValue = text;
  },
  setElementText: function setElementText(el, text) {
    el.textContent = text;
  },
  parentNode: function parentNode(node) {
    return node.parentNode;
  },
  nextSibling: function nextSibling(node) {
    return node.nextSibling;
  },
  querySelector: function querySelector(selector) {
    return doc.querySelector(selector);
  },
  setScopeId: function setScopeId(el, id) {
    el.setAttribute(id, '');
  },
  cloneNode: function cloneNode(el) {
    var cloned = el.cloneNode(true); // #3072
    // - in `patchDOMProp`, we store the actual value in the `el._value` property.
    // - normally, elements using `:value` bindings will not be hoisted, but if
    //   the bound value is a constant, e.g. `:value="true"` - they do get
    //   hoisted.
    // - in production, hoisted nodes are cloned when subsequent inserts, but
    //   cloneNode() does not copy the custom property we attached.
    // - This may need to account for other custom DOM properties we attach to
    //   elements in addition to `_value` in the future.

    if ("_value" in el) {
      cloned._value = el._value;
    }

    return cloned;
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent: function insertStaticContent(content, parent, anchor, isSVG, start, end) {
    // <parent> before | first ... last | anchor </parent>
    var before = anchor ? anchor.previousSibling : parent.lastChild; // #5308 can only take cached path if:
    // - has a single root node
    // - nextSibling info is still available

    if (start && (start === end || start.nextSibling)) {
      // cached
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      // fresh insert
      templateContainer.innerHTML = isSVG ? "<svg>".concat(content, "</svg>") : content;
      var template = templateContainer.content;

      if (isSVG) {
        // remove outer svg wrapper
        var wrapper = template.firstChild;

        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }

        template.removeChild(wrapper);
      }

      parent.insertBefore(template, anchor);
    }

    return [// first
    before ? before.nextSibling : parent.firstChild, // last
    anchor ? anchor.previousSibling : parent.lastChild];
  }
}; // compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]

function patchClass(el, value, isSVG) {
  // directly setting className should be faster than setAttribute in theory
  // if this is an element during a transition, take the temporary transition
  // classes into account.
  var transitionClasses = el._vtc;

  if (transitionClasses) {
    value = (value ? [value].concat(_toConsumableArray(transitionClasses)) : _toConsumableArray(transitionClasses)).join(' ');
  }

  if (value == null) {
    el.removeAttribute('class');
  } else if (isSVG) {
    el.setAttribute('class', value);
  } else {
    el.className = value;
  }
}

function patchStyle(el, prev, next) {
  var style = el.style;
  var isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);

  if (next && !isCssString) {
    for (var key in next) {
      setStyle(style, key, next[key]);
    }

    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
      for (var _key in prev) {
        if (next[_key] == null) {
          setStyle(style, _key, '');
        }
      }
    }
  } else {
    var currentDisplay = style.display;

    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute('style');
    } // indicates that the `display` of the element is controlled by `v-show`,
    // so we always keep the current `display` value regardless of the `style`
    // value, thus handing over control to `v-show`.


    if ('_vod' in el) {
      style.display = currentDisplay;
    }
  }
}

var importantRE = /\s*!important$/;

function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach(function (v) {
      return setStyle(style, name, v);
    });
  } else {
    if (name.startsWith('--')) {
      // custom property definition
      style.setProperty(name, val);
    } else {
      var prefixed = autoPrefix(style, name);

      if (importantRE.test(val)) {
        // !important
        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
      } else {
        style[prefixed] = val;
      }
    }
  }
}

var prefixes = ['Webkit', 'Moz', 'ms'];
var prefixCache = {};

function autoPrefix(style, rawName) {
  var cached = prefixCache[rawName];

  if (cached) {
    return cached;
  }

  var name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);

  if (name !== 'filter' && name in style) {
    return prefixCache[rawName] = name;
  }

  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);

  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + name;

    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }

  return rawName;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';

function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith('xlink:')) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    // note we are only checking boolean attributes that don't have a
    // corresponding dom prop of the same name here.
    var isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);

    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? '' : value);
    }
  }
} // __UNSAFE__
// functions. The user is responsible for using them with only trusted content.


function patchDOMProp(el, key, value, // the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === 'innerHTML' || key === 'textContent') {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }

    el[key] = value == null ? '' : value;
    return;
  }

  if (key === 'value' && el.tagName !== 'PROGRESS' && // custom elements may use _value internally
  !el.tagName.includes('-')) {
    // store value as _value as well since
    // non-string values will be stringified.
    el._value = value;
    var newValue = value == null ? '' : value;

    if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    el.tagName === 'OPTION') {
      el.value = newValue;
    }

    if (value == null) {
      el.removeAttribute(key);
    }

    return;
  }

  if (value === '' || value == null) {
    var type = _typeof(el[key]);

    if (type === 'boolean') {
      // e.g. <select multiple> compiles to { multiple: '' }
      el[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
      return;
    } else if (value == null && type === 'string') {
      // e.g. <div :id="null">
      el[key] = '';
      el.removeAttribute(key);
      return;
    } else if (type === 'number') {
      // e.g. <img :width="null">
      // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
      try {
        el[key] = 0;
      } catch (_a) {}

      el.removeAttribute(key);
      return;
    }
  } // some properties perform value validation and throw


  try {
    el[key] = value;
  } catch (e) {
    if (true) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed setting prop \"".concat(key, "\" on <").concat(el.tagName.toLowerCase(), ">: ") + "value ".concat(value, " is invalid."), e);
    }
  }
} // Async edge case fix requires storing an event listener's attach timestamp.


var _getNow = Date.now;
var skipTimestampCheck = false;

if (typeof window !== 'undefined') {
  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (_getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = function _getNow() {
      return performance.now();
    };
  } // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
  // and does not fire microtasks in between event propagation, so safe to exclude.


  var ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
} // To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.


var cachedNow = 0;
var p = Promise.resolve();

var reset = function reset() {
  cachedNow = 0;
};

var getNow = function getNow() {
  return cachedNow || (p.then(reset), cachedNow = _getNow());
};

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}

function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}

function patchEvent(el, rawName, prevValue, nextValue) {
  var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  // vei = vue event invokers
  var invokers = el._vei || (el._vei = {});
  var existingInvoker = invokers[rawName];

  if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue;
  } else {
    var _parseName = parseName(rawName),
        _parseName2 = _slicedToArray(_parseName, 2),
        name = _parseName2[0],
        options = _parseName2[1];

    if (nextValue) {
      // add
      var invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      // remove
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = undefined;
    }
  }
}

var optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(name) {
  var options;

  if (optionsModifierRE.test(name)) {
    options = {};
    var m;

    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }

  return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}

function createInvoker(initialValue, instance) {
  var invoker = function invoker(e) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    var timeStamp = e.timeStamp || _getNow();

    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5
      /* NATIVE_EVENT_HANDLER */
      , [e]);
    }
  };

  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}

function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    var originalStop = e.stopImmediatePropagation;

    e.stopImmediatePropagation = function () {
      originalStop.call(e);
      e._stopped = true;
    };

    return value.map(function (fn) {
      return function (e) {
        return !e._stopped && fn && fn(e);
      };
    });
  } else {
    return value;
  }
}

var nativeOnRE = /^on[a-z]/;

var patchProp = function patchProp(el, key, prevValue, nextValue) {
  var isSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prevChildren = arguments.length > 5 ? arguments[5] : undefined;
  var parentComponent = arguments.length > 6 ? arguments[6] : undefined;
  var parentSuspense = arguments.length > 7 ? arguments[7] : undefined;
  var unmountChildren = arguments.length > 8 ? arguments[8] : undefined;

  if (key === 'class') {
    patchClass(el, nextValue, isSVG);
  } else if (key === 'style') {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    // ignore v-model listeners
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === '.' ? (key = key.slice(1), true) : key[0] === '^' ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    // special case for <input v-model type="checkbox"> with
    // :true-value & :false-value
    // store value as dom properties since non-string values will be
    // stringified.
    if (key === 'true-value') {
      el._trueValue = nextValue;
    } else if (key === 'false-value') {
      el._falseValue = nextValue;
    }

    patchAttr(el, key, nextValue, isSVG);
  }
};

function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    // most keys must be set as attribute on svg elements to work
    // ...except innerHTML & textContent
    if (key === 'innerHTML' || key === 'textContent') {
      return true;
    } // or native onclick with function values


    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }

    return false;
  } // spellcheck and draggable are numerated attrs, however their
  // corresponding DOM properties are actually booleans - this leads to
  // setting it with a string "false" value leading it to be coerced to
  // `true`, so we need to always treat them as attributes.
  // Note that `contentEditable` doesn't have this problem: its DOM
  // property is also enumerated string values.


  if (key === 'spellcheck' || key === 'draggable') {
    return false;
  } // #1787, #2840 form property on form elements is readonly and must be set as
  // attribute.


  if (key === 'form') {
    return false;
  } // #1526 <input list> must be set as attribute


  if (key === 'list' && el.tagName === 'INPUT') {
    return false;
  } // #2766 <textarea type> must be set as attribute


  if (key === 'type' && el.tagName === 'TEXTAREA') {
    return false;
  } // native onclick with string value, must be set as attribute


  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }

  return key in el;
}

function defineCustomElement(options, hydate) {
  var Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);

  var VueCustomElement = /*#__PURE__*/function (_VueElement) {
    _inherits(VueCustomElement, _VueElement);

    var _super = _createSuper(VueCustomElement);

    function VueCustomElement(initialProps) {
      _classCallCheck(this, VueCustomElement);

      return _super.call(this, Comp, initialProps, hydate);
    }

    return _createClass(VueCustomElement);
  }(VueElement);

  VueCustomElement.def = Comp;
  return VueCustomElement;
}

var defineSSRCustomElement = function defineSSRCustomElement(options) {
  // @ts-ignore
  return defineCustomElement(options, hydrate);
};

var BaseClass = typeof HTMLElement !== 'undefined' ? HTMLElement : /*#__PURE__*/function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  return _createClass(_class);
}();

var VueElement = /*#__PURE__*/function (_BaseClass) {
  _inherits(VueElement, _BaseClass);

  var _super2 = _createSuper(VueElement);

  function VueElement(_def) {
    var _this;

    var _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var hydrate = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, VueElement);

    _this = _super2.call(this);
    _this._def = _def;
    _this._props = _props;
    /**
     * @internal
     */

    _this._instance = null;
    _this._connected = false;
    _this._resolved = false;
    _this._numberProps = null;

    if (_this.shadowRoot && hydrate) {
      hydrate(_this._createVNode(), _this.shadowRoot);
    } else {
      if ( true && _this.shadowRoot) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Custom element has pre-rendered declarative shadow root but is not " + "defined as hydratable. Use `defineSSRCustomElement`.");
      }

      _this.attachShadow({
        mode: 'open'
      });
    }

    return _this;
  }

  _createClass(VueElement, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      this._connected = true;

      if (!this._instance) {
        this._resolveDef();
      }
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      var _this2 = this;

      this._connected = false;
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(function () {
        if (!_this2._connected) {
          render(null, _this2.shadowRoot);
          _this2._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */

  }, {
    key: "_resolveDef",
    value: function _resolveDef() {
      var _this3 = this;

      if (this._resolved) {
        return;
      }

      this._resolved = true; // set initial attrs

      for (var i = 0; i < this.attributes.length; i++) {
        this._setAttr(this.attributes[i].name);
      } // watch future attr changes


      new MutationObserver(function (mutations) {
        var _iterator = _createForOfIteratorHelper(mutations),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var m = _step.value;

            _this3._setAttr(m.attributeName);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }).observe(this, {
        attributes: true
      });

      var resolve = function resolve(def) {
        var props = def.props,
            styles = def.styles;
        var hasOptions = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);
        var rawKeys = props ? hasOptions ? Object.keys(props) : props : []; // cast Number-type props set before resolve

        var numberProps;

        if (hasOptions) {
          for (var key in _this3._props) {
            var opt = props[key];

            if (opt === Number || opt && opt.type === Number) {
              _this3._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(_this3._props[key]);
              (numberProps || (numberProps = Object.create(null)))[key] = true;
            }
          }
        }

        _this3._numberProps = numberProps; // check if there are props set pre-upgrade or connect

        for (var _i2 = 0, _Object$keys = Object.keys(_this3); _i2 < _Object$keys.length; _i2++) {
          var _key2 = _Object$keys[_i2];

          if (_key2[0] !== '_') {
            _this3._setProp(_key2, _this3[_key2], true, false);
          }
        } // defining getter/setters on prototype


        var _iterator2 = _createForOfIteratorHelper(rawKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)),
            _step2;

        try {
          var _loop = function _loop() {
            var key = _step2.value;
            Object.defineProperty(_this3, key, {
              get: function get() {
                return this._getProp(key);
              },
              set: function set(val) {
                this._setProp(key, val);
              }
            });
          };

          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _loop();
          } // apply CSS

        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        _this3._applyStyles(styles); // initial render


        _this3._update();
      };

      var asyncDef = this._def.__asyncLoader;

      if (asyncDef) {
        asyncDef().then(resolve);
      } else {
        resolve(this._def);
      }
    }
  }, {
    key: "_setAttr",
    value: function _setAttr(key) {
      var value = this.getAttribute(key);

      if (this._numberProps && this._numberProps[key]) {
        value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
      }

      this._setProp((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), value, false);
    }
    /**
     * @internal
     */

  }, {
    key: "_getProp",
    value: function _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */

  }, {
    key: "_setProp",
    value: function _setProp(key, val) {
      var shouldReflect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var shouldUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (val !== this._props[key]) {
        this._props[key] = val;

        if (shouldUpdate && this._instance) {
          this._update();
        } // reflect


        if (shouldReflect) {
          if (val === true) {
            this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');
          } else if (typeof val === 'string' || typeof val === 'number') {
            this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');
          } else if (!val) {
            this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
          }
        }
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      render(this._createVNode(), this.shadowRoot);
    }
  }, {
    key: "_createVNode",
    value: function _createVNode() {
      var _this4 = this;

      var vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));

      if (!this._instance) {
        vnode.ce = function (instance) {
          _this4._instance = instance;
          instance.isCE = true; // HMR

          if (true) {
            instance.ceReload = function (newStyles) {
              // always reset styles
              if (_this4._styles) {
                _this4._styles.forEach(function (s) {
                  return _this4.shadowRoot.removeChild(s);
                });

                _this4._styles.length = 0;
              }

              _this4._applyStyles(newStyles); // if this is an async component, ceReload is called from the inner
              // component so no need to reload the async wrapper


              if (!_this4._def.__asyncLoader) {
                // reload
                _this4._instance = null;

                _this4._update();
              }
            };
          } // intercept emit


          instance.emit = function (event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }

            _this4.dispatchEvent(new CustomEvent(event, {
              detail: args
            }));
          }; // locate nearest Vue custom element parent for provide/inject


          var parent = _this4;

          while (parent = parent && (parent.parentNode || parent.host)) {
            if (parent instanceof VueElement) {
              instance.parent = parent._instance;
              break;
            }
          }
        };
      }

      return vnode;
    }
  }, {
    key: "_applyStyles",
    value: function _applyStyles(styles) {
      var _this5 = this;

      if (styles) {
        styles.forEach(function (css) {
          var s = document.createElement('style');
          s.textContent = css;

          _this5.shadowRoot.appendChild(s); // record for HMR


          if (true) {
            (_this5._styles || (_this5._styles = [])).push(s);
          }
        });
      }
    }
  }]);

  return VueElement;
}(BaseClass);

function useCssModule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$style';

  /* istanbul ignore else */
  {
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();

    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssModule must be called inside setup()");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var modules = instance.type.__cssModules;

    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS modules injected.");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var mod = modules[name];

    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS module named \"".concat(name, "\"."));
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    return mod;
  }
}
/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */


function useCssVars(getter) {
  var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  /* istanbul ignore next */

  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssVars is called without current active component instance.");
    return;
  }

  var setVars = function setVars() {
    return setVarsOnVNode(instance.subTree, getter(instance.proxy));
  };

  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(function () {
    var ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, {
      childList: true
    });
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(function () {
      return ob.disconnect();
    });
  });
}

function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
    var suspense = vnode.suspense;
    vnode = suspense.activeBranch;

    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(function () {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  } // drill down HOCs until it's a non-component vnode


  while (vnode.component) {
    vnode = vnode.component.subTree;
  }

  if (vnode.shapeFlag & 1
  /* ELEMENT */
  && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach(function (c) {
      return setVarsOnVNode(c, vars);
    });
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
    var _vnode = vnode,
        el = _vnode.el,
        anchor = _vnode.anchor;

    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}

function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    var style = el.style;

    for (var key in vars) {
      style.setProperty("--".concat(key), vars[key]);
    }
  }
}

var TRANSITION = 'transition';
var ANIMATION = 'animation'; // DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.

var Transition = function Transition(props, _ref) {
  var slots = _ref.slots;
  return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
};

Transition.displayName = 'Transition';
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    "default": true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = Transition.props = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators);
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */

var callHook = function callHook(hook) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach(function (h) {
      return h.apply(void 0, _toConsumableArray(args));
    });
  } else if (hook) {
    hook.apply(void 0, _toConsumableArray(args));
  }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */


var hasExplicitCallback = function hasExplicitCallback(hook) {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some(function (h) {
    return h.length > 1;
  }) : hook.length > 1 : false;
};

function resolveTransitionProps(rawProps) {
  var baseProps = {};

  for (var key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }

  if (rawProps.css === false) {
    return baseProps;
  }

  var _rawProps$name = rawProps.name,
      name = _rawProps$name === void 0 ? 'v' : _rawProps$name,
      type = rawProps.type,
      duration = rawProps.duration,
      _rawProps$enterFromCl = rawProps.enterFromClass,
      enterFromClass = _rawProps$enterFromCl === void 0 ? "".concat(name, "-enter-from") : _rawProps$enterFromCl,
      _rawProps$enterActive = rawProps.enterActiveClass,
      enterActiveClass = _rawProps$enterActive === void 0 ? "".concat(name, "-enter-active") : _rawProps$enterActive,
      _rawProps$enterToClas = rawProps.enterToClass,
      enterToClass = _rawProps$enterToClas === void 0 ? "".concat(name, "-enter-to") : _rawProps$enterToClas,
      _rawProps$appearFromC = rawProps.appearFromClass,
      appearFromClass = _rawProps$appearFromC === void 0 ? enterFromClass : _rawProps$appearFromC,
      _rawProps$appearActiv = rawProps.appearActiveClass,
      appearActiveClass = _rawProps$appearActiv === void 0 ? enterActiveClass : _rawProps$appearActiv,
      _rawProps$appearToCla = rawProps.appearToClass,
      appearToClass = _rawProps$appearToCla === void 0 ? enterToClass : _rawProps$appearToCla,
      _rawProps$leaveFromCl = rawProps.leaveFromClass,
      leaveFromClass = _rawProps$leaveFromCl === void 0 ? "".concat(name, "-leave-from") : _rawProps$leaveFromCl,
      _rawProps$leaveActive = rawProps.leaveActiveClass,
      leaveActiveClass = _rawProps$leaveActive === void 0 ? "".concat(name, "-leave-active") : _rawProps$leaveActive,
      _rawProps$leaveToClas = rawProps.leaveToClass,
      leaveToClass = _rawProps$leaveToClas === void 0 ? "".concat(name, "-leave-to") : _rawProps$leaveToClas;
  var durations = normalizeDuration(duration);
  var enterDuration = durations && durations[0];
  var leaveDuration = durations && durations[1];

  var _onBeforeEnter = baseProps.onBeforeEnter,
      onEnter = baseProps.onEnter,
      _onEnterCancelled = baseProps.onEnterCancelled,
      _onLeave = baseProps.onLeave,
      _onLeaveCancelled = baseProps.onLeaveCancelled,
      _baseProps$onBeforeAp = baseProps.onBeforeAppear,
      _onBeforeAppear = _baseProps$onBeforeAp === void 0 ? _onBeforeEnter : _baseProps$onBeforeAp,
      _baseProps$onAppear = baseProps.onAppear,
      onAppear = _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
      _baseProps$onAppearCa = baseProps.onAppearCancelled,
      _onAppearCancelled = _baseProps$onAppearCa === void 0 ? _onEnterCancelled : _baseProps$onAppearCa;

  var finishEnter = function finishEnter(el, isAppear, done) {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };

  var finishLeave = function finishLeave(el, done) {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };

  var makeEnterHook = function makeEnterHook(isAppear) {
    return function (el, done) {
      var hook = isAppear ? onAppear : onEnter;

      var resolve = function resolve() {
        return finishEnter(el, isAppear, done);
      };

      callHook(hook, [el, resolve]);
      nextFrame(function () {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);

        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };

  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter: function onBeforeEnter(el) {
      callHook(_onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear: function onBeforeAppear(el) {
      callHook(_onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave: function onLeave(el, done) {
      var resolve = function resolve() {
        return finishLeave(el, done);
      };

      addTransitionClass(el, leaveFromClass); // force reflow so *-leave-from classes immediately take effect (#2593)

      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);

        if (!hasExplicitCallback(_onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(_onLeave, [el, resolve]);
    },
    onEnterCancelled: function onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(_onEnterCancelled, [el]);
    },
    onAppearCancelled: function onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(_onAppearCancelled, [el]);
    },
    onLeaveCancelled: function onLeaveCancelled(el) {
      finishLeave(el);
      callHook(_onLeaveCancelled, [el]);
    }
  });
}

function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    var n = NumberOf(duration);
    return [n, n];
  }
}

function NumberOf(val) {
  var res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) validateDuration(res);
  return res;
}

function validateDuration(val) {
  if (typeof val !== 'number') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is not a valid number - " + "got ".concat(JSON.stringify(val), "."));
  } else if (isNaN(val)) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is NaN - " + 'the duration expression might be incorrect.');
  }
}

function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.add(c);
  });
  (el._vtc || (el._vtc = new Set())).add(cls);
}

function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.remove(c);
  });
  var _vtc = el._vtc;

  if (_vtc) {
    _vtc["delete"](cls);

    if (!_vtc.size) {
      el._vtc = undefined;
    }
  }
}

function nextFrame(cb) {
  requestAnimationFrame(function () {
    requestAnimationFrame(cb);
  });
}

var endId = 0;

function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  var id = el._endId = ++endId;

  var resolveIfNotStale = function resolveIfNotStale() {
    if (id === el._endId) {
      resolve();
    }
  };

  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }

  var _getTransitionInfo = getTransitionInfo(el, expectedType),
      type = _getTransitionInfo.type,
      timeout = _getTransitionInfo.timeout,
      propCount = _getTransitionInfo.propCount;

  if (!type) {
    return resolve();
  }

  var endEvent = type + 'end';
  var ended = 0;

  var end = function end() {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };

  var onEnd = function onEnd(e) {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var getStyleProperties = function getStyleProperties(key) {
    return (styles[key] || '').split(', ');
  };

  var transitionDelays = getStyleProperties(TRANSITION + 'Delay');
  var transitionDurations = getStyleProperties(TRANSITION + 'Duration');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = getStyleProperties(ANIMATION + 'Delay');
  var animationDurations = getStyleProperties(ANIMATION + 'Duration');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type = null;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(Math, _toConsumableArray(durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  })));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
} // synchronously force layout to put elements into a certain state


function forceReflow() {
  return document.body.offsetHeight;
}

var positionMap = new WeakMap();
var newPositionMap = new WeakMap();
var TransitionGroupImpl = {
  name: 'TransitionGroup',
  props: /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup: function setup(props, _ref2) {
    var slots = _ref2.slots;
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    var state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    var prevChildren;
    var children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(function () {
      // children is guaranteed to exist after initial render
      if (!prevChildren.length) {
        return;
      }

      var moveClass = props.moveClass || "".concat(props.name || 'v', "-move");

      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      } // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.


      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      var movedChildren = prevChildren.filter(applyTranslation); // force reflow to put everything in position

      forceReflow();
      movedChildren.forEach(function (c) {
        var el = c.el;
        var style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = '';

        var cb = el._moveCb = function (e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener('transitionend', cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };

        el.addEventListener('transitionend', cb);
      });
    });
    return function () {
      var rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      var cssTransitionProps = resolveTransitionProps(rawProps);
      var tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = children;
      children = slots["default"] ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots["default"]()) : [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
        } else if (true) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<TransitionGroup> children must be keyed.");
        }
      }

      if (prevChildren) {
        for (var _i3 = 0; _i3 < prevChildren.length; _i3++) {
          var _child = prevChildren[_i3];
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(_child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(_child, cssTransitionProps, state, instance));
          positionMap.set(_child, _child.el.getBoundingClientRect());
        }
      }

      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
};
var TransitionGroup = TransitionGroupImpl;

function callPendingCbs(c) {
  var el = c.el;

  if (el._moveCb) {
    el._moveCb();
  }

  if (el._enterCb) {
    el._enterCb();
  }
}

function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}

function applyTranslation(c) {
  var oldPos = positionMap.get(c);
  var newPos = newPositionMap.get(c);
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    var s = c.el.style;
    s.transform = s.webkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
    s.transitionDuration = '0s';
    return c;
  }
}

function hasCSSTransform(el, root, moveClass) {
  // Detect whether an element with the move class applied has
  // CSS transitions. Since the element may be inside an entering
  // transition at this very moment, we make a clone of it and remove
  // all other transition classes applied to ensure only the move class
  // is applied.
  var clone = el.cloneNode();

  if (el._vtc) {
    el._vtc.forEach(function (cls) {
      cls.split(/\s+/).forEach(function (c) {
        return c && clone.classList.remove(c);
      });
    });
  }

  moveClass.split(/\s+/).forEach(function (c) {
    return c && clone.classList.add(c);
  });
  clone.style.display = 'none';
  var container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);

  var _getTransitionInfo2 = getTransitionInfo(clone),
      hasTransform = _getTransitionInfo2.hasTransform;

  container.removeChild(clone);
  return hasTransform;
}

var getModelAssigner = function getModelAssigner(vnode) {
  var fn = vnode.props['onUpdate:modelValue'];
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? function (value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value);
  } : fn;
};

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  var target = e.target;

  if (target.composing) {
    target.composing = false;
    trigger(target, 'input');
  }
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
} // We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.


var vModelText = {
  created: function created(el, _ref3, vnode) {
    var _ref3$modifiers = _ref3.modifiers,
        lazy = _ref3$modifiers.lazy,
        trim = _ref3$modifiers.trim,
        number = _ref3$modifiers.number;
    el._assign = getModelAssigner(vnode);
    var castToNumber = number || vnode.props && vnode.props.type === 'number';
    addEventListener(el, lazy ? 'change' : 'input', function (e) {
      if (e.target.composing) return;
      var domValue = el.value;

      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
      }

      el._assign(domValue);
    });

    if (trim) {
      addEventListener(el, 'change', function () {
        el.value = el.value.trim();
      });
    }

    if (!lazy) {
      addEventListener(el, 'compositionstart', onCompositionStart);
      addEventListener(el, 'compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
      // switching focus before confirming composition choice
      // this also fixes the issue where some browsers e.g. iOS Chrome
      // fires "change" instead of "input" on autocomplete.

      addEventListener(el, 'change', onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted: function mounted(el, _ref4) {
    var value = _ref4.value;
    el.value = value == null ? '' : value;
  },
  beforeUpdate: function beforeUpdate(el, _ref5, vnode) {
    var value = _ref5.value,
        _ref5$modifiers = _ref5.modifiers,
        lazy = _ref5$modifiers.lazy,
        trim = _ref5$modifiers.trim,
        number = _ref5$modifiers.number;
    el._assign = getModelAssigner(vnode); // avoid clearing unresolved text. #2302

    if (el.composing) return;

    if (document.activeElement === el) {
      if (lazy) {
        return;
      }

      if (trim && el.value.trim() === value) {
        return;
      }

      if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
        return;
      }
    }

    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
var vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created: function created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      var modelValue = el._modelValue;
      var elementValue = getValue(el);
      var checked = el.checked;
      var assign = el._assign;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        var index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        var found = index !== -1;

        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          var filtered = _toConsumableArray(modelValue);

          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        var cloned = new Set(modelValue);

        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned["delete"](elementValue);
        }

        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate: function beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};

function setChecked(el, _ref6, vnode) {
  var value = _ref6.value,
      oldValue = _ref6.oldValue;
  el._modelValue = value;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
}

var vModelRadio = {
  created: function created(el, _ref7, vnode) {
    var value = _ref7.value;
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      el._assign(getValue(el));
    });
  },
  beforeUpdate: function beforeUpdate(el, _ref8, vnode) {
    var value = _ref8.value,
        oldValue = _ref8.oldValue;
    el._assign = getModelAssigner(vnode);

    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }
};
var vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created: function created(el, _ref9, vnode) {
    var value = _ref9.value,
        number = _ref9.modifiers.number;
    var isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, 'change', function () {
      var selectedVal = Array.prototype.filter.call(el.options, function (o) {
        return o.selected;
      }).map(function (o) {
        return number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o);
      });

      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted: function mounted(el, _ref10) {
    var value = _ref10.value;
    setSelected(el, value);
  },
  beforeUpdate: function beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated: function updated(el, _ref11) {
    var value = _ref11.value;
    setSelected(el, value);
  }
};

function setSelected(el, value) {
  var isMultiple = el.multiple;

  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<select multiple v-model> expects an Array or Set value for its binding, " + "but got ".concat(Object.prototype.toString.call(value).slice(8, -1), "."));
    return;
  }

  for (var i = 0, l = el.options.length; i < l; i++) {
    var option = el.options[i];
    var optionValue = getValue(option);

    if (isMultiple) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }

  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
} // retrieve raw value set via :value bindings


function getValue(el) {
  return '_value' in el ? el._value : el.value;
} // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings


function getCheckboxValue(el, checked) {
  var key = checked ? '_trueValue' : '_falseValue';
  return key in el ? el[key] : checked;
}

var vModelDynamic = {
  created: function created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'created');
  },
  mounted: function mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'mounted');
  },
  beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
  },
  updated: function updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'updated');
  }
};

function callModelHook(el, binding, vnode, prevVNode, hook) {
  var modelToUse;

  switch (el.tagName) {
    case 'SELECT':
      modelToUse = vModelSelect;
      break;

    case 'TEXTAREA':
      modelToUse = vModelText;
      break;

    default:
      switch (vnode.props && vnode.props.type) {
        case 'checkbox':
          modelToUse = vModelCheckbox;
          break;

        case 'radio':
          modelToUse = vModelRadio;
          break;

        default:
          modelToUse = vModelText;
      }

  }

  var fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
} // SSR vnode transforms, only used when user includes client-oriented render
// function in SSR


function initVModelForSSR() {
  vModelText.getSSRProps = function (_ref12) {
    var value = _ref12.value;
    return {
      value: value
    };
  };

  vModelRadio.getSSRProps = function (_ref13, vnode) {
    var value = _ref13.value;

    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
      return {
        checked: true
      };
    }
  };

  vModelCheckbox.getSSRProps = function (_ref14, vnode) {
    var value = _ref14.value;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
        return {
          checked: true
        };
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return {
          checked: true
        };
      }
    } else if (value) {
      return {
        checked: true
      };
    }
  };
}

var systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
var modifierGuards = {
  stop: function stop(e) {
    return e.stopPropagation();
  },
  prevent: function prevent(e) {
    return e.preventDefault();
  },
  self: function self(e) {
    return e.target !== e.currentTarget;
  },
  ctrl: function ctrl(e) {
    return !e.ctrlKey;
  },
  shift: function shift(e) {
    return !e.shiftKey;
  },
  alt: function alt(e) {
    return !e.altKey;
  },
  meta: function meta(e) {
    return !e.metaKey;
  },
  left: function left(e) {
    return 'button' in e && e.button !== 0;
  },
  middle: function middle(e) {
    return 'button' in e && e.button !== 1;
  },
  right: function right(e) {
    return 'button' in e && e.button !== 2;
  },
  exact: function exact(e, modifiers) {
    return systemModifiers.some(function (m) {
      return e["".concat(m, "Key")] && !modifiers.includes(m);
    });
  }
};
/**
 * @private
 */

var withModifiers = function withModifiers(fn, modifiers) {
  return function (event) {
    for (var i = 0; i < modifiers.length; i++) {
      var guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key4 = 1; _key4 < _len2; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    return fn.apply(void 0, [event].concat(args));
  };
}; // Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.


var keyNames = {
  esc: 'escape',
  space: ' ',
  up: 'arrow-up',
  left: 'arrow-left',
  right: 'arrow-right',
  down: 'arrow-down',
  "delete": 'backspace'
};
/**
 * @private
 */

var withKeys = function withKeys(fn, modifiers) {
  return function (event) {
    if (!('key' in event)) {
      return;
    }

    var eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);

    if (modifiers.some(function (k) {
      return k === eventKey || keyNames[k] === eventKey;
    })) {
      return fn(event);
    }
  };
};

var vShow = {
  beforeMount: function beforeMount(el, _ref15, _ref16) {
    var value = _ref15.value;
    var transition = _ref16.transition;
    el._vod = el.style.display === 'none' ? '' : el.style.display;

    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted: function mounted(el, _ref17, _ref18) {
    var value = _ref17.value;
    var transition = _ref18.transition;

    if (transition && value) {
      transition.enter(el);
    }
  },
  updated: function updated(el, _ref19, _ref20) {
    var value = _ref19.value,
        oldValue = _ref19.oldValue;
    var transition = _ref20.transition;
    if (!value === !oldValue) return;

    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, function () {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount: function beforeUnmount(el, _ref21) {
    var value = _ref21.value;
    setDisplay(el, value);
  }
};

function setDisplay(el, value) {
  el.style.display = value ? el._vod : 'none';
} // SSR vnode transforms, only used when user includes client-oriented render
// function in SSR


function initVShowForSSR() {
  vShow.getSSRProps = function (_ref22) {
    var value = _ref22.value;

    if (!value) {
      return {
        style: {
          display: 'none'
        }
      };
    }
  };
}

var rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
  patchProp: patchProp
}, nodeOps); // lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.

var renderer;
var enabledHydration = false;

function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}

function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
} // use explicit type casts here to avoid import() calls in rolled-up d.ts


var render = function render() {
  var _ensureRenderer;

  (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, arguments);
};

var hydrate = function hydrate() {
  var _ensureHydrationRende;

  (_ensureHydrationRende = ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRende, arguments);
};

var createApp = function createApp() {
  var _ensureRenderer2;

  var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(_ensureRenderer2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);
    if (!container) return;
    var component = app._component;

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      // __UNSAFE__
      // Reason: potential execution of JS expressions in in-DOM template.
      // The user must make sure the in-DOM template is trusted. If it's
      // rendered by the server, the template should not contain any user data.
      component.template = container.innerHTML;
    } // clear content before mounting


    container.innerHTML = '';
    var proxy = mount(container, false, container instanceof SVGElement);

    if (container instanceof Element) {
      container.removeAttribute('v-cloak');
      container.setAttribute('data-v-app', '');
    }

    return proxy;
  };

  return app;
};

var createSSRApp = function createSSRApp() {
  var _ensureHydrationRende2;

  var app = (_ensureHydrationRende2 = ensureHydrationRenderer()).createApp.apply(_ensureHydrationRende2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);

    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };

  return app;
};

function injectNativeTagCheck(app) {
  // Inject `isNativeTag`
  // this is used for component name validation (dev only)
  Object.defineProperty(app.config, 'isNativeTag', {
    value: function value(tag) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
    },
    writable: false
  });
} // dev only


function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    var isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, 'isCustomElement', {
      get: function get() {
        return isCustomElement;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("The `isCustomElement` config option is deprecated. Use " + "`compilerOptions.isCustomElement` instead.");
      }
    });
    var compilerOptions = app.config.compilerOptions;
    var msg = "The `compilerOptions` config option is only respected when using " + "a build of Vue.js that includes the runtime compiler (aka \"full build\"). " + "Since you are using the runtime-only build, `compilerOptions` " + "must be passed to `@vue/compiler-dom` in the build setup instead.\n" + "- For vue-loader: pass it via vue-loader's `compilerOptions` loader option.\n" + "- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n" + "- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom";
    Object.defineProperty(app.config, 'compilerOptions', {
      get: function get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}

function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    var res = document.querySelector(container);

    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed to mount app: mount target selector \"".concat(container, "\" returned null."));
    }

    return res;
  }

  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === 'closed') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs");
  }

  return container;
}

var ssrDirectiveInitialized = false;
/**
 * @internal
 */

var initDirectivesForSSR = function initDirectivesForSSR() {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};



/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
var _PatchFlagNames, _slotFlagsText;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}
/**
 * dev only flag -> name mapping
 */


var PatchFlagNames = (_PatchFlagNames = {}, _defineProperty(_PatchFlagNames, 1
/* TEXT */
, "TEXT"), _defineProperty(_PatchFlagNames, 2
/* CLASS */
, "CLASS"), _defineProperty(_PatchFlagNames, 4
/* STYLE */
, "STYLE"), _defineProperty(_PatchFlagNames, 8
/* PROPS */
, "PROPS"), _defineProperty(_PatchFlagNames, 16
/* FULL_PROPS */
, "FULL_PROPS"), _defineProperty(_PatchFlagNames, 32
/* HYDRATE_EVENTS */
, "HYDRATE_EVENTS"), _defineProperty(_PatchFlagNames, 64
/* STABLE_FRAGMENT */
, "STABLE_FRAGMENT"), _defineProperty(_PatchFlagNames, 128
/* KEYED_FRAGMENT */
, "KEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 256
/* UNKEYED_FRAGMENT */
, "UNKEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 512
/* NEED_PATCH */
, "NEED_PATCH"), _defineProperty(_PatchFlagNames, 1024
/* DYNAMIC_SLOTS */
, "DYNAMIC_SLOTS"), _defineProperty(_PatchFlagNames, 2048
/* DEV_ROOT_FRAGMENT */
, "DEV_ROOT_FRAGMENT"), _defineProperty(_PatchFlagNames, -1
/* HOISTED */
, "HOISTED"), _defineProperty(_PatchFlagNames, -2
/* BAIL */
, "BAIL"), _PatchFlagNames);
/**
 * Dev only
 */

var slotFlagsText = (_slotFlagsText = {}, _defineProperty(_slotFlagsText, 1
/* STABLE */
, 'STABLE'), _defineProperty(_slotFlagsText, 2
/* DYNAMIC */
, 'DYNAMIC'), _defineProperty(_slotFlagsText, 3
/* FORWARDED */
, 'FORWARDED'), _slotFlagsText);
var GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
var isGloballyWhitelisted = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);
var range = 2;

function generateCodeFrame(source) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  // Split the content into individual lines but capture the newline sequence
  // that separated each line. This is important because the actual sequence is
  // needed to properly take into account the full line length for offset
  // comparison
  var lines = source.split(/(\r?\n)/); // Separate the lines and newline sequences into separate arrays for easier referencing

  var newlineSequences = lines.filter(function (_, idx) {
    return idx % 2 === 1;
  });
  lines = lines.filter(function (_, idx) {
    return idx % 2 === 0;
  });
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        var line = j + 1;
        res.push("".concat(line).concat(' '.repeat(Math.max(3 - String(line).length, 0)), "|  ").concat(lines[j]));
        var lineLength = lines[j].length;
        var newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;

        if (j === i) {
          // push underline
          var pad = start - (count - (lineLength + newLineSeqLength));
          var length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push("   |  " + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            var _length = Math.max(Math.min(end - count, lineLength), 1);

            res.push("   |  " + '^'.repeat(_length));
          }

          count += lineLength + newLineSeqLength;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */


var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
var isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */

var isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden," + "loop,open,required,reversed,scoped,seamless," + "checked,muted,multiple,selected");
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */

function includeBooleanAttr(value) {
  return !!value || value === '';
}

var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache = {};

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }

  var isUnsafe = unsafeAttrCharRE.test(name);

  if (isUnsafe) {
    console.error("unsafe attribute name: ".concat(name));
  }

  return attrValidationCache[name] = !isUnsafe;
}

var propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */

var isNoUnitNumericStyleProp = /*#__PURE__*/makeMap("animation-iteration-count,border-image-outset,border-image-slice," + "border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count," + "columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order," + "grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column," + "grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp," + "line-height,opacity,order,orphans,tab-size,widows,z-index,zoom," + // SVG
"fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset," + "stroke-miterlimit,stroke-opacity,stroke-width");
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */

var isKnownHtmlAttr = /*#__PURE__*/makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async," + "autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor," + "border,buffered,capture,challenge,charset,checked,cite,class,code," + "codebase,color,cols,colspan,content,contenteditable,contextmenu,controls," + "coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname," + "disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form," + "formaction,formenctype,formmethod,formnovalidate,formtarget,headers," + "height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity," + "ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low," + "manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate," + "open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly," + "referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped," + "selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset," + "start,step,style,summary,tabindex,target,title,translate,type,usemap," + "value,width,wrap");
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */

var isKnownSvgAttr = /*#__PURE__*/makeMap("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude," + "arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency," + "baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class," + "clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation," + "color-interpolation-filters,color-profile,color-rendering," + "contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate," + "descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx," + "dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity," + "fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity," + "font-family,font-size,font-size-adjust,font-stretch,font-style," + "font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name," + "glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef," + "gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x," + "horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3," + "k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes," + "lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local," + "marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth," + "mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode," + "name,numOctaves,offset,opacity,operator,order,orient,orientation,origin," + "overflow,overline-position,overline-thickness,panose-1,paint-order,path," + "pathLength,patternContentUnits,patternTransform,patternUnits,ping," + "pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha," + "preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel," + "rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures," + "restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing," + "specularConstant,specularExponent,speed,spreadMethod,startOffset," + "stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity," + "strikethrough-position,strikethrough-thickness,string,stroke," + "stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin," + "stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale," + "systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor," + "text-decoration,text-rendering,textLength,to,transform,transform-origin," + "type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi," + "unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic," + "v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x," + "vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing," + "writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole," + "xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang," + "xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan");

function normalizeStyle(value) {
  if (isArray(value)) {
    var res = {};

    for (var i = 0; i < value.length; i++) {
      var item = value[i];
      var normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);

      if (normalized) {
        for (var key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}

var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  var ret = {};
  cssText.split(listDelimiterRE).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function stringifyStyle(styles) {
  var ret = '';

  if (!styles || isString(styles)) {
    return ret;
  }

  for (var key in styles) {
    var value = styles[key];
    var normalizedKey = key.startsWith("--") ? key : hyphenate(key);

    if (isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) {
      // only render valid values
      ret += "".concat(normalizedKey, ":").concat(value, ";");
    }
  }

  return ret;
}

function normalizeClass(value) {
  var res = '';

  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      var normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (isObject(value)) {
    for (var name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
}

function normalizeProps(props) {
  if (!props) return null;
  var klass = props["class"],
      style = props.style;

  if (klass && !isString(klass)) {
    props["class"] = normalizeClass(klass);
  }

  if (style) {
    props.style = normalizeStyle(style);
  }

  return props;
} // These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element


var HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot'; // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

var SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view';
var VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

var isHTMLTag = /*#__PURE__*/makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

var isSVGTag = /*#__PURE__*/makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

var isVoidTag = /*#__PURE__*/makeMap(VOID_TAGS);
var escapeRE = /["'&<>]/;

function escapeHtml(string) {
  var str = '' + string;
  var match = escapeRE.exec(str);

  if (!match) {
    return str;
  }

  var html = '';
  var escaped;
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escaped = '&quot;';
        break;

      case 38:
        // &
        escaped = '&amp;';
        break;

      case 39:
        // '
        escaped = '&#39;';
        break;

      case 60:
        // <
        escaped = '&lt;';
        break;

      case 62:
        // >
        escaped = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escaped;
  }

  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
} // https://www.w3.org/TR/html52/syntax.html#comments


var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  var equal = true;

  for (var i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
}

function looseEqual(a, b) {
  if (a === b) return true;
  var aValidType = isDate(a);
  var bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isArray(a);
  bValidType = isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }

  aValidType = isObject(a);
  bValidType = isObject(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    var aKeysCount = Object.keys(a).length;
    var bKeysCount = Object.keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (var key in a) {
      var aHasKey = a.hasOwnProperty(key);
      var bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
}

function looseIndexOf(arr, val) {
  return arr.findIndex(function (item) {
    return looseEqual(item, val);
  });
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


var toDisplayString = function toDisplayString(val) {
  return isString(val) ? val : val == null ? '' : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};

var replacer = function replacer(_key, val) {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return _defineProperty({}, "Map(".concat(val.size, ")"), _toConsumableArray(val.entries()).reduce(function (entries, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          val = _ref2[1];

      entries["".concat(key, " =>")] = val;
      return entries;
    }, {}));
  } else if (isSet(val)) {
    return _defineProperty({}, "Set(".concat(val.size, ")"), _toConsumableArray(val.values()));
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};

var EMPTY_OBJ =  true ? Object.freeze({}) : 0;
var EMPTY_ARR =  true ? Object.freeze([]) : 0;

var NOOP = function NOOP() {};
/**
 * Always return false.
 */


var NO = function NO() {
  return false;
};

var onRE = /^on[^a-z]/;

var isOn = function isOn(key) {
  return onRE.test(key);
};

var isModelListener = function isModelListener(key) {
  return key.startsWith('onUpdate:');
};

var extend = Object.assign;

var remove = function remove(arr, el) {
  var i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var hasOwn = function hasOwn(val, key) {
  return hasOwnProperty.call(val, key);
};

var isArray = Array.isArray;

var isMap = function isMap(val) {
  return toTypeString(val) === '[object Map]';
};

var isSet = function isSet(val) {
  return toTypeString(val) === '[object Set]';
};

var isDate = function isDate(val) {
  return val instanceof Date;
};

var isFunction = function isFunction(val) {
  return typeof val === 'function';
};

var isString = function isString(val) {
  return typeof val === 'string';
};

var isSymbol = function isSymbol(val) {
  return _typeof(val) === 'symbol';
};

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object';
};

var isPromise = function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val["catch"]);
};

var objectToString = Object.prototype.toString;

var toTypeString = function toTypeString(value) {
  return objectToString.call(value);
};

var toRawType = function toRawType(value) {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

var isPlainObject = function isPlainObject(val) {
  return toTypeString(val) === '[object Object]';
};

var isIntegerKey = function isIntegerKey(key) {
  return isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;
};

var isReservedProp = /*#__PURE__*/makeMap( // the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');
var isBuiltInDirective = /*#__PURE__*/makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
var hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * @private
 */

var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * @private
 */

var toHandlerKey = cacheStringFunction(function (str) {
  return str ? "on".concat(capitalize(str)) : "";
}); // compare whether a value has changed, accounting for NaN.

var hasChanged = function hasChanged(value, oldValue) {
  return !Object.is(value, oldValue);
};

var invokeArrayFns = function invokeArrayFns(fns, arg) {
  for (var i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

var def = function def(obj, key, value) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value
  });
};

var toNumber = function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
};

var _globalThis;

var getGlobalThis = function getGlobalThis() {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};



/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/

module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url["default"] : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
})); // runtime helper for setting properties on components
// in a tree-shakable way

exports["default"] = function (sfc, props) {
  var target = sfc.__vccOpts || sfc;

  var _iterator = _createForOfIteratorHelper(props),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          val = _step$value[1];

      target[key] = val;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return target;
};

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=script&lang=js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=script&lang=js ***!
  \***************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _HelloWorld_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue */ "./src/vue/HelloWorld.vue");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      title: 'hello world'
    };
  },
  components: {
    HelloWorld: _HelloWorld_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  methods: {},
  computed: function computed() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=script&lang=js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=script&lang=js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "HelloWorld"
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true":
/*!*******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


var _withScopeId = function _withScopeId(n) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-5e019a2f"), n = n(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)(), n;
};

var _hoisted_1 = /*#__PURE__*/_withScopeId(function () {
  return /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h2", null, "", -1
  /* HOISTED */
  );
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_hello_world = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("hello-world");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [_hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h2", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($data.title), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_hello_world)], 64
  /* STABLE_FRAGMENT */
  );
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("h2", null, "hello world");
}

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compileToFunction)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
  }
} // This entry is the "full-build" that includes both the runtime


if (true) {
  initDev();
}

var compileCache = Object.create(null);

function compileToFunction(template, options) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       true && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("invalid template option: ", template);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
  }

  var key = template;
  var cached = compileCache[key];

  if (cached) {
    return cached;
  }

  if (template[0] === '#') {
    var el = document.querySelector(template);

    if ( true && !el) {
      (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("Template element not found or is empty: ".concat(template));
    } // __UNSAFE__
    // Reason: potential execution of JS expressions in in-DOM template.
    // The user must make sure the in-DOM template is trusted. If it's rendered
    // by the server, the template should not contain any user data.


    template = el ? el.innerHTML : "";
  }

  var _compile = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
    hoistStatic: true,
    onError:  true ? onError : 0,
    onWarn:  true ? function (e) {
      return onError(e, true);
    } : 0
  }, options)),
      code = _compile.code;

  function onError(err) {
    var asWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var message = asWarning ? err.message : "Template compilation error: ".concat(err.message);
    var codeFrame = err.loc && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(codeFrame ? "".concat(message, "\n").concat(codeFrame) : message);
  } // The wildcard import results in a huge object with every export
  // with keys that cannot be mangled, and can be quite heavy size-wise.
  // In the global build we know `Vue` is available globally so we can avoid
  // the wildcard object.


  var render = new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__);
  render._rc = true;
  return compileCache[key] = render;
}

(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(compileToFunction);


/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");



function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
  }
} // This entry exports the runtime only, and is built as


if (true) {
  initDev();
}

var compile = function compile() {
  if (true) {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)("Runtime compilation is not supported in this build of Vue." + " Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\"."
    /* should not happen */
    );
  }
};



/***/ }),

/***/ "./src/js/element.js":
/*!***************************!*\
  !*** ./src/js/element.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/style.css */ "./src/css/style.css");
/* harmony import */ var _css_title_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/title.less */ "./src/css/title.less");
/* harmony import */ var _css_image_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/image.css */ "./src/css/image.css");
/* harmony import */ var _img_2_jpg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../img/2.jpg */ "./src/img/2.jpg");


 // import '../font/iconfont.css'

 //1:

var div = document.createElement('div');
div.className = 'title';
div.innerHTML = '';
document.body.appendChild(div); //2:

var bgDiv = document.createElement('div');
bgDiv.className = 'img-bg';
document.body.appendChild(bgDiv); //3:img

var img = document.createElement('img');
img.src = _img_2_jpg__WEBPACK_IMPORTED_MODULE_3__;
img.style.width = '350px';
img.style.height = '200px';
document.body.appendChild(img); //4:
// const iEl = document.createElement('i');
// iEl.className = 'iconfont icon-yonghu'
// document.body.appendChild(iEl)

/***/ }),

/***/ "./src/js/format.js":
/*!**************************!*\
  !*** ./src/js/format.js ***!
  \**************************/
/***/ ((module) => {

var priceForamt = function priceForamt() {
  return '999';
}; //common js


module.exports = {
  priceForamt: priceForamt
};

/***/ }),

/***/ "./src/js/math.js":
/*!************************!*\
  !*** ./src/js/math.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": () => (/* binding */ sum)
/* harmony export */ });
//ES Module
function sum(num1, num2) {
  return num1 + num2;
}

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/title.less":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/title.less ***!
  \*********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".title {\n  background-color: pink;\n  text-decoration: underline;\n}\n", "",{"version":3,"sources":["webpack://./src/css/title.less"],"names":[],"mappings":"AAEA;EACE,sBAAA;EACA,0BAAA;AADF","sourcesContent":["@bgColor: pink;\n@textDecoration: underline;\n.title {\n  background-color: @bgColor;\n  text-decoration: @textDecoration;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/image.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/image.css ***!
  \***********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../img/1.jpg */ "./src/img/1.jpg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".img-bg {\r\n    background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\r\n    background-size: contain;\r\n    width: 200px;\r\n    height: 200px;\r\n}\r\n", "",{"version":3,"sources":["webpack://./src/css/image.css"],"names":[],"mappings":"AAAA;IACI,wDAAoC;IACpC,wBAAwB;IACxB,YAAY;IACZ,aAAa;AACjB","sourcesContent":[".img-bg {\r\n    background-image:url(\"../img/1.jpg\");\r\n    background-size: contain;\r\n    width: 200px;\r\n    height: 200px;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/style.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/style.css ***!
  \***********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".title {\r\n    /* */\r\n    color: rgba(18,52,86,0.47059);\r\n    font-size: 30px;\r\n    font-weight: bolder;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\r\n}\r\n", "",{"version":3,"sources":["webpack://./src/css/style.css"],"names":[],"mappings":"AAAA;IACI,wBAAwB;IACxB,6BAAgB;IAChB,eAAe;IACf,mBAAmB;IACnB,yBAAiB;OAAjB,sBAAiB;QAAjB,qBAAiB;YAAjB,iBAAiB;AACrB","sourcesContent":[".title {\r\n    /* */\r\n    color: #12345678;\r\n    font-size: 30px;\r\n    font-weight: bolder;\r\n    user-select: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css":
/*!****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\nh2[data-v-5e019a2f] {\r\n        color: red;\n}\r\n", "",{"version":3,"sources":["webpack://./src/vue/App.vue"],"names":[],"mappings":";AAyBI;QACI,UAAU;AACd","sourcesContent":["<template>\r\n    <h2></h2>\r\n    <h2>{{ title }}</h2>\r\n    <hello-world></hello-world>\r\n</template>\r\n\r\n<script>\r\n    import HelloWorld from \"./HelloWorld.vue\";\r\n\r\n    export default {\r\n        data() {\r\n            return {\r\n                title: 'hello world',\r\n            }\r\n        },\r\n        components: {\r\n            HelloWorld\r\n        },\r\n        methods: {},\r\n        computed() {\r\n\r\n        }\r\n    }\r\n</script>\r\n<style scoped>\r\n    h2 {\r\n        color: red;\r\n    }\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\nh2[data-v-7d22bc7c] {\r\n        font-weight: bolder;\n}\r\n", "",{"version":3,"sources":["webpack://./src/vue/HelloWorld.vue"],"names":[],"mappings":";AAWI;QACI,mBAAmB;AACvB","sourcesContent":["<template>\r\n    <h2>hello world</h2>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        name: \"HelloWorld\"\r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n    h2 {\r\n        font-weight: bolder;\r\n    }\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./src/css/title.less":
/*!****************************!*\
  !*** ./src/css/title.less ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_title_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./title.less */ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/title.less");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_title_less__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_title_less__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_title_less__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_title_less__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/image.css":
/*!***************************!*\
  !*** ./src/css/image.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_image_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./image.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/image.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_image_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_image_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_image_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_image_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/css/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/vue/App.vue":
/*!*************************!*\
  !*** ./src/vue/App.vue ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_5e019a2f_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=5e019a2f&scoped=true */ "./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true");
/* harmony import */ var _App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js */ "./src/vue/App.vue?vue&type=script&lang=js");
/* harmony import */ var _App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css */ "./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css");
/* harmony import */ var F_knowledge_vue3_ts_code_02learn_webpack_06learn_webpack_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,F_knowledge_vue3_ts_code_02learn_webpack_06learn_webpack_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_App_vue_vue_type_template_id_5e019a2f_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-5e019a2f"],['__file',"src/vue/App.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/vue/HelloWorld.vue":
/*!********************************!*\
  !*** ./src/vue/HelloWorld.vue ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _HelloWorld_vue_vue_type_template_id_7d22bc7c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true */ "./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true");
/* harmony import */ var _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HelloWorld.vue?vue&type=script&lang=js */ "./src/vue/HelloWorld.vue?vue&type=script&lang=js");
/* harmony import */ var _HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css */ "./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css");
/* harmony import */ var F_knowledge_vue3_ts_code_02learn_webpack_06learn_webpack_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,F_knowledge_vue3_ts_code_02learn_webpack_06learn_webpack_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_HelloWorld_vue_vue_type_template_id_7d22bc7c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-7d22bc7c"],['__file',"src/vue/HelloWorld.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/vue/App.vue?vue&type=script&lang=js":
/*!*************************************************!*\
  !*** ./src/vue/App.vue?vue&type=script&lang=js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/vue/HelloWorld.vue?vue&type=script&lang=js":
/*!********************************************************!*\
  !*** ./src/vue/HelloWorld.vue?vue&type=script&lang=js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./HelloWorld.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true":
/*!*******************************************************************!*\
  !*** ./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_template_id_5e019a2f_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_template_id_5e019a2f_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=template&id=5e019a2f&scoped=true */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=template&id=5e019a2f&scoped=true");


/***/ }),

/***/ "./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true":
/*!**************************************************************************!*\
  !*** ./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_template_id_7d22bc7c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_template_id_7d22bc7c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=template&id=7d22bc7c&scoped=true");


/***/ }),

/***/ "./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css":
/*!*********************************************************************************!*\
  !*** ./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_5e019a2f_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/App.vue?vue&type=style&index=0&id=5e019a2f&scoped=true&lang=css");


/***/ }),

/***/ "./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css":
/*!****************************************************************************************!*\
  !*** ./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_HelloWorld_vue_vue_type_style_index_0_id_7d22bc7c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/vue/HelloWorld.vue?vue&type=style&index=0&id=7d22bc7c&scoped=true&lang=css");


/***/ }),

/***/ "./src/img/1.jpg":
/*!***********************!*\
  !*** ./src/img/1.jpg ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "img/1_278559.jpg";

/***/ }),

/***/ "./src/img/2.jpg":
/*!***********************!*\
  !*** ./src/img/2.jpg ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAZACyEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5+HFFFJmpOoKO1GaM0IBaKPpRRcAFFFAoAPWjiiigA7dqBSUZFAC9qPpSZ4ozSAWikzSZoAXijp7UUlABS0g4p1ACUGg0UAFFFH5UAFHFGaBQAfhQP0oFHtQAtGKKB9etCAB+FL2o6UCmAU5T2po6Uq8GgkuWx5rWtj09KyLf71a1t0wahkM1Lc1rWZ5AxWTbj0rVs+oqTKWxuW/3OlTKKitvu44qyvt+NQzBiqOKcBntQBTh0qRDGxVK574q83SqNz3qRozbjO0+mKw73v61t3B4IrEve9NG8DBuzjPH1rNkPWtK8H3qy5P0reGxuhh+lNpTSetWWgooBzRxjpQNB3o7c0nGKO1ACjPrxQABQOR9KKBDqWmil9aADtxS9aSgGgYfWiij6UAFAHcdqKKACjtQKM0ABpv1p1IelAhvagUuaB0oGHTpS/jSUozQAlFOooAbRSnrSUFBRRRQAooFFLQIMUUUUCAUYoozQAd6PrRxRn8aADtSjpSdKO1ABR7UlL+NA0A96Pxo7UdqBBijmiigYvvRzSCigQA0UfjR+NABRRRQAUfzoye9H1oAB3zQaSloADS/hzSZ4ooAB7UUZ4ozTAKMUUCgA980D2oHFHvQAfWjij86KQB3o5oooAOeaB9OaKPxoABmiiigoKPxooFMkO1AzRRQO4UUUUCFFIPejNFAC0mKT1zS0h3DilpO1AoEHFFH0o7UAH0o570v0o4oASj8qM8UUAHaj6Cij2oAKUUlH0oAKO3WjtR2oAKO1HeigAxxR60dqKACijtRQMUdKKQUtAxR0pQOKQdOaWgVgoxRmjPXNAWFpO1JS0BYBRij8aM0BYO1L9aT+VGeaLhYWigfXiigLB2o7YFHNFAWE9aB7UtFBSEpccUUCgaCj1oGaO1MYdqO2KB0pR70AIPwpaT+VL2NFwCigUd6LgHWk7e1L7Ck59aLgFFFFABRRR3oAOvWjApRRQAUUopKQhRSjpSCloEHSkpaKAQtHTpSUUDQoo+lFH0oKD60hFFLQAmKB+lFFAxR7UYpO9H40AKKKT6niloAO1Ao6dKSgLi8UUe1HFABQM9hxQO5oz1AoAPpR+FApKAFx6dKOKQHHSloAUUd6QfWl7UAPHpTlpg6U9TSGh4z+FLmmKeKcKQCinD60wGnZoKHCnCoxTgaoCQU8VGDTloEPHFLSClBqSRRTlptPX2qSRwpaaKcKRIoxT19aaKeOtAhwpc0nNLUki0o/lSdqUdxUsQdjSjg0DvmnCkQxV61IKYPb8acKTJY8dKUYpopw71JIo9KUUgpRQIUUo5pBS9qkApw9qQdetOHtQAAU7mkWnCpGFJS0UgQlJ35pfrS0AIKXnFApaAG4/SlpaSgkSkp30pKBCdvSjijjFJ25poBD3xUL1ISMVE5poRC/Xio/wAae3rTeKtANPQ1E1Sn2qNhVICOlBpfWm1YBRRxzmkoAX1pPpRRQCFHSnBuOlMyaUH3qSkPycUZpuaTPNRYaHil7U0Uo70FIeKAabSimigY9uDTVpaei5NaIBV7VKnXmlSPipkiqrjJoOlWUFRxRnFW44/ammK4wLShfarAjpwiouQQKvtT1T2qykXrUixCpuBDGnrUqrUyx08Jx0qLgRRr3NToKFWpFWpZDY5alSmAVIgqTNk6dKeOKZHUgpEge9MPfvTz0ph+tAhh6cVE3vUrZ5J6VE1QxohamH6U80w0rDG4oNLSdiKYXGnpzTfwpxxim+9NIQhpD0NL7U0mqEyJ/aq0tWHPFVpO9Ais/eoGqZ+9REdaQ0R0096kxTSPSlYpEZphqQjrTcdaljQz+dH40tGKRQZ/OlFJ9KP6UgHqasIeKrr+lTJ0q0JkymnDpUakU4HNWiR65p4pik9BTx0rRE2HCkHtSjpxRTJEo9+1Ln3o5xVCGmo26Hinn2qNvegEV5emKqPmrcvf1qq3PrQUiFunNR59qlb9aiPtSYwHqaQ+tAz+dIakpCUD3opQKQABxSetKBxS4oAZiin4oxTuBGf5U3FSY5pMUxoaMinrSAU5QaBolTpTx+dMWngUALgelFLiikBwIopKBXWmdotFJmg0XAWikzSii4CigUg6UUXAXoKSjtRQAdqKSigAo7UUUABozRRQAvagUgozQAv0pRikpRQAtH40UUAFHtRRQAn40uKKSgApaOKKAD6UUUUIAoHtRRTABTl600U5aCS5a9a17XsKybbHpzWra+1Q2S0a1uK1bReelZdr0FbFt2xUGEjVtz8uKtp05qlbk+lXkPHvUmLHjFApaO1SJjH75qhdZ5q+3Q4qjcjrUjRlz9DWTeLweK2ZQOc1nXSZBpo3iczdr1FZUw5NbV+uCRWNP3raD0N4lY0dqU96b61oWg+lL29qO1HHrQNAfage9AxR64oAKKPxooEFL70lH40DQvvRmkooAXNLTaPpQAvFLTaO1AC9uKM0DmkoAU0nNHaj2zQCQlFH40UdAFHSgcUUUAKKOtJSigApKdSUDsJRRRQMKKKKBWF7UZ9qSgUCF7UtNpRigBaT8aBSUAL70ZpKKAF4o7UlKPegA+po5/CkoHvQAtFJRQAo6UZpKKAFoFJ+NA6UALRSDpzRQAvajNJRQAo+tFHHWkoGhaKQdKKAsLmikooEL9KPxpKKAF+tLSUntRcBe1LTaOtAC96PWk7UetAC/jQKSigBaOO1JR9KAFo/nSUA0XAWgUUnegBfpR35pKO3NFwFo560go7UXAXijtSUUALmgUlFADqKTtS0AFFFFACUZpKKAFzR9KQcUc0ALmjtSUUAKKKQUUAOpM80lFA0haKSigLDqKbSigGLS0lA60BcUUtJS9qBhRSCl9qACige9HagEFFFFABRRS9qAAUCkpeKAF6CjjFJ+NHagBaKKTrQNC0DFJilxQUg+nWlFJR2oAWj69KSkoC4vA6UUmTSfWgVx3SikpKAuOoHvTfpSgmgYtFIO9GaAFoFJRn3ouAo9KWkzR7UAOopBRxzQJi0UlKOlFhXF7e9J9aKKAAUvam/jSigaFHSloooKQUUlLQAlH86OKBQAtIKWigBOPwpaMUUAJ2xR2oxR2oABR3pKPpQAv1PNH0pPal7UABopKM9xQAtHekooAUUoptKM44oAePenCmCnD60hjx1pQaaKO9IY8UoNMBBpRQNMcDTwajFOWqGSCnrTFpwoJHj3pwpgpwqLiHilU8U0U4UiWPFOHWmD6VIKRNxwxSrmkpwpEscMUtNFOHFIQtOHXtTeKcOR3pEsAKcOlItLUkDlpw9j0po4pRSEPFKOnNNFOHpxUskcPQ0CkHSlFIQ4e9ApO9KPakNDhSimilB+lADxSg9sdaaDjvS/jUgOo7U3NFIBc0Dn6UmaM0AO7UCkBxRnmgBeMUhoNJmhEsUGjNNz6Cj8aBBTSetBP5UxjxxTQhGPpUZPB55oY+lRt0qkgENM9c0uRTSferSAPqajPSnE0wnrVJAJ3pv6UvrSdueaAEzxzSZ4pPpSZpoB2aKbn60A8GmA6gUlIDSGmPoFNBp1TYpMcvWnCmgVIoosNMADQBT1X05p6oaaRVyMLU0Kc09Ic9qtwwc5xTSHdBFGMVYjjFSRw8dKsRxUwuMjSrMUee1Pji9asxR46U0ybjUi46VIIhjpU6JxnFOCUmxXK4jp4SpxGacEqRXIAnHNKF4qwEPejZ6CkK5CFpwWpSlAWpJuMAxUiigCngVJA9BTxTFp46UEge9RmpD3qNvegRGxqNunNOY8HNRk9qloaI26UynHvTexxSSHcafemEilY1GT69BVWEBakzTemcdKTNMB+eKYxpCe4pjN70CY1zwc1WdutSSN+dVy1Ahrd6jPc08802gaYztTSPWnnp0pKVhkeKYe9SEdaaRipsUhmKb25qSm9uKkaGUCg0ChDHLUqniou9KD600wJlNPDDHpUAI9aeDVpisToalXFVlbmp0IxWiZFiT60vFNHTmiqJsL9aO1IDSZ4poVgNRMetSE1Cx4NMEiKTvVV6sOepzVd+vXk0mNETYqI1I3cCoj0PNIpIT60djmko9vWkNBQKO9KPSkA4Zo5pQKXFACYoxxTsUuKAIyOKTBqXFG2quFyMCnqPanBacF9qBiKOKcopwWnKtK4xMe9FSYFFK4HnPY0CjFKPQ12naAzSfjS0YoATFFFHNIBR0opBS0AH40UfnSUAFFFFABRR70UAFFFFABQKB1pRQAUopBTqACikGKWgAooHtRQAgpRR9KPpQAfWjvSjpSYoAKKKKEAUUfyopgAp6Cmdqeh60hF2DrzWnanpWTC3NalqeBzUsTRtWla1ueKyLQ+5rWtulQznmalv0q/GeKoW9XEPFSYMmHTilFNB9CKWpEBHBqlc96unGPeqdxUjRmy9TVG4HykelaEneqFznacmmjaJzepfebArDm61u6mvJrDmHJHatYbG8SsR1pPbPWnGk984/CrNEJ7UvFJTu1UA2lHelHvR3oGIaSnfWk9aBCc+lFGKOM0AFA6Uo6UUDQlL06daSl9aAEFHeijtSAKPrRQKEAe2KTrS+vrScUwCiiigBaKB0pRQAtGKKO1SAUUUVRQlJS0lABQKKKAAdKUUCjFAmGKBR7UtAhMUUtFADaKdRQA3vRRRQAUUUd6ADtRR3ooAKBRRQAdqO1FHegA+lFGKO9ABQKKKAEpaBmjvQAUUUZoKCjmij3zQAflRRRQSFFHeigAooooAKKKOe1AB3ooooAKB3o7UCgAooooAB0o7UUUAFFFFABRRRzQAdqKOaKADvRRSigBaKTFAoAWkPSlooAbQM0UUAFHeiigAooooAKKKUdM0AJRRRQAUUUUFBSikpRQSKKWkFLQACl7UUUFB9KOT1oHTmjvQAUCij+lABRS5+tIKAF7UlL60ooATtRRRQAfhRj6YoooAPxoHAoooGhaMUUhoGLRRR296ACk7UtJ1oAOKSjt7UD9KBBRR2o7UBcO1IKXj8qKBi0mKKKkYUUUCgBc0tFH1NUAopPWj6UUITFFKKaO9OWmIKO1KOlA7+lIBKKUUg96LDFoFLRQMKKQUe1AC0fWiiiwAO9L1pBTqAEAyaeFpo6UoYigAK8Uyn7uKaKAEpKXtRQA2ilooAbijt0pe1FAxKXtR3oGaBAOlFApRQNCinCmilH40hju/FKM96aOuBTvrSGLQKQUooAcKetMHWnrQA9elPFMFPFADlpwpq04daRI4U5aaPzp60iRy08cimrT1+tITFHP1pw9qaKcKRIoHFOpBSikyWKBThz0po5FOX8KQhw6fWlAoAxQM47VJAtKOKTtS0iRRxThzTR1pwpCHD3pw9qYO9Oz9KkQo60ucU3NGfSkMdS9+KZmjI9qAJAaXPcVGCPXFAPWiwiTNGfypmeKTNKwXJM0dqjyO9GeODSC5Jn3ozx1pmeKTPelYLjy3HvSZH5Uzce9G6gVx+aM1Hu96TNOwiQnr0qMnINNLGmFuapIQpbvUZNKT+VMJ4poBD0phNKxqMn86tAKTTTSZpM0wAnuKaaPxpO1NAhO1A74oopjAdKKQUv50CA9KKQYpRQCFWpFFMHXvU0S5pWGhVWpUSpUT2qeOP2ppDuRxxGrUUPFTww+1XI4eOlNIdyrHD7Vbih9qnjhq1FCKdhcxXSGp0i/KrUcXarCQUWFzFNI8VYhjJ7VYWDmrEUOO1KwcxXSLipBF6CrixcU4R0ieYpiLmneXVnZRtpMVyps9aTYKsMtNK1DHcg2+lJtqbbTSKkVyMClxTsUYpEgOO9OHuKaPelzx7UAIe9RMevtT2PXioWPXmgkax461Ex5PQ05iecVGefpQNCGmHpxTulN+lADGHpTGqQ1G1AXIyaaTxjvTmqM9OKBXAtULtxSsahc8cUCGO2etR9TSnPNJQAhpppx6deaTH0oGhuOKTmndKKVhjO3FN+tPxSEUWGiPvSdqfj8qb2qLFJkZ6c02nmm8c1I0AxilX60lFNaDHA9KeKYD9aUVSYWJAfpUqN2zUAPbNPQ+9WmTYsBu1KGqJW4xS5rRMixJmjPvTM0me9UhWFJqJjjNPJ7VEw/KmBE561C2alYH8KjYUrjRCf/11H/KpmFRkHnHNSBHRjtUm32pAvtSuAwCnAU8KaULSuO40CnAUoHXFKBRcQmKcBSgUu32ouA3FKBTgKcF4ppiuNC08LilC04LTuCYgFOA6UoFKB2pFJicelFSbaKkLnmYPFFJzmlrvO8B70UUtACUDpR2opAGKKKKADFFFFMBO9GKWikAlL3pKXtQAmKKB1paAClFJSiiwAKWgUtFgEFHalApcUWAbxS0uOKUCiwDaKdijFADcfpRTsUmKYCCkGadikx6UAJ/OjtS/SjFACCnD6UlKP5UrATxE1p2jfKKyYz+taNm3PXmkxPY3rNj61s2xzisK0NbVq3vWZzzRsW54xmrSGqUDcZq4h47VJg0Tqadmo1YdKeDxSsSKen4VUnwQatE9fpVafoeMVNhooSgc8VQuRwfpWhLxzVC56UXNomJeR7gc1g3cW0mukm5JBFY+oLyfzFXFm8WYjDrimfWppRyTUXTpWyRohO9Hv3pR7UdqYBR2pRSc0DE/pRilxxRQAnrmgUv60Y+tAWEHSjnrS0YoAT6Clx7Uc4ooASjmloFIBtL9OtL25ptABikpfeimFxKB70frRigBR0oBpKWgBfWlpooHNIB1FNpRQO4UClophcSgUtFAXE5paKPXFAg96UUfWjigAHSkpaO54oABSUtH8qAEoxS44o96AG/WilooASjoKXnvRigBBQOtLilxQA2kp2KTFACYoFLRQAlFLSUAHrRR+NFA0HaigiigYUUUUEhR2oo/OgAxQKKUUAJRilFJjikAUfSlox2FACUYpeaWgBtFLiloAb3opcUlMAopRQMUAJRSkUd6AE7UUtHb3oASij680tIBO/elxRijmmAe1LSCloAKQ0Z4o7UAJRRRQAUUd6KACiijFABRR2oHSgAopfWkoHcKX+dGKWgQUUdqOKAFHSiigUAKKKKKCgoH04oxRQADPejvRRQAUc0vrQO+TQAv8qPrR/KkxQAc0etGKXtQSJR0pe1JQUA6UtGKKBoBSUtHvQMO9FLR/KgBO1J3p1GKBDKO1LSUCD2opcUuKAG0UuKXHFA0JRxRinAemKkaG4pcetOC569aUISOB1FMZH2pRg9af5ZA5BoCHoAaYDcelH1p2056UmKaEw796OPSilA4osIMUnr6U40UAJSc+tL0FJ9aAFzSj6U3+dGaQ0xaKTNKP50BcWigegzil2nHBpiEHtSj9aFQ9eaeEPPFAXGf1oA/KphH7Umw55oAj5xSVJt9aNvFIYyjFP28UbaAI8UlPK+1Nx2oBDaSnbfSlKnNAxnr60Dj6UuOaMUAIKUUDvQOtAC0v8qBSjNIpBTqQe1KKQBSjpSY4pR0oAcKeKjFPWgB609aYOlPWhgSL0pwpopwpCHCnLTRT1pEjx0pw+tMX608UhMcPpTh/OminUMkUZxSj3pBzThyKmxIq+3SnLTR+tOFIkcPpSj3poyOvSjNKxNx3rxR/SkB96AaLEMUHNOB560wH0ozxU2ESA9aXPHFRg+tG6lYB+aXPFR5pc//AF6VgH80oNM/KlHT1oAdn0pRTfzopWAXNGT60n0pPrRYVxwPYGlBpnSkzSAfu45pM+/NMz7Uue/pRYBSaTJ9aTNGaVgFzRnjrmm54pKYgJ+lMJ680H680wn1ppCFJphPXmkJ600nse9UkAE+9Rk+9KTTSapAGaSjvSdqaQrhR/KjP5UnemMKPpRS0DDjnkUg69qWgUriClH6iinKM9OtFwBAT0q5AtMhj45q9DH6Ci4Jjoo89quww+1Lbxe1aVvDmqQ7kUUPHSrUcfHSrMVvntVmO2qhXK0cVWo4uOasR2/rVlLfigm5Wjj9qsIlSrBipFjxQTcjWMelTxpTlQdhUyrgUguRhOKQrU4FGO1SxFfFNIqwV9qYV7ipuO5XK1GRU5AphAqbhci20wrUxqNunSpC5ERxSYp5/UUw0E3EFJxiim5ppCGuetQscipG/SmEflRYLkZxzTMVIabxinYBmO1Jxjr+lPNNPcUWGMPeom/lUzcZqI0WAhI9Kjfv7VMemO1RN0IpWJuQN3PaoWx2qZ/0qFqAuREGkAOKcfelA7UrBcbg45FIQe9SY4xTcU7DTGY/yKMU/Ax1pMe9A0R4pCOMVIcU04xU2KRHimEcY9qlNMb3FS0NEJxSd6cabU2KWggooo9qQwxSj6Un1pfrTQx6mnKaYMU8flVomw8Hr604H35popwrRMVhaWgfpT1HFUmSMIzTSuO1TbeKds4pXEU2XtURXir5jGOlRNFxS5hlJl7moynWrpjNRmP2qbgVdtG2pynpQEpBcgC04LU2yl20CIAtOC1IFpQKAuR7fSnBakA9KUKaCSNVpwWpAtOAFUmIYFpQKdjsKAKdxCAUAU7FLj0pFJjcUUuKKQ7nmXrR2p2OKTFdyPRG0tL9aO1MBtFOopAIKOlH1NBpgGKKPrR+VACUYoooAKKMUUgDtS4pPpS49aYAMUY5pR+lAoAWlAoH1pwoAQD0pwX3pVHB9alVaAIwtKEqYL6U4LQBBs9aNlWAnSjZ6frRYCvs4OOlN2cVaCYphUZ4FMCALgUm2rGzrTGXrRYCAjikx71KV/E03HHNICOkFONJzQAoPYVbtHOetU6lgbDdaTQjorOTjk1r2sg45rnbR8d617WT3rOxhJHRW8oxwavRScdaxLeTjAJq9DJ6UjFo1Fb3p4btmqcb81Mre9SyLWLGRioJec07dx1qJyecmpBFWXuMVn3XQjmtCXvWfc96k2iZknesq/6Vqyd8VlX2MVUdzZbmLL94+lRetTyj5jxUWOa6FsajMUuKcBQBTGhuO9GKfijFADMUYp+KMUAMxS44p2PSkxQA3HFJin4o7UAMxRTqKAG0etOxx3pO31oEN+lFLRQAyjtS0nagBB9aB70vFJQAD60daPw5paBifWjsaB35pQKAEFOHSkFOFABSjpQKUCgBvalpcdaO1ADR3pRS49KXH50ANxzS4opcUCE7dKO9OooGNGaPr+dLijHrQAmP84pMU7tRigBDSYp3ajFADccUopwH1oxQA0UU7FL70AMpMU/FJQA2k5paTFACcUUcc0GgBO1Jml70lAC96KBRigAoooHFABRRSgYoABS0UUgD3oxxS44opAIPrRS45o96AEHpRR2+tHpigAopaT8KADtSU4dOetJ600AUlLij+dMApOlLxiigApPrSj6Uo/SkAdPrSYpaPwpAJRS80lABRj8qPpQelNAFJ9aWkpgJRThxSYoASinUUANopcUUAAozxRiloAT8TRRj3pcUAAoFGKUUAA6UUClHSgAxRRRQACiiigoMUUUUALSfWjvRQAoxR60nalHvQIWj8KB+lKKBAKOlFAoAT8aKdikwaCkJS0opKBie1L9aSgCgBe1KOlAzTgDmgBMe1JUgU44ox7UARYoxwc1KFo2+1BLI8UYFSbDRt4oC5GBRin44oI9KQxn40AU7b9KUChDTFQd+9XLeME8gYqvGtWo1Pr0ppAXFto2XtSrZR9PWoUJ6EmpVY+tOw7ivp8ZHFVJrAr90ir6sfXt6UjNnqeKaQrmO1qyk5U1CVxx0rZZuuapPAWYkDiqsK5RweaD05q2bWTsp/Ko3t5F/hP5UWC5B2Oab9KkMbDqD+VM2kdRRYVxOaQe+MU4KfSnLETwAeaVhpkdPUZ4HWrUGnyy9BgHvWlaadFCMync3X6UWDmM+1s2kPANaaaXwM8VaFzFAPlGTVWa/lcnB2gn6UKJPMDWSKO3vUBhVemKPNc9WPNOUk9SadguRmPg1EyirJx7VCw6nmlYaZXZQPpUdSSNxVYv6mkUmS8UvFQBqA3pSsF0TYFJt4pgY9jTt3XmkNMQjnNNwOeeaduyOaTjtiiwXG49aQjnpT+OfpSHpigYykH8qdiigAHFKPWm96cKQ0KKXFKBxS4496QCc0o+tFLQACnj0poAp6g0AOFPUUKKeooC4opRSgD0pwWkK4gFPFAFOApCAU8U0CnjigQope3WgelL+FIkUYpR6Ug9M0tIli0opopaCB2e1Ge/FN/Gl9cHmkSLng0Z9aTNJ/KkSPHSjNMBpRSYh2eKXPvTM0oNTYB+aAfWmA0oNADwcUv8AKmZpQfWgCQfU0H3pgNLn0pWAXPNFJnNJnsDRYQE/Skz70EimZHpxSsA8GkzxTc0Z4pWAdmk3U0nimFvzoAlLDmmluKj3Gk3etNIRIT7Uwn0pM+nNNLU0hCE9aTNNb600nrmqsApPsOKYTRn3pMnpTSFcCaPxpOnA6UUwHfjRSDvSigEKPeiinDmgYAUAUoFPVakVxAv41JGvPb3pVSpkXntmgVyxCnHrV6CP2qC2XI6dK0bdKaC5Zt4x6Vp2sQyOKq26+wrWtEq0hcxZhiGKtJF+dLEvFTKtVYVxqx88CpQlOUU8LQTcjC+opQnPFS7aUCkTcjC4p4FOApcUguMxxxSGnn2phqWCYnbrTCODTz9aYelZ3GmRsKjNSkVERUjGGo26VIelRnpQBG1Rn2qRu9RmmibiU09KdTfpVJCuMboaYaee9N9aqwXGHpmmmn9jTccUWBDMU0/qakIPNN9/SiwyNulQsOtTN3qJqQERqJs44NTGon6UWArt39BUR71M9RHuOaQEePXrSgc0CnAUANwelFOAxRjigEMGKTHr/KpMUYpDIiO+aaRxUpFNIpWKRCf0ph4FSkVGRxwKhlIiYHkGmVIR15pmOuakob2pPqKdjmikCG0v1p2OOaAKChQKetCrxUij1qkJiKKcBx7U5V4pwXHWrTJEUc4qVE44pFWp1FMQ1V45FKFqQDjmlCj8am4mRbaaVBJqxtphXrU3C5WMYzTTGCKsleKaVouK5UMY9Kj2VcK1GV45ouK5AFo2cdam20mPyouTcg20YqXH0pMfTFFxEeO9KBT8CimmFxKMGnCimmIQDg0CloFAB2oxS8UnFA0wxRS/hRQO55nijFOxSV3npjKSnHvSUAJRSYoFAB/Oj1oo7detCAO1H1pKXNMANLSD1oxxQAlLilooAMemKQdKX86B60WAO1KKUD0pyqadgEA71Iq+1OSPmpkjP5UAMROanVOKkSPjOKmWPP1oAgCHHSnBO1WRFxSiOmBAqcdOKaUOSKuLFx0pDHTFcqbO1M2D8auGPj3pnl0BcrbDUbJ1q5sNRuvBoC5TZMVEwq4y1Xdamw0VyOabUrA1GR60gG4p0Zwab0oBx0pEs07V+MZrUtX96wbeTB5Natq3vU2M5I3oJMDir8MvGc1jQNgdavQvxUWMZI1opOKtI/bNZUT457Vbif34qSLF3dx1prH3pitxRn1NSxJDJOhz0rPuRwcVff61TnHBqTWJky1mXw65rXmXqKybwZ71UWbRMeQck4FQ4GSMVZlGMnvUJFdCNUNxRinY9aXFMY2jFOA7GjFADMUY9ak2+tG2gdiP8KTFSY4oxQIZim4qSkI4oAZSU7FHHTigBvv7UUvek70AJTaf9KaelAWGEUdqcfak9s0CG8dqSlpKADFFL/Kj1FAxBS4pRQKBCCnikFKKAFpR0oFOoASgY9Kd/nmj60ANFGKdj16UuOOKB2G/hxRTgKMUAN/pS0o/Sjp0oAaPYUuPXpSgetL1oAbjjgHFJ7du9PxikxxQA3HWkxT8UuKAGY5oxTiKMUgG0ClwKXtmmA3tzSGnUh96AGUnrSmjtQAntTad/OkoAb9KKXmkoAKB+dFFABSiiloATtR2pRS0AJ2paKB+NIA6UU7HNGKQDaB/KnY4pMdqAEpcUAdaAO1MA7ZpKcBRj2oAbRjg570oHWihAJ9KO/vS0Y+tMBO1HrRRQAg+tKOtFH0pAHbr0o/Gk7e9IDQAtHvR2opAHaiil9qaAb+VLR+dFMAopaKAEpOaX9aUd6AEoH6UopO1ABijFGKUfpQACiiigA/lRRRjigApR0oooGgooooGFFA6UdvegQUUlAoEL2opKUZoAUUtIKUUAKKMfnSgU9U7UWAjx9aXH51MIzVmCyZ1yTQBRA496UKT0FaX2ML1p8cC9gM4oGmZixMex5p4t2I6VsR26+lWEt0x2oGYItGPTNL9jaui+zpjtmmtbjnFFwMAW+OtHlfXiteS244qAwnPIoC5Q2etLs9RVwRUeWcdKAuUynbFLs9qteUaetuxpiuUglIY+OlaK2tKbXHpmkIySmOabt681ovb+lRNbHqKAuUtuevWnxx5NWPs57ihUwaEguSRx1OkLEcCiAVq2qAgZxVJC5jL8iTPTipYrdyeQfauntdPjmHPH4Veh0qJOTzz6VSiLnOXisJGHI/SpP7LbHzZrsI7aNMgKKd5UZGNoqlEnnOQXTUHY0/7GijgCuq+zRHqooFjCc/LTsLnOT8hR0H6Ugt1Y8r+ldb/AGZB/dHvTk0+JTwopWBSOSbSlYfcoGhbh9z2rsltol7D8qlCoueBRYfMcL/wjvHCHP0qH+xzG3IOfevQvkwRgY+lQSQQv1AzTsHMcUtt5akEYFVJl69eK7K4sYyDtx6VnNpwLHNFg5jlGhOTwaaYWx909K65NKU9hn6VKujKeqilYLnEeWQeQePagcDHvXayaHGVwBWZdaEy52fyosNM50tUDsMc1pz6bNGSCDiqMtnIM5U0DTRRkIOelV2FXHiIPOc1CydaVikyAdP5UDOKfs7UbaVgEHTH404YoxxzQF+tKw7hj0pwHHSgLinBfzpWHcApxQVIp4pTg5osCZARTcflUpApuO1KxSYzHc0oFOx9aUClYaYClH60oHYnmgUhgM+1KB3pVGegp6qaAGBTmpVWnKnpT1Q96dgEUcZqQD2pVWnhcUWENApwH504ClHSkIQD1pwFA4+lKPak0AAU4dKSl+nWpEFLSD9aXFIlig8deM0D60nej+tIli/WlpM8UZ4oJAfWl9eaQe9HbrQQL+dFJzRSsSL9KBSUmaQh2aM03NG7j3pWAfmgN6UzPagH9aLASA+9Lmo8/pSg0WAeD1pQajBpQaQEmfUUdvpTM8UZFFhATSZ/Kmk9aTNKwh2fQ0meDTM0uetKwXFJ9TTcjv2ppbimlqLBccSKAf1pue1GRjIppCuOyfWmE5HNHb3pDTFcaT70nc5oNJ65607BcSil7UD9KYB2oHsaXFAoAQDj2pQKUDinqueKVwGgc1IiE05E7Y4qdI8DApXCxGqfjUyx9sVIiVMkdIVyJY6kSP61Zji9BU8cHqPagi422j5rSt46bBDgdKvwRVSFckt046VrWikVVgjHpWjbpWq2JuW4xxUgFIi8VIophcVakUU1aeBSFcUClA60oFJSFcO1JS9qax4qQEJqImnE+9RlqhsEGaTimlqTNQ2O4pPFRmlJphNIBp71G3enMajY8UIBjVGaeaaapILjOe9HalpPrVoQw001JTSKaAZSEU7nn1pMcc0xpjDTSKkNMIpDIm6daiNSvURoCxGw9Kiepj361E4qQK7DrULdDU71C1ILDB708dPWmDrTx096AsL65pAKUUuKAsJjB96THBFPAox70DIyvHNMI5qbHtSMMilYaZWYUwjB4qcr2zUZH5ioZSZARTSKlIppHtzUFJkWKMCn49PSjH50rjQ0CnKv1pQKeq8cUXGIq+tSKoz9aVVqRV44pgIq04LT1XPWnBTVJkjUXFSqKAKeF70XECj1pwApwHenAUrk3G49qaVqXHpRg0iSuVpNtT7fyo2cUrgVinFRlatFDzTGT6UriuVSvWkK/hU5X0ppXincm5XKjoaTHpUxHrTNtArkWKMVJikx1phcaBQBS4pce4oTEMo5p+OOMUlMExPX1pPWnUlO4CfjRS59qKQHmxFNIqQL1HakxXonrkRHNNNS7aaVPegCPFFPx1zTSKAG9qSlNFACUUtJTAX8aXtSc0ZPegAFLR370DvTSAUUoHFGKkRM9R+NOwCxpntU6R1JDH6irCR+1OwrkKx+tTxx1KkdTRx+1FhXGRx8dKmWP2qaOOpkj9qLCuQLH7U8Q1bSPnpTxHSC5VWLjpUbx/XrWiI+MVE8fp2poLmcUHOBzTCv0q80VQvHTEVSgqN1qyVqNloAouvUGoHXrV9161XdR1x0pWKTKTLULD0q468Gq0i4qR3IDxTfenkU3HWkIVDj1rSs5PWs0fpU9u+09aVibHRW7jsavwtWLbSdK0YJPeoaIcTUjb0q1E9ZsbjuasxuazI5TUjYGn81Ut5PerY6cGpFYa2OSOoqtMODVo9DUEq8VLKSMy471kXg5NbU4zn2rJu1GTTjuaRMeVRzVcjrV6VevXFVXXk10I1REBmlxTgKcFOKoYwDuaUDFSBaUL60DQzbwaNtSY5o29aQ7EW38qbtqfFN28dOaEIhI6ikI9qmK0wrxTEQkUmO1SFaQigCOk9c07FJzQAlJS/Sk7HNACUw089OlNNAhv40nalooAT1pe1JigDigaHUCkFOH60CAU4UoFKO9AAOlKOlAFLQAdqBS0fjQMTAoHrSgUuKQCYpQOKKX2pANxS44pRS4oAbilwaUD3pcUx2G4+lH1p1JTGNpcdfel+lGPWkA2jFO/KkpAJim9qfSEU0Azt17UGl+lB6UySPtSU6koASk/nS0hoASkpaKAEApaSloABSgfrQKcBQAgFAHGKcPenAUAMC04LxTgPalApDsN20Yp+OaXFIZHj0pMcVJijGaoViPbzRg07HtS4oCwzAoxT8e1GO9AWGY/OjHapMUmO1AiPFGOwp+KMUAR0lSYpMcUAR+tHHQU+kxQAz6UmPWnGk+tACd6Wk7UopAA6dRQKB6Ype2KYCDrQKUdKKACjiil7mgAxR+FFFACfyo96WjmgBBRS0UAFHelxSUDQd6O1FFAw7UUUUCQUUUUBcKKUUGgQ3NFL0oxxQAD8aBQOlKBQgAfhmnqPahFz07VbhgLdc0ANtYDI+McVsx6Z8mSOaZZRCMgn1rYklCw5A5xQNIxZbZUbB6CrMO3y8AimTOWYkjg0kIYnav4UCGyrycdKjQHPGa2rbS5LhQQDite18PnblkOfpQBzMcbH1qzHC2O/FdSui4P3ee9SDSgooBM5mO1ZvWrcVjxyOa3ksFXtSuqRjkigVzCaz4OV/Sqz2KnNbFxcRjIBHtVJ7hTnGKEK5QNkozxUMlsqjtir0kwxxzVOeb5Tkimhlcqik5pPMUDAIrPvLg5IB6VQadvU/nVWFc3vOXGM0hYN0rEjlY/xGtC2Ykc5pWC5Z208Y5yBQFJ6U9bdyM1IXIWAIOaqSrzxV2SMr1qswyelUkJMIQc961bT7tZ8SmtG24q0hNnQaY3yYrTTkf1rGsWAHWtWBuatENk5qM96mPK8mo2HXpVWIIS+KfHL6mon6ngVESR0osK5oJIOafvHrWWJSPrThOemaLDTL7P15FRmSqnne9J5vHB60WGmTyTbQcmqb3RBNOZg2QTULIDnGc0WHclW59TUgnHt+NUW+Uc0zzMUrBc2opk28gVYWRCOMVzgnIHWpo7og5BosHMbzMvPSonUHriqMd3kc4NTpcBuhpWC4PAjA5ANU5tOifPy9av7h7e1KW9etFhpnMX2gh8mMjNY02hTr0B/Ku8bvmoWxyDikNSZ57LpU6ZypwKrmydeCpr0ZolYHKjn2qnNYRvnCj8qLFKZwRtyvYigQ+1dbcaUMHiqh03B5FKw+Y58RcdDSmLrW8NPODxSGx9RRYOY58x8dKQL7VttYA9DTP7O9xSsNSMbZ6A0eX1wK2DYkUn2PHY0rDUjJ8o0CI1q/ZyvUH8qPs4PAU0rFcxlhDSiMnNaRtz2Wk8gjqKVg5imkZ9BUojAqcIBkf0pcUWHciCAClC+gqTijFA7jQKXBp2KTFKwXExzRj1p1JilYQA8UfSlpPWlYAHHXpThTe9LU2AUZpabR9eKQrjqSk7c/pR2pWJYv8qBSeuKSixLHj3o96bSj9aViGLR0pM9aM/maLEsX19KT6dKKTNIQc0lHrSe9AC5HrikB4pM8U3OCaAJQfypcmog2PoaXdRYCUHHejNRbqN3FICXPvTd3Xmoi3v8ApSbjigRJupN3Woy1GfQ0Ej8/lSbqZnrSZ680rCuOLU3J5ozxRRYBQT07UA03PHajI5osA+kyKbu4oz6GmIDRSdu3FJn1oC4vrRnjk031+lKOlAXH5704UxeelSAcdKAuOQZqZUJ4pIlPpVuNPWpbsNMjijPbNWUiqaKIYFWo4vaobFcrxwnHFTpD7VZji9qspDUtk3K0UNW44uOhqaKIZxVqOLjtQmIhjjq5Chx0p0cQHrVmKOtIsi46FavwrxioI1AqzEMVqmRcnUcVKBUa09TVXC5IKcKaDSigYtL9abnvRuFS2LcCajY+9OLConNZyYxjN1qNmHrSO3XFRlvWsnIEP3U3dUe6jd6VNwHlqaTTN1ITTTAGPFRk0rGmVSAO1NNLRVpANopcUlUkAmKT1p3ajBxVAiPoKCPan4ppoQ1uMPemEcGpDTD39KQ0QOPxqIj86nf27VC1AyM4wajfNSmon71Iiu3OetQt0OOhqw3XjrUTUhkXenL/ACoxycGlH86QC0ooHrSge9MAGPWjFLR2oAb+dNNP/GmmkwIyOfrUTDORUzVGe+OtQykREds800ipKb+VQUiPHpQBTu/tSgHvUlIaBT1WlAp6igY5R7VIopFFSKOKEAKKcBSinAVSZNxAKkUcZpoFSIO1FyLigZFOApwGKcBSJbGAfnShM08LTgvHSkTcj2/nSbBipsDNJikwuRFaYU4qximMOKQrlVlqJl7VZYVGRwfaqQrkBX1FMK1ORTdtArkBWmkVNjg8U0r2oERY7UgH5VJgc0Yp3AjwPegipMep4pCKLiI8cUztUpXim4ouA2inYNFFwPOcUbfSpNuKTHFenY9kiK0wjipiKjIosBGep700jinnpTDTAYRTe1P+vemkUANpfWjmgUWAWgf5zRS00gEGacopQD3qREzVJACL61YiSiOPmrUSVSRI+FOOlWUjohj4q5HHxQIiSL0/lU8cXtU8cdWooRigVyCOL1FTrFVlIvanhMdqBXIFjFOEYxxUwU+lSBDSsFyuI+DgVE8dXdvOKYY80xFBo+vFQyR+taJj7dqgkj5pAZjp1qBl61oSR9Qarunai41qUnWq7DrV5kqCRPbpSGig68VWkTrxxV914OKrOmQaQ7lJlpmO1Wmjpnl80hkG0+lKoI/Cp/K57Uoi9KB2JYJCBV+CbB5PFZyIR0zU6ZH0FS0FjYglz3rQibjisO2c55PetWFuKzaIaNKB/mrQjbIrKhPPFaER+Ws2iLE56VDJ0OOtSf8A6qY/Q1IJFGUVn3CZzx9K05B1J71Qn79acUWkYs6detVHXnvWlcL1zVNl5NbRZqkQBOvWnBfrUgWnBfTtVDSIwopdtSheOKcFNFxpEG2jbx0qfbxQV9qVxlfb2o29Tzmptnp1o29c0XCxX2/jTSlWShxTdtFxWKpWmFeKtletMKdqLhYqFeKaV71ZKjmoyvemKxBjim8mpSOe1MI9OlAWGHvTe1K1J60CsNpKdikxTEIKWlApyrQA1RTwOOn5U4L7dacF9qQxoHFAHWnhaXbQAzHpSinY9KMHFA7DcUvWndqOPwoCwg96B0wKcPxoxSCwnalxQOlKBQFhKAMU4CgCgEIBRgjmnY4oxQNDfwpO3NPx+VJ6/pTQxKSndvekpgJ2oGKWk96kQU3tT/5U000Kw002n+1NpiGmm0+m0ANxRTqTHFADMUU76UmM0ANxS4pwFKBQOw0CnqKUDingUgQ0DinAcUopRnFAxBS4oHTFKBSGIKcBQBTgtADMelLjjgU8ClI9qB2ItvrSYqbFNx60wsR49aMetPwO9GKYrDMegoAp2KTHFAhOKTHWnUn40ANxTcU89aaaBDMU008imkcUCGGkNOIpKAEopfpR+NAB3NApO/NL0oAO1H86KPxoAUe3WgdKTvxS9sUAFHainUANFLRRQAD8KMUtGOKAEHTmjil+tFACYo/ClFGKACm07FBFADRSijtS0AIKXFFKOaAG4op3HrRj6UANAqRFzSKuT1q/awBj60xojgiycVpQRgDpwKUW+wAjpViJcqBQMTlRxSozSHaMnNXYbMuucVatdOfeNo70WAoLZSN2OD04rZ0rScjLCtaz0x2A3L0rftLERqBj9KLCZDpNgkQ+YCttIogvQVVICDg9BVC71FYFOCM0iS/dBFztxWNd3SITlgBWHqetysSsbEfjWJLdSSnLOTQkFzfu9WVQRGc1i3N9JKTluKq5z6VXuJggySadiblhpTg8moTKcnNVVuM59Kjknxn9KBXLrT4HJqlcXAIOD7VUluGIOTxVZ5SenSmkFx0zbic+tQHvQW96aapCuSRdeSMVp2kgHUiskHHQ81JDKQ/WiwrnUQHIq7DyKyNPl3jBPQVqW7HjHSlYLi3MORwOaoeSAxrZZfMi46iqDrnJ/iHWqsFyqV2/SpIpMHn8KSVTjJqCTKkEZxxmmTc3LGX3+tbFvIOMVydvcbGGelbFtdeh4NUhXOhEg2844qJpOapwzFup6e9SbgcjjNWiR7NxmkI3LxTd2OvSk3cEqaYhjjFRZH5VKz5HPPqKgkAx8p5ouAZP5UBvfntUBk+tRmUluvNIaZb34OGpvmY5BqqZiOG6U0seqnigLlmSRWGDVZ/rxTC5B56e1OVxmgBnP4UmTng1KVDHKnkfrULZ5HQjtQBLHN61YWf1NZpkwcEdKkWUY5JpAaaXJB61Zjuc9ax0kBBGalhZs4B6UWGa4mB69KaWBzyMVSEhGM5FI8hU5UmkFy0WKn2pyzL3ql5/Zuhpvnbc569qB3NIMrKQaYYEbqOtU458H2qZJzjK8inYLkotEx0pDZr0GMmmrdepNKsueUJFILleSxXJwMVCbZ07Air5nIPzqcetKJlzwARSsPmMx+PT8qZkEkFRWo0UMwPQHtiqF1YSLyrDFFhplcohzyMU1oB/CajZZYid6kr60qSMoyp4qbFXRG0XY5qFoR3rQSZCMSgfXHSpxaxuBtbOfSiwJmG0ZU8CoyvqP0rbn06RRkDKnvVF7dl6qfyqbFqRR2jtRg1YeIgcVFtNFhpjQtG2pFBqQLSsO5W24GMUhqzsqJ16ilYLkRHNJTj1pvtU2AX8qQd6SipY7iilHT+VNBHelzSsK4du9BNJ2pM0WJuKO/WlpmfrQDSJHg8YFAPFMzSg0EsdRn1pM/SjNIQoOfSlz/Om5HXvSZHfNAh2aaaM+9MLc0rCFJ4OKYTSbuKaTxmgLjt1G735qMnjNN3eposFybdijd15qHdRupWFclLUgao89c0Z96LASbuOvFAbr1pgPHWgH3oJH7uKQH3puaQGkIkzSZpmfSjNAD8/lSZpufXFJninYLDsmjPFNz7UmaEIf+FJ7UmaOO5pgOoHNNH605eaQE0QqzGn51FCvHFW4lOO2aVgJIo8dquQx1FEmeladvDkVDQrhDF6CrkcPtmpYIOwq/Db+tRYm5UihzwBVtLfjp1q9Bbd8VYEOB0qbCuZ6Q+oqdI+MAVbWHinCP0oRNysqGpo14qTy+acq4qkyRVFTJ0xUQ+tPBrRSETg+9Kre9Q54pN/vVcwi2Go3+9VPMpRJx1pcw7Fkvx1pm/3quZPem7/AHqJSGWPMpjvx1qAye9MaT3rNyAc781GWPNRs1N3elRcCTdS54qIfWnDPemgHZooFLVoBp6U3in4puMirSAbRS8UlWkAUg70tJ2ppAFBo+lIfbrTsCEpPqaXPFNoQxp701sYpxxzjpTGPFA0RP0qFutTN7VEcVIyM0x+hp54qFjz1pCIm6moyD0FSnvTMdqkLkf8qB7UuP1pQKaC4YpQBilA+lOAp2AbRjindqD7ClsAw9CRmmn9Kce9NOeeam4IY3Tr34qI9c1K38qjPoDUNloYfWmkU40neoY0Nx9aUDrQB+tOA4pFJgoP4U9aQAdqkQUh3HqO4qRRTVFSgccU0K4AcUoFOA45pwFNE3GhamRaRV5qRRQTcUD1pyjilX26Uo6d6CLgBS4+lKBx70UibiY4pvFOPQmm54xmgLhTD0p3ammkJsib3FRN7VM3NRmmhXIyP1ppFSYpPWgREQaaVqbH1ppUUWC5Dj9KMYp+KTFAXGYpCKfjjmkwO1AXIiKTFPNNNAXG496KXH0ooC559t4pCKkIpCK9U9kgYe5qNh1qZhUZWgCBhTO30qZhxUeKAGHpTSOKkx+tNPehAMo/GlpMelMQCnJyaQLx04qSNaaQEirmp40PcUyNe/erMa8VSESRp7VaijpkS1biSmIkhj9uKtxx02FOPercafWgVxYk9quRR+nFQx+38quQ4xzQS2OWOl8sVKtOA/Ki5FyER9acEqUDmngUXFcgKCmFevvVjH50xhRcEysy1C6datMODURpXRVyi8fBHeqzx461ouPpVeRevFTcaM9o8D2qB4+tXnHaoJO9FyzPkjPYVXeLr1q+/f1NQPjBpDKLR9qQR9c1aI6+tMwM9KVxpEAT0p2ypQKcAKVykiHZ+QpwTipMetKB/wDWouVYIVweK04M4FZ61dgbjg1EiJIvwnn361oRHg1mxHnrV6BvzqGjOxbHTg9Ka2MYFKKa3eosJFaU9cVSn71clxzniqc36U0WkZ8w65qoy85Aq3NnJ5qELWiNkiEL2xTgvJzUoXtTgmO1MqxEE9KdtqcR+opwjpXGkVttIVPpVnZQUpDKu2jbU+zvSbKAIdvBppWrG32pjLxQIrMOvrTCtWCpphWmKxXK9fSomXrVsocUxo6LhYpFaYwq20fWoXSi4imw55pvepXX0pmw+hppk2G/jS4p+00bT75qxDQKkUcH1pAtPUfnQAAU8CgLUirxxmkNIZjsaMVJjnvRtpXKSIsCl21JtoC+tFx2IsUAelSY9KTHHIoFYZSgU/b7UoX2ouIYB6UoH1p4WlxQAwDrRin468Ube9AJDAOCec0AU7FHbFA0Nx9KSnUYoGNxijFLilpiGU361IRTcUANpKdRTEMIpvapCKbzQSRmkxxTyKbQA2jBp31oxQA3GaXHFOA4pR3oHYZjinAUuM0oFK4wA980oFKB+VOUflSAQA0uKcBTguaB2IwKUDipNtG2i40hgWnAcc08DinY+hoGhmOKMCngf5FAHrQMZjvSEVLim4oER4oIqXbTdv50XFYix69KTFSkUwjtQFhmBSYp+KTHHtVCsRn6Uw9KkYUw0EsZSGncc0hoEMNJ2p9NoAb+tIPrTsUlABRg0UvegBMe1LRR+NABSjpzR/KkoAX6dKKUCjFACD86UdaB0paAE4o9sUtJzQAtJ/KjtQKAFxScUtAoAKSnYpMUANNApcUhFACilyaaM9+lLQAtKM0gqeJM0AJBGWbA5resodq5A5qtZW4yMDmuj02zLkKFJz3xQUkVltWki4XJ6VbsNLlZgQhP4V1WnaQWAG010dnpsFuoMgyaYXOSt9LcABkPpXRafpiRxBnUZ+la58vJEUfT2qGSQdCwz3FArkQjSP7oHSoLm6WJSSwqK8vkjyEA4rktX1Mtuy2Px601qIv6nrO3Kqw/OuavL/zT941myzNI2Sc596fbW0k77YwSev4U7CDdvfjJp4AHBU1ejtlj+RRlu5p32Yck9O5pCMyVjtOOlZk5Z2OBwK2bwcFVxjoTWS0R5IPGfTrQkSyqDgYpk7bUGD1q0Yi+NowKq3ibXI75xTFcpyOcfWogxqWVNoA7mmLHk9RmnYVw6jIoAGCx6CrUVsduegpJIeOOmfzoQFIkk+1TJ2OOM0eWSTViGLKEEcDpTJLlhNtcYAwPet2FsMpB4PFc5bqRW3A3+gxk/eVsUAa0DFVyM1DeJscSLgg80xJwIwFP3upx0qX/AF1syEjeoyKAKj85I5GOajuIwYQV6Y5p0D7g6nqOKdAxeIjuOKaAzAxyRzirNtMQQpPGarS/fIxhgajV+SCcGqJZ0trccYJBxWhFIHHHWuZsptrgk5Ga0RN5b85waaYWNxeR/UUYUd+ScVmLdlWB6oassxf6HpnvVXFYklXacI34djVd2OSPut/OmPI/IBIYUnn7xiQAHp6frRuIa5OSHFNZQQA3XFSbh0bGPX0pkijaMNnFAFaQOmc8ioi5UZXpVuRWVeRuT1qsfmY7exoAekqyJ1GfSlUcH19KhaLcpMecjtnpTUlKdeR0pATFypyOP61IJlYbZRxURGVJU5U1DuPQigCw8PUxnPtUBX0/KpFJ2/KTuHvUibZgcjEmPzoArjg1KrEHcpORSMoPGPm/nSxfMDjt1HrQMsxzcZI+tTuEki3xnnHzCqCYUlgTgdvapI5dpJX7vf3oVuohzsVXA5pgmVhtcY/GnMMnn7p6GoZY+cMPpRYZMh7Bhipoyw+4eR2qiiNjg5H160u2RPmQnB96QF8ncc9/SmBzGcgEA1WjncNkduuanMxKbgAU6HjpRcLssLOB1BwfxoXYzfK2KqlsoWiOR6U0SLjrtalYaZfibLEOAeeuetWgxUYOGjrLil8vls1Yin2EMMn2pjWpc8pXRtoDD0NUJbJGzsO0jnFTqxc5jba3pnrVmMrOhDqBIv6+9A1oYhjKkiQAr346VJAPLJaF/l7jNad1ZExB4uo6isqSPy23DK8cil5ML9jatrkMgDD5elT/AGKKYZTkHrWLbyPENwIZDzWvYXqK4KkA9xRYFKxDPpC4yoNZk+mYzgH8q9DsJLe6UAqu7H51NcaTBMp2qAe1HKNTPKzZPkjB/KnixkxnBzXezaMIyfk4B9KrPYhQfl/SpsUpXOGkt2TORVOVTXaX1mpUgAZrl7yDazAetTYpMyzTTUsi46jkVGR2qbDTGGkpxpp+lTYYUlJnFFSK4ZozSfjSfyosSLnmlzTaBSsA4GjNJz70tIQ4GkzTQeO9GcdKCR2R9aM03P1+tJnikSLnrzTCetBPWoyaEIXNIT1puf50hPJ5pgKTwaYW60E0zIz9KQDgRijd3pmfekz6UASZpd3rUWRg5pc0rCJA1GfXmo80oOPWiwiTNID60zPPrSZNFhEoPXnikzTQaAeKAQ7NGab6+1GaBj8mjPp1pme9GeKBDgaUHvTaWgQ8VJEMmo19qtW6cZoAniUY9quQx802GPpwav20BY8UE3JrSHPWtm1gGKis7fAGQK1reLjFKxDYQxDHIq9BFToYuKtQx+g5zUNE3Fii4qQR+1Txx8dKlEdQ0IqCP0FGzHvVry/SkMdSFyoUpCvWrZTGahkXipuBW4oDcdaSTgkCoWb3o5hE5cetML8dagLmm+ZQpBYsbjRuqvvpPMp8wycyUwydahL+9Rl/epcgLHmdeaaWqvv96UPUXAl3GgGowacDTQyVaeKYlSLVIQ4ClxSqKcBxWqQDcU3FS4FJt9a0SAhIoxUhHtTCKtIBnrSfyp56Uw9KLAJmm/jRSE0AJmkJ6ijNNJ60AgphP0pSf8KjY1JQ1sY5qM04n2ph6YzQBG5qJupp7UyoYDD0NJjgjjinY68daAPTtSAjC0uKkC0oWmkBGFNKFqUKcdKXbx0piIcelIeM5qUrxTGGBxQxkRxTD71IajPSs2wRG3pUZ9BUjd8daiY+lQ2Whp9KbxSn+dJ6/SpGhR3pw/8A1UwU5f51LGPH1qVMVEP0qVTQBKvTipBiolqRT9MU0K5KvWpFFRp7VKlMQ5RUiCmLUydKZFwA9qd9KcBwaMe1BLGcUUtJ9KCLjTSHrS/WjjtQK43tTT9acaae9KwrkbZ9aYRUh70w+poAYaTsadxRTAZ/Ok4p9JU2Aj68U0ipCOOKbj3oAZim0896T8aBXIiOtNqQj86YRzigaEx7frRS0UDscERTSvWrGzrTSntXr2PZKpX86aUq0U9qZsoAqshqJlxmrzJ61CydaQJlNlxTSPXrVhl4ppWgCALTlQehqVU+lSLHx2pgRJH2xUyR+1SpH6VMkfemkySNI/SrEcdSRx8VYjj9qpANii471chi5+tOhi4q3HHgZoJCKPjpUyrilReMVKi89KCbgi1YjU0iJVmKOpciGxUXipFT2qVE+lSBayczNshEZ/CniPjnrUoFKABUcxNyHZx9Ka0fFWPpSMKOcakZ8i9TioGBq7MvcVUbuKamaRdyEjrUEid6sHuKa3vRzFooSJ19aqyjrWlIvHH51SlXrxTUjRK5QcE5qIp1q4V6gdKjKcUcxaiUitN21cMXJ9Kb5Q6460uYpRKoXrSheKn8s8jtR5Z96LlJEIHGeMilA5+lS7KNlK4WIscYzU0TEGm7eCO9Cr7cUNiaL8L1fgbmsuH2q9C3fJxU3MnE1I2ytDdKihfjH86kY/KaViLMrTd6pTc5q3KeuKquM8GkmbRjoUnTk0zZVtl9KZs7DmqTNVoQhPyNPVfanhf0pwU0XGMC9qcFqQLx2pQOvFIdiLbxSban20m2i4EGyk2dan20bfai47FfZ7CmMnXgVa20hXii4imUpvl8VbMdN8uhMLFMx9eKYY+1XvL4phjp3FYoNH7VE0daJiOTTTDSuBltD7dqb5HWtUwU1oevFNSFYyzDjnFJ5QrQaH37Uww8d6pMVij5ee1KsYq55P6Uohp3FylUKMUBatGLjpSeWaLjSK4Wl21N5fHPBoCUXHYg20Ban8s0bPai4EG3Pak2+tWPLNJ5dFwsV8Yo/L3qYxnBpChHFArDB0pQOD60uCKB0ppiG0c07160UAMPt0pP6U8000AgH5UlLiloHYZgetHc06igBlIRTj+NJimhDe+KTHXHWnUnrQIafWkxT6SgCMikxxUn1FJigRHilAxTsD05pQKASGY5wKXFOApQKRSQwClApwX3pwX0oAaBTwMUoXinqtACAcU4DjFOC04KcUDSGY60AcU8CjFIoaBSgfnSgU4CgBuKAKftpdtADMDpRg96ftpMGgBmDj2pO1PxSYoAYR1phFSkU0imhEePTpSY4qXGKQjigRXYdRURFWGFRkdaoTIiPSm4qTFJigRHimnpUpH5UwigkjIopxHFNoAKKd06UnNFgEopcUlAAOlKKBSgZoAB0zThSgUoHpQA3FLingcUY4oEMxim81LgdaaR6UDRHigU7aaAKAACnAU4DjpSgUANC0Yp31oxQAzbxyOKQr6VMpx9PSpo443HJ2n86YFHbSgdqvfYy2fLYN+lH2R1OGU0khpFNRWpp1nJOwCqfyrU8P8AhqbUphtQ7e5xmvUtG8K29jAPMjAIHJx3oGkcdofhuaZgXXanuMflXa2GmQWa5crwOTVppBCdkajaPSoPss11JvlYrEOwPH40JlFoahEAVt0Bxxmolmfqw59/8KEMS4EC7gDxx1P0rV0zSJrubzLpdqAZCkdqduxLt1KJdjHhQcn/ADk1UuLcIp3Mc455rob9YbV9p4AHA9a4/WbuWfzBAP3fTI4zTsK5javfhQYYBxnsa5i5V3clz+HWr04kd/LQZZvT/GtnRvDrzSp5+CMj5en40yTn7PS5JQrlTtPA4610NnpbRjaowx7+1dYlra24ECIJJQRgUTxG3BJUtM/PHai1xJnLXNqsBKqB0ySR/Os6RTJnA4HArrX05pmVZAPMkP3B6e/vSS6WrSeRHsUKPmbptA70WFucDdQMxwPX+VV7iDYgU8DvnvXUXixB5ngAEMYxkjPT/wCvXH300kzO2fl6D8aa2FcjGAkknRV4H06Vku4YscHI6Vt6zGtrplupOCw596wLZw82B90c896LE3GmFjHuxyenvU+n2byTpleD0rXW3iuFiNspDquGB9fX2rQsIVCz3E2AEXCcdSOP8aOgkZEi/vvKUDC/zppCO5WXGCcZAxVtY1RZJ3PB6fWq7Kd7FuQvJ+lLYLFOW0KNlSHQ/wAQ7e1WdOhUzMjD5SppW3QkMvMbD8q0NKRpdQhEYHzDHT+dUGpRs4IjL87HavUCrVlz5in7oORniluLJ454jGpC7jnvyKaG/wBNEfYLjHr70IQ3zDE8iHIIqzbSneCO5A/+vWfdSg3koPXjmpYpSEGM8UxIsXKGG7DDhJP8/wA6dbfLOVP8dS3g3WkUhGV659KhCkSq5PClXHvnilcdjPvVKXDccZqBhh89R3rW1iD92ZU+4WrIYkfSqQWHoxR+DxWzE3nQ5OSR/OsYEOM8AitC0m+zuhHKN19hTFYtRMUBVx8p6H096vW0hdTGxxjp7VA7AMM8xt0PpnuKWNGSQoeR257UXEiyWDfJIMEcA1WJKybJF4Hf/Crb4KlWBzj8x61FKjJH0DjH4immIhkJh5HzxHoaduUAHJKHvUSXKwqcrvjPUelPUqVLxYZT1X/PQ0w2HM7AYUgqefWmKyyZ4w4p5QNDvjJwOvt9ai2jG89u4osJCGNlfenK9D/9cUkiqGwBlXqaKQqN6ncvftUoSMsG42N146UIDMVWiJwTtNWIkEoyByO1WpLQxtjIZGGRVWH/AFxUZVhx6UDJktRnjIP8qe1u2Mp98fhV2zEe796SCD3q88MZdX2kA9xQFjFWNbhSG+WUdO1V3jZWwRtcdff3rpXtbe63KMRTDrgfeqB7EzKYZVCyD7kg74pAYDLlTnhvemvgW529QetXblGtyY7lDxxkc1A6/uywx5Z4zihWHYqJIVABPymrG/5cNyvTNV5U2dTlDzRFIEyCcge3agTFljZDuQ/KaA7J8wNSqVddqnGelROhDbTw386BIczBm3bRtNKsyo/7sjHcEUxCNxU0zywWPQGi4FtRG43wtsbuP/rVG+VP70YH94VVBO446j0qYTMU2sAy55p3CxKGHqCvajeVfI+7VSQ7BvjJ205LphHzSKRoLIxwwzVpbs4HyncOvvWWkjModDn1FTxyhXVhnAIzSGmbEFwFxJGwKnhkNMnEbu2VGxjkVR3xmUgEjd0xxS+ZIFK5JYdAe9LUCKe3eBz5T5U9vWo4pT3yrA1bidZztf5XAwKbNHvO1kAb19aaYi9pmpvGwy3IrrtO1dZVAYjNecsjryCas2N08MoJY7c01oB6otwrryQaqXfllDgCsKyvztBByKtvcB161LKTKV4Bhq5rUIsseO9dVIocc+lZtxaKSeKkq5x88JGeOKpyLjqD1rqby1UKcDkVgXMRBIIosNMoHP6Uw9+amZcZ9Kjwahooj/nSdvY040w9KkVw7+1JmlHFJ27UgCij60n9KQh1FN5Ix3opWAcDx3oJ60mePem55osSOJ4puaTNNJ7GlYlgT1xTCfegnrTT+lOwhT1xTSaM0wmkAE8U2jPHekHTigQUZo4o7e9IA9aUHHpSUDpzQAA+tLmkpO1Ahc0ZP4UlA+tArCqfQdKeCO9RjvSg+vWgY7PHWjOBxTO9ANFhDwaUGmD8aev40CHD6Zp4FIo4xUiL7cUAOjXnpV+1SoYI89RWnbRccUE3LFvHmta0ix2qtax1r20dOxDZYt04xitO3jPaobSLJ7VrQRD8KdiGxYouOlWoouakij44q1GnHTNTYVxqRjbzT9gxUqqMUu31rNxFcgKDpTStTkVGw5rNoCBhVeXoc1ZeqczdazkNFKbvjFVXbrViY9apSHrWTY0IWpm/3qNmqMvU8w7E+/3pC/FVi/vTd9UpAkWDJTC5qHdRmlcdiTf6dacr1XyaeppCLStUqVXj9Knj5q0gsWEHpUyL7U2JeKsItbRiIFWnBalVacF4raMQIttJtqbZRt9q0UQICvFRMvoKtlajZaqwkVCKYRVhlqFhRYLkLHHbmoyac/f0qIt1qbDFJpMimk+9NyPWkCHE8ZqNumKM+9NP60hjT9abinZoFICIim7DVgL2IpwT6UrBcrbPSgJVry+OlAT2pWC5WCelOCn0qxs44pQnHOadguVwtLtqfZ1pNopgVyvWo3X07VZK1G68HFSwRTYVE3SrLiq7j8qzZRXb36dqjJ7VI9Qt39azZSGn9KB360H3PWkH1qRjl704UxfTNPFADl4qRT+VRinr6CiwiVTx1qRfaoV9KkX60CJ0NTL7VAnX2qZf0qkK5KtTxdKrpyKsRj1oESCj1oFLQQyM+9JTu2aQ/jVIkbSce1ONNOMUWIENNNO45pppAMIqM1IRxzTD7UgEx7U3FO/lTTj16UDDjmkpfak/GgBvt6U0ipKb2pBYZ603FPPSm4oCww+lMI5qQ008/hSAZg0UvP8AkUUAceU5puz8jV4wimGGvZPXuUStN2VbePioivtRYLlZl4qB14q6y9qiZTSGikV6gU0JzVwpQsfb9aB3Kyxc1MsftU6R1KsdOwrkCR1PHF6VOkVWI4ecAUybkEcdWooe9TRwnHNTqmKQrjEjwKmVaVVqVEoFcEXP0qeOOnRRHPAq5FDjkjmocrGcpDIovWrKJgcU5V9KeAe9ZNmd2xoHFOx+dKKX8Ki4hKUcUYNFSFg9vSm9qdSHODmkIrzDiqUg5rQkGQaoyDrjpmhMuLK5HpTWzg1Ifao29qL2OiCuV5TwaquKtsuc9aj8v2pcx0RiVSuab5dXBHQI80uY1UUUzH603yuKvCE0vk0+YrlM7y+OlHlVoeTR5NHMKxneUaTyq0hD3xR5HBo5g5TO8nrxR5P1zWmIfbNJ5PUUcwuUoLHUsYx271a8ntSiH2o5iOUIT78VMW4pEjp4TvS5hchXcZqIr7VdMfB4pnlUuYtRsikU603ZV7yutMMXoKpSHYqbevrQF74qz5VKIx2607gVgvtT1QYqfy8DgClEf0ouBDspNlWQnFGylcaKuyk2c8Crfl+nNJ5f5UrgVdnXNGz2qyIzQsftRcCts9qQp7Vc8v2NHlD8aXMMpGP2pPK/OtDyfypPJ9qOYLGeIqb5RrTEHtSfZ6OYOUzfKppiH+RWmYPakaDrgChSCxkND7Uww+grVMHFMMA5xVKQcpl+TR5dafk+1MMFPmDlMwxn8KTYcVomCm+Rz2o5gsZ3l0bBV/yaaYT6U+YVils9BSbKueUfSm+WaOYLFTZx04o2etWinpTSnFFwsVdmMimFexqyy8VGVpphYrFeuRTNtWSvUd6bj2qkybEGKTFTbRzTcdapMmxERTf6VKV6jPaoznmncLAOfrRQOlGKBifWk7e1OxQf0oFYZ24pD7U/8qbRcLDccUlO6UlAhMfnSU7HWj1oCw2kxThRigLDcUYp2OKUDii40huOKUCnAU4Ci40hoWnKtOHoBTgPai4xFX1p6rSqKeopBYaBx0pdtSBaMUrjI9tG2pdvpQFpDsRhc0oUipAKUDjigLEYWl21KFoAoCxFtpMVNikIoCxBikxU20YppWmFiIim461Jik20xWIyOKaalxTCKdybELUxhUpphHWmhWI8U0ipCtIRTJsREelNYVKR6UwigRERTcVIRTcUIQgpcU4AUuOtMLkeKAKfjikxSC40CnAUoHFKB1oEAFKBQKcuM0ALj0pQMj3pV5FPAoAj20hWpdtGKBohC0Bal29+1Kq9/WkBGF4oxxU6qKCmDjmgroVyP50h9+tSlaTbyc00AxRViADdio1WrlkVjkLMgbjABp2Eh0cLscxg9eK2/D+kXGpXojycL1PpVS1Wa7cRxIFBOMAYr0bw9p/9mWYI2hyPmP1pN2LSNmwW20u3ENso3AYLYxz61HLI2TJcSNtJ+VM43fhUMtzAYSwbIHU/3qtWKxoo1DUz8ox5MRGcmkgsiw7QQ2/mXQ+cgEJnGBUVjBdatJtjQiA+1XtM0G61+4NxcqYoSflT/wCtXoWk+Hktoo0TKgDnjBP+FXGJPMYWi+HobIedcDe69MjGParWp3EVhavM/wBFUc8+la2pR722KQiRnLNnqRXG6hcrcXZYjNvAPlB/z1zVbEXuzB1csY5Li5YmWT7qDjArmWmmmt3RUOASAB+VdDcW1xPJJNMCWP3VPbPT9K0INNTTNNUyqHupSNq8fSkkO6OX07SlsIxLcruuH+6v93611Ok6dN9naRiFLfxHt9BUqacwnjaQB33bvpXR29oJlw/GAML6+5/CnYRzyWaWcTSLliTgFurH1+lSfZVs7c3N0d0p5A9PwrQnjVrou3+phHAxxgd/rmoMC5LXd0P9Hj5ReucUWEZttZM0Ul3KCksn3VPp61ia1K1vbJaw4+0T8Pj0/wA811FyR9gmu5SVxg7M468BR7etcPNP88XmZZ3kJJ65Uen44p2Ara7ara6OArKF3BWPdvXFcUIxcXNvAB33H3x/+qt/xXdyXlwtsilUTCt747/yrK0LElxe37LshgX5fftQ9CEYfi+5NxqJUEbUwOPaqeiWzTXDBR1H6A1HeZlmkkJ++3FbnhqMxu7DG/Z6dvemkSXNLiMUihAfNdto9s1teJLEW0FraRHc0mJWwOmeMVL4bsmN1DlCWQ7j7Z4/lzVXxJdv/a8mw/NHIEz9P/rmoTu7DsY93Eyp5QUfKQOnrUdzEY0KEfMfm/Ot6eFJdTVR35bj0FVr63VrtlUE7VApjsYpjJs+R0GPyNX/AA+DHqFg5xgtg/r1qR4cRKMDaeauaXbr59rMQBEsuPr7U76AN1eM294d3AZjj8/5VgvGRNPMw5Qj8Qa6vxTH5mZQpCo4x7c1z8J85b5WUBfLBH4GpWwrGXeLi9BOdrKv61JGCrFGP0PtV24gEltHMCMKoU5PocVWCnID9R0PqDV9CUaemBbi1ltZPvY+XtzVfyWJWIkhlbac98GnadIEu4ju7gZrQ1K2dbnI++W6+uDgmpZVhjRrLFdWgU5HKe2DXMXKkZRgQVPJro7yc29/G65CjlvxqhqMIF0cjKSjPPr604sVjHTK9qvrzbKRzg1GbVwD5Y3D0xzUttjy2XP4VVxGhYTeZC0Qx7E09ZnbMTj94nT3rPg/cM2OqkVoXhEgS5jwDwGxQgsWY5C6b2IyvFTo4kTcAfcCqSEtH5qHK9DUtvKqjKEY/P8AOi4rEM8IWQlclH4/GqiRtBM2CQe3vWlIokBMZ561Gyx3EPzHEq1SYrEEdwUchh/9ep1RGG6MjB/hqp5LtkqclRkilhbJOCVYdqL9AsWRCAD5ZwD1BoiXadjEjJqeJVuPlb5ZD0PrUkMBbdDKBvH3G9cUrgXLYBoRC+P9k/TtUdxYLLJgkCYD5T6/X3qexIaPypAPMHQmteWyFzbAkhbhRkf7WP60ILGFZLkmGcYkB4OOuK2bGLzIngYjgcfT0rNYOWG4FZk9uo9a1Io3uwJbU7ZFGWXP60xpdypdQNvUqpDKfpmrtsHmiMZQtVxITcQ7gv71OHX6VLbLk7QCCRjkd6Ex2Ma6tVlQxXC47BvSsu405rVGA+eIjH4+1deISWaKVcg8A1EbPygyS/Mufl4pWFY89mtsLgZK9vaqMqFWwQQO1dxNYwzExMojk6qwH3vasO6gCs0MqASKeD/eFO4jKUb1AjHzd6kEglBjkJEqjhvWnyIiq2wlJKhKlsFsbgeff3oVybDNoYHd98dfeojnaVOdwqeRFI5JVvpTF3RH98oZTwG60CRAGaE5IyKcCB+8jxg9RUpCkHuh/SovL2AuM4x60DJcoy/L0PBFRtCFXKnKH9KQYwccr/KlXdC2R8yH9aQxEyo+VuKkD7168g4pxYKQ8agrnkUpUODIpA5zikBNHIskW08OvQ+tKrbyVJIbsfaqw+6xI69CKfayDO2Q8Hof5Uh3LBY/dcEN6inrM23D8j1FNDkNsk6dmphGGOCfpTsCZYAVxlSCfSoXXrimjKnKnmn7g3UYoQXJ7O8aE4b7ta8GoIRjI5rnWHpTQSp4JpgmdhHdKw4IoaQEdc4rmILllP3j+daEF3uHJ5qbDTLdzgqcc1hXcRya2iwYEiqdxFkEkGkM56VBzVSTgnJrWuI+TWXOpFJopMrmmH2FOPfJ+lJ+P1qLDEH40d+BQO9NJpWC4tH40nf1o7VICj0pPxo9aO1FhXDNIaSkJosIXOfpTSetHWmnFFiWJTaUmkNIQlNOKWkNFgGn2pKX60nrSEJ25oo7UdqACj60dqO2aQB9aO1HTpR25poBKPxpRR9aBCD60v60dqO1ACc5paSlFAhVwKetMHXnrTx/KgRNEM1aiTNQQDmr8S5pATW6YrTt09aqwJ6itK3T1poiTLdqh4rWtl6VQtkNa9qnI61aMrmhZpWtClUrNK1IVH4UySWJeMdqsKOKbGOOalXvipsIAOlLjvSgetLU2AiYVC44qduntUD9/WspIaK8h4NUZ261bmOMis64Yc1zyGitMeDVGZsZzU00nWqE0nXmsZFJCO3BqEt70xn5IzTC3vWWpSRIWPSgN71Bu96cDVK47EwalzUYpwqrBYcKenWox0qWMU0gsWI6sxVWjqzHxW0UTYuQ9KtRiqsNXIhk10RRJKq1IFFKi8U8LxWqQEe32pNtTbeOlN21okBCVqJgOaslfaoXHXinYVisy9agkFWXB5qCTpzU2CxSl6H2qszdqszfhiqjHk1DGhCfekzSZ5+lJ9O9SAoNHrSevNApDFGelOApABUsa0JCBE9qmSOnRr2FWFSnYCER9eKXyuOlWVWnbR2osBS8v0o2GrhXimlKLAU9ntTWQjtVsp1xTCvWlYCkVqNl4q2y4BqF161NhooyLycVVkHXmr8i8VTlGM1lJFopPjJqBu/rViT61XasykNo7Uc+lGOtAXFHFOHTjrTR04pwBFKwhw609famCnqPWkBIntUi1Gn0qVBQSSJUyfhio09qlUU0IkQVZTpUCVPHnHFMCRelL2oH60UEjTTDxxTzTTjFUiGhvrSfWlPSm/jTIEpp/SncU1qkLEZ6U0040w+9IEgpP50nak4oKSFpKKPpQFhMdaKX+VHrmkA09+aaacfamNQAw0w/WnGmZ/KgLBzRSfnRSCxkbR6U0p1q2UphQ17J6hSePiq0kfXFabJ2xUTR/SgEZjJjtUZTtWi0VM8r1FA0ygI+KesXtVwQ+lPWL2oHcqLHxUqRVZWKpki9qBXIIoqsxx4HSpFjA7c1KqUxMYFHYU9UzUqJ6ip44T6UE3II4/8ACrMUR71PFBgc1ajhA7VDZNyGKPAqdEOKlWP2p4jNZMixCF9KcB61Lso29jUCsRAUuO1SBaTb61I+UjpadtpCtIXKN9aQ45FO28/SjH1pWFYiYcEGqcy4q/t4xVeWPIosVGL2M5x60wqT0q4Ys80nk8Gs2zup09Cp5fHNJ5fX61fENAg4qbm6jYoeV7U7yvarwhpRFilzFpFNYeKd5NXBH60eVS5h2Kfk+1IIB6Vf8r24oEXtRzBYoeT1pRDxV8RUeVRzBYo+TxQIPar3lHtQI+OaOYfKUfJ70nk+1aHl03y/ajmDlKYhFOEXFWxHT1j9aOYXKUvJ68Zpphq/5XFL5VHMPlM0xdfemNFWkYhg5FNMQx0oUhcpm+V7UeUMcVoGH2pvk+lUpE2KPl0COr3knk4o8qmmTYpeXxxR5dW/K9qcIjRcLFPy6Ty6vCGl8n1pXGUPLoEVXxDntThFijmHYz/KpRGRV7y/ajyvSp5ikiqsVOEVWVjqRY6XMOxU8n2o8n6VdEdL5dHMOxRMI9KY0PtWh5XU4ppjFHMFjMaEUwxVpNF14qNoh2pqQWM7yuKYYvTmtAx0xo+KakFjPMftTCvB4q80dQtHT5hWKmykKDNWClNK+lNMRXKc8UwpxVkr+VNK+uadwKbL/wDWqNhgmrbD26VA69aExWKrD8qjK8dDip2HB9DUZAx0qkxWICOtMxUzD8qZjsapMlkWOOPxppGAeKmxgYphFWmIgIphHapyKaR+tUIhA6ijAFP2+1JTAbSf1p1IQKAE5puDTqTtQA3HNJjjinUY+lADTSYNLijFArCUYpwFKB2FADQKcBxS4pcUDSGgUopwHelAouOwKKcFpQKcBSuAgFSKKAB1p4GBSGgFKBSgU8DilcBgFG2pMdqMcUhjMUu32pwHHNOA9KB2GAdhS445p4H40Y4ouBHjijFPxx0pMe1FwIyKTbxUm3ijFO4iErTCtWCKaRTTEVyvpTSvHNTleKaw4p3EV2XjgVGVqwV4560wrwaaZNiDFNK1PtOOlNxxyOaomxARxTCOtTletRkUxEJFJipSPpTNvFBI0ClA9qcBxRTENxx0pMU40gFACD3pcUtGPWgBB9aclAHHalAx0pAhwz2pw6d6aM+tOX0oBEgX15pce1CDinEDvSGMPpSqMdqcB2AoAwc9qEA9ApBBoZMdfwpR6jFSB8rgjimBVK/rSFcDnvVoID0NL5B6ggj6UIEVFStLT7YPIMgt7dKiityzhVBJPtXXaPozW+yS4HJx8v8AShtJFxjc0/DunJbwyXVxhIkHGf4jV1557tSVQpbjp6/SpZ1N26RKAsMQG7nAJp5ui5W2iAKrwAoxk+tSlfUbdiW2gjiiWS4+dhwsf9P/AK1dp4X8MzX86XmooRHgeWhHSneCPCfmul3qI3AYKIRxXq1vCkKpuUKAMKuK1UOrM5S0INPsorO3BKY9FxyKiu5mgRmlO1mHA9B61rXUscMZkdc4GQAM1yN9dvLM814pCgcJ0wO2atuyITMrW71ZwLWAtubl+Og9PrWGIftl0trbKRGhy7e/1rRFq8jSNCxMshznHStSGyTT7H92AZXGSccn/wCtU6DMS5hjguobWBQzr87t1xjtTWt1mvjNJykOFUetW9HgLS3E8+Gdm59gPerOlwLcFnIxGhPtk+tMQWVsCVYr++b2zhRVyWDyGKr/AK2TsOwq5ZqkMD3Tck8KP9noBSI3lQvOw3TydP8AZ9hTtZAZN5AjeXaKQC5zKR2HpVPVvLLRWkeFSPDO3bjt+VacsPkxsx+aeT9a47W7l7jU4tKtnHmuMzMD0A7U7gnYo+LHlvmhhsyfscWeR3J/nXO2my61S4LABLSHA44+Xn8zXU6lHJBbeapVYbddx9z6Vx6usHh25mL/AL+ebH+9nJJ/QCkkDOTu5GnF9eEY5+Ue7H/DFWtTgOl+E4bcjbPM3zcYyDzVnT9Pa+v7SxXjJ8yT+YzUHiuY32s+Rn91bKIvqw70WvoT5HIQ2rO6Aqcda6vw3YpJOm7IZ8qB6k1VtYBNqKpGv7sDB4rt/CGnmS/td0R3JIDj6HND0FayJ9KtpdNtL27uAN6kqvtjgVwV0WlNxO7fMzBh9Sa9I+IUiWtlPBEcPI+4jP6V5/cxA6dEq8Ox+b6VEO4JNo0YYF+3iZDmIxqSfp2/OpBHhpZXGBnH51oxWoGn2wwR8qn8BzSMsbsgIIVuf/r/AKGhspIw40DRMrZxyRxVuSFVsoCWC7XXI6A+/wBabPHiBsdd2B26n/CrGpRj7LaRjq3zfXGaEVYtT4vNKulCkCMgqcdia5e3iJkuoyMfuvTrz1rsrJA9nfQAYby0P1571zIhcTXBwflTHHtzQibGf5ebB1A+6cVVtyylo2UHAyO9a9sglt5FHIcjP51nSRNA3mqMlWwfwNUmTYRcb1IADKQf8iuouIftmnRzErvQc/5/KueMKvIkqdGIJHpXV6bEQssYUbVTOPbJHHvigaOV1WMFncYwQB/n8qq3IaawSTndGAPy4/liujuLEecwPzREZJHPH+NU9MsxLDPCxAVhlT6f5FK4GBFkhSD8vXFLtEkuPunPBx/OrYtfLYqW4DYqCZcyMFJGDxTJsNaIK+GyGXqfWr9uY2tCuzK5x/8AXqq2WUo55XGD61NYfLuQDKlc/jVIXQZaZhmAj5RuCvrVoW+IPOg+ZC2GWoIyRMrL1U8ipIJWgkYg/I1FgJYWAG5PxFMuocsJY6NwSUttGCeferqssakkBo2HP+NO4WMzcwcMpw2MGmSBfM3EkE8mr08HOVIGRlTVZI85Sb5STge1AtCSOQLtVh+Na9myzfupRyfut05/xrHt4t+YWJ3j7p9cVpRswgCsMSIOeMZx3+tAWLfkkSYY/vR17ZHr9a3LPZKgibAlC5X3/wDr1RjkW/gXGPtCjqP4h/jVmzUtOhOQRx6Z96ExoufYY7xDDMBHcgfI+Mbu/wCdZkKy2d1tbKyg4BHGRXWvAJ7UEjZMnP19xUUVrHqEL/IPtERH6f0oCxnaTcPPLIqsEmDZwR1/+tWokALsGUq+M1Q1K28ny7+AMjD/AFgxjB6Vs6fcrdQrIwVsYDD/AAprUGytbhVuBFdJlWGA/ofepp7ISMYiTnHGe49M+taF5aq0IeEiROPqBnoaFMc0aKSVcHIOO4ppXBs5fUdO85GR0IlB4IPXH9a5a/tZHLQygl0+6/r/APXr1Ce3W5OxiVkHRumfesHU9KLMQ6EOeAfX3pNCPOXtvMG2ZdrdC1U5bVoTtYgjqK6fUIGt5WiljOCOuOtZwhUExsu5AO/+NIVkYDR7VO8554NIWfG18YzkZrVvbWOOM+WQ6emOhrJlWQfN95aYrAh2sd5+WlZeCUOUNI3zRiRunfigSHGEI2n2oEMKbMFc7SOaljYIoDYKnj6U8L5iYB5A6Y61AMHPYrQxrUesYViQSFJ9M0wE7z/d6GnI/mEKx47e1Rt+7cowP1pASxN5chRx8j02eIwycH5W5FCnehXHzCneZ5kG1h8y8Dmiwh6N5seCRuUfnSqedpPOPzqCNsdOCKnYh13Lww/nSGmAPzbWOCKcT270xh5ibh94daaj5GDSC5IG4I9aT6UmRSZx06UAOB5p6sR0+tRZpQT60XAvQXJXgng1M9xuU+tZqmnBueaBjp/mycVnXEfXjpWgTmoZYwwNKxSdjFkUjPFNwavzRdaqMmCcVNhkJptPYYph61Nh3EoFJzzR/OkwuL9aTpSUcVIBSUv9aTtQIQUhoJ4ph+tDJYHpTaU/Wm9ulIQpPHak9cYo/Gm9uaBBScY70p9qT8BSAT60fQ0n4UYoABx1NLSU4UDE9jRS0AdzSEHak7U7FIKYCduaP5UvP4UvagBtKKCPelA/yaBCinItCrmrMSdxSFYfAmBxWhApqCFPSr8KUCLNuvryK07dAap2y+1adsvtzTRnIvWycDNalqoqlbqOK07VeapGTNO0XjpWjEKqWqkLzV2OqETJUgqNentTx060gHjFFN7c00sKkLA3Q5NVpD170+Rx2NVpZMA1lJDSK87cVlXT9eau3EnBOaxbuXk896wkhognl681Rkk68ilnk688VRkl64rJxKSJTJ1pN3B5qtvpyk+tRylpE4NSoKij5q3EmRQolJCAYpQKl2YHNJiqsOwiipUFMUVKgqkibEqetWIwelQxirMXWtoohotQirsA5qpCOKvW4/GuiKIsWYwMVIFzSIOOlSqOK2SAbt600rUtIRxirsBAw4qB6ssKryCpAqv3qtL0PIqzIeTVSY8VLCxSm71UkI/CrExOTVRm61mxpCZpQaZmlBqQsOpwpgNSD3osIcoqZBUK9OtTp+tMCePrVhBUMfSrEdNASItPCHHSlQVMi8dKaQEHlnHTim7O2KuFeKaV5PFFgKZU46VEy8VeKDtUTLU2Az3Xiq7DrxWjIuQcVUkWoaKRRdeDnpVGcHpWq68EVn3CnmspIpGXJ1PXmotpq461CVrMZBtxRipcYHFJjrTSC5GAfX9KcOlO28e1AFFhXEFPXmkA+lPUdqgdx69OKkWmoOtSL7UiLj19alXpmo1z61IvTtTQrkqVYj6darKanjP5U0FycelL/KkU0tAhp6Uw084xUZ9qaJsJ3Oab7UpppNUTYSmk8dqXPXI+lMPepGojSaYTxSmozmkUogTScdvypPejjqaA5RRSjpxTQaB7dKAsOB44oJGOlAPakosIQmo2bjNOY8dahduvSnYdhCw55phbqaYSfWm5pWCxJmimUUWHYUp2xTDHxz2q75dJ5XNetc9EomM9qY0fWtLyewphh/zii4GWYqb5Q9K0zb8Ec037OfQ07gZ4i/L6U8RVeFueeKXyDjpRcCksYqVI/SrSwc4qeO2PoaaFcppEe1TJAevNaEVqcdKtR2vtQTczY7ck9KtxW+BwDWjFbetWUtvagkzEgNTJCfTpWmltUyW3tS5RGatv7VKtue4rTS249qnW1z0qeUaMb7MKaYPatw2hx0qM2h9KjkNFymIYeDxSGHjpWubX2pDa+3FTyMehjeVSeVx0rY+y9sU37L7UuRisjI8k9hSeVWt9m68UhtaXIKyMnyuOlNaHPY1rG1Pp9KT7L7VMolwSRjfZqPI9q2fs3B4pPs3OcVzygzshJWMfyPajyfUGtf7P2xTTb1nZmiaZk+VzjFHkVq/Z/alFvSsyroyxDx0pRD7fnWmLf2pfs4xxilZhdGWIuORSiP8AOtL7PSfZqOUV0Z3lYo8qtIW9KLf2o1KTRmeVxwDmk8r2rS+z8Uhgx2o1C6M7yvWkMY9K0DB7UwwnnjipuMpCPt2p4jqyIsdKcI/y70D0KuzuB0pNlW/L6nuaPL74pBYpeWec800x1e8v0phj600xWKWzjFJs46VbaM0wp7GmmKxX2ik2VY2+gNG2rTJsVvLFOEeBU+32pQv1obFYg2elLs9asbetG32pXCxW2elL5dWAlOEeaTY0iqI+KXyqtCOnhMdqlspIpiLFOWPB4q2Ix6U4R0rsdioI+DRs4q55VJ5dFwsUylIU9queXSeWKLhYotHwajaOtAxjBqMxCncLGeYqYYhg1fMZ60wx9aLhYz2j4qFouPpWi0XtUTR00wM5o/SoSntWi0ft+lRNFVqRNigUqMpV5o+tRmMUXJKDoemKgdK0XQc+1V2Tk00wKDKCelRMvWrjp1qF19uO9WmIqsOvNRkcHNTuvODUZFWmSRY47VEw9KnI71Ew6jNUmSRfWm08gjPpTTmrWohh/lTccGn/AE6031p3AbSU6ii4DaSnY44pKYDcUmKfikxzmkAwikxT8UAYp3AQCnAUYpw6UDSEApwHH8qBTgKAGgcU4CnBacB+NIBoXg08ClAxTgO9FxpCAU9RQAO9PUegqbjSAL7U8Lx7UqrxT1WlcZGF4OBzTlXinhfSnbfzpXGkRhcUAdRUoXNG3ii4yPbxSAGpdppNvHJ5ouBFjikxgcipsU3FMViMCkxUmOvtRjtTTFYixTT7dalIpuKLgQkUhBp5B5zSEVSIISOvpTDjpUxHoKjammJkR9KaRxzUpHemEVSJZERgU0gc8VKRwaYfpTRFyErSY9alIppXrTsSyPHFNIqQjigj6UwI8UY5p+OaMUCGY4pcDFPA9KCOKLAMApQOeKcF9KUA0hoQCnKvNKq8GpEWgaHxrSlevpUir8tGKkqxDj2pQOKeQenakC0xWD6UuDinBTUsaZPNMQirxUkaEtxU0ce5gAMnpXU+HPD5upQzrlB19qL2RUY3E8L6Qqhry4xtTBUY6mupWNYoWnuyN7fcTHT3qvIyCZYLRRtTgnHXFSSL5kvnXufLT7sefT1qErmktFZFdw/l5GERvuj19x6123gHws9xKkskZAOCWYday/CehXGu6it1cgraIw2rjqP8ivctMgis7dY41AIGBxW8YmTkQRQpayxxxr8qKMYq45Ek25jhUFLIVXJwDIfauY1/UnkuV0uwY+Y2DI4/hB/rVbGbdy7qeq+ZMLe1UO2eT2AFV9RjeW3jhIDzPgn2AqxYxJCqxRr8qjLuR2HvTziPzLmQgyHlR6egoSFsUvL+xKIYV33MmBn0/wAKi1gva2O2Ml7lwEBH5dPrWlbQNsaZv9a4yTmqzxO94JGxshG0Env60rDMv7P/AGZpCRy58+XA98+tWbqP7NZwQIR5kwGQOympr2IXFz9pnkVUiA2A9zVVna3dru6AZuETPr/gOtC1EaMse6FEIIVFwceopiRrGPMfknhV/wA/rVsMGhUDkFRk/rmql7OI1aQnCqPTp3ok+xSRy/jTWo9D0ue7kIM+MRrnHJ4rz34eC5uJLnULkkz3JyuT0Aqv4/1L+2L5juP2aE7Qv9a6jwXaGDRUuJF2qx2j/dGKXwoyXvTDxY3l6XHaBsyztvfB/hz0rh74o93Bp0ZJS3GJCPXqTXXXcn2mW71Bx+7Q7IgeeOcf41x0EMvn3QCnzZ+F7nr1/GqTNGbPhWIR2Oq6pLhQwKR5/wBn0rh1RZnlld/mZt/Tqa9G8SJ/Zfhq20tMCVwHfHof61xDRg3MVtAmTnBOOuTSixD9Cs2WL7RIuA7DHrwf8K9K+H1uou2lk6iIkZ7EmsJrONWsIogFjDAn37V1GiyR6fpmoXEjAEPtUe3P+FTN3QS2OM8ZSm+1S4wCwDfKB2/CufNq5kwynYFAC4689a25Y3FvNdFzknKt65z/AExVW3LbWlLbjjJpJ6WGlZGukZKWpHAWPbj1xVGHYWO4DIyF/P8Az+dWdOmZ7BZDksBx71V8oOV/hIfP174/WgaViJ4w4jVlGS+T+eKL1QdWSMEAR4UfzqxGvl3DvKMrG2FHqaq3aKbiWViVJGB+B6/rVrYTuXdHlV7u8ZsY8vp64NZluA+o3Ck7UKnj+laOhxATS5I+aM/jVOZPL1OIx55yOnUe9QnqO2hBp8EYeRUXIJ6YqottumuI9pOHzzWjbuI7qIr8oXlvzq/qEMcV15kbDEvp35/wqk7bkWOYaARMw5GP5V08ipFcxKg/dPCpPPQnvVW6tEuJXWMkyEencf0q75Xm20ZP30TZ+VG41oQm1RJ1UktG644HUjv+VZXleRbI65LJIe/UD/61dBY9bcnBU4z744pmoad5ccm0ZUnI/WjZDscrqFvwsvGGPzAe/wD9aqMkCDzMjoM10a2yMjRYBI+U/wBP61SmhEgYBQDgfpTXYmxhCHkuxO0rjpS6ewNz/dBHArUv4AI0I+6F7VkQA/a0PvTFYlkAjnVx0BwcU+No2lKt9xunsaWSPAY84Pb+tVZoyFZlzuGDj1oTJ2LRBUmGQ/L1U1YtG2sY2wVI/Wq0EgmVd/XIFXDDtYBhtcYI/wBoUXDcR0aLcjZMY6Hrj/61Rq6uxjfHHSrM7mOXceUwPxFR3MCkJInAPegLCIgVuuJF6E+noa1IJ7m4ZmaMStgbhjqBxVCPG5EuBhez+g+vpW1pUcsN4v3djYG4Dgj1poSKUcXly74MqpOceldPpEP9oLtUqk6jkHjdWdqsYjutsoAWTkOoxyPajSHkW8REf5lIwRx+NFgTOltJHZjHL8kqcEHjI9frVy0to7W9W5iYYPVev4VJEsN1CVnwJwQQ4HX3zT5bEsBGsoD9RnjOKdrjTNK8tlmibbBmCUAN7e9cBc/avDOrAMpazk5Bx716n4dulMb2VwgbK/LxnnvzVLX9Hjv7KW2lQgjlTjPI7inexLuZ2kyxSxiWM+ZBL+n4VbgtQCyMvyB8r9PUV53peo3XhbWPseoKWtWOAe3J616dY3URWN1Pm20q4B67f8BTSFdjZYkltirABkOAR/Oq+5ZIjBPyw+63TI/xp8yyWl43mZeNiMe4qWdAfmjI2kD9KLoDm9a0sOm4oZFAx06VxOrWUlnkbWMD/wAQH3ffPpXqXmmQ74ycDh09P/11i6jaDkKoeJj908daVgueZRw/ZvmUiRW64PUf41SvbMbWuLPJjH3o+uK6fUdN+yzsqDarnO08Ae/FY/ktb3pB3Lu+8p6EHuKVhnO44cEHyyB2/WonjMJwOh6Y7+9bd1bZdhEmQ3T86zrqNrYbZR8v8JprXURXXKLyQG6jmnH96pZRhwOR9KhdW+8efSnKSrBx070hDQyujfKVbPP1p7qZoevzCkmXypNw5RunFMbKPuXODwaEgRBG7I3fPSrQO0bhyGxmoJAN2fWlhfy2+flDx/8AXoQD3IVg6D5aeWw28dD1pgx5hT+A8j2oU8Mh7Dg0gTJwcHcMYP602QY+YdDTY2A4PSl/h/2TSGAPHtQDTBx0PFL/ACoAeDSrTM8Uqn16UASj2pDQtL2xQA5DS/zqNaeDQO4yRAwNUZo8fWtL61HIgYGgdzFdfWoG+vNX7iPBNUnX161LQXI+cc0lHrSVFhpi/Wk/Cjt7UdvWlYA9aSimmpATPpSGlPekNDENP86TtSmm/WkAUhpaO1IQ360lL0+lHPagBBSClo/CgAHtQKSlHegBR19qX2oxx70YoAPYde9Liil9RQIbRTgOM0evNACY4pQKBSigB6Vbh6VVjFXIRUiLcA9KvRAVTgq9BigkvW46YrTthWfbjjpWnbDtVIzkaVsO1alqvPvWZbVrWuM8dKpGRpwDsatJ04qvB07VYU/lTETKcdetOzUO4etIX60gJWbAqu8nWmySe9VXk681LGh7y9c1VlkwDzTJJOoBqtLL15qWhkdzLweeaxrqTk1cuZOuKybl+tZSQ0itPJ1Gapsxp8z8n2qsZOvNRymiRMD69akQ1WRs1ahXPFTylJFmDrWnAvy5qnbQ1qRJhaOWxpFETLUWKsuPSoiD3pWG0NUc1Iopq1Io9apIixJGKtRCq6e1WYu1axRDRbhHFaFuvFU7cVowjiuiKMiVenFSCmLTxxWqAXFIaXtSHFMBjdDVSbvVpzwc1SmbripbBFWQ9apzEYPNWZD19KpXB681DZSRTmb1qo564P4VPM38qqMTnI6VlcqwuaAaZnFANTcLE6nipAaroeOKmU/nTTIsTLU8dV0qxHTTJLMdWIx6VBH1qxH061SAsR9anTOKgjqwvSrQDscU2nfjSGkxXGH17VGw4NS1GelSxkDjrmqkvWrrjiqUveokUiu4GDWdcjrWi/eqNxgk1lIpFBgKiYdasOODioWHp/OoSHciIpoH061Jikx9KtIljMGgLzT8elKB+dS0JMao/wAmpFXBpQPWnqPUVmx3EA4waeBQPejt0NSK44frT1PFR0op3JJV6e9TRmq6tUiHmi4kW0PFSA8fzqsje9ShuDTKSHn61Gxx06UhY0wtQh2Annimk9qaW75phb3qg5RxPWm5603PXJpO/wBKASAkfjTD1OKeTzzUZpDsNPTmjijsabmgLC5pc0lAP1oFYdmkJHrTcj3pjN1HamkKwjtiq7Pn60SN+VRk0wsGaTPWj9aSgY7NFNwKKAN5YevSniAYzirCrUqpXbzHo2Kv2fvinC3GKuBOKkVOOlFwsUPsw9KcLUY7VfCDtSiPNFwM/wCyjHApptR6VqCPtSiLpVJkmWtqO4qzFajuKurF7Cpo4h0rRENleK2GelWY7UelWoYvpVuKL2rRIi5UjtRjpUyWtXo4qsJF69KdgM9Lb2qdLbjpV9Ih6VIsXNAigltVhLfjGKupFxUyRc0WC5QFsCOaabUdBWsIvWkMIosJMxmtR6fpTPsoznFbJh9qYYqXKO5kfZBjpTfsg7j9K2PK4pPKo5Q5jI+yCm/ZOtbHk+o4pph9aXKHMY/2UelNa2HTHFbBh4phh4qeVDUjHNrTDbVrmHjkUww8c1PIi1NoyDbjFNNv1xWt5IpphpeyTLVVmV9mFJ9nFahi+lNMXtUexRSqsyjDz06UeTx0rSMVRmLjip9iUqxnmKk8vir5jphiPWo9iUqpT8uk8v2q2Y+OcZpCntU+xLVQq+WKTy/UVaK0zbx9al0ilMrGP0FN8oelWyvXFMK9qydMtTKpiFJ5XGatYpMVDiWpFQp603Z6irm3tUewVFrGiZW2+1NKf5xVrZ2xQUxUDKLJUZTrV1k4IqJk9RRcCrt9KQLVjb1wKTaCKpMViALmnhKlC+gpQtFxWIglGypwnFOC+tLmCxAI6cE4qYL+dOCUr3GkQhPanBBUwWnhfai5RXCU7bx7VOF7YpdtICuE49aTaKsBe9G0UAV9tJsqyEo2UAVdntTClXNlMZKVwKRT2phSrZTrTClMCkyHB4qFkq8y8GoWWhMCi6elQstXXXrnpULKO1NMmxSZRULLVxl7c1A61aYrFSRarOOvpV2ReKrSL+VUmKxUZeuKhZR09asuKhdcg1SZJUdfyqFh6VakHXmoG96tMlkJA/ConHXFTN3xUTZq0yWQsODzUZ6cdKe1MP6VaJG4HPtSe/FKRRTQxpFJz27U6jFMBtFLSYouIB70n1paMUXASkFOoApjQgGacKAB2pw9qAEUdzmnqKAOKctAAAO9OA4pQM0oFK4CAU4DtSgetOAI4pXKQKM9akUCkUYqVaVykIoqQDmhR/KnipuMQL6UoFOx6U4ClcEhoHYCjHtzThinACgZHtpMce9SYGaMUAREU3AHWptvtTSo79aYiLHWkxUmKbimhMjx7UwjqamI60xhx0poViIgUxhz7VKR9aYy+lUmSREc/hUZFTN06VGfamhERFNPpUhxg+1MPfNUiGRnr7Uw8GpDTD061SIY2kx1zTiaTjFURcZjk4pP6U457ZxTSKdhCdyMDFJg0pozQguL0peMcik7U4c0xXAClVaVRzUoWkUmMRalRcA4oVfXkVMg9RUspAq/JnFJtqdV+XgUzbz0qSiLaaVVxx3qQL7U9UzQK4xV4xjmrNvA0jBQvX2qa1gBIzjPatvTogZ0t4lDTSEA+wp3sOKuXfDXh2S53zuNsUfVjXS3JMNmtpZYBc7c+uO9TXExtLeDT42Kjhn/AAovoWM0UdmN0rjjjse/tRa5qtEUDCdPVURt7vgE4698Cuh0fQZdVuIzOCkIxn3NXdJ0ZY2iNwBLcHpjkLXpOg6MLaESS4L9h6e/1rSMTKbLOhaVHZ26hVCqBgD0HpW0AqoWOOKWNP3OB1qlqU6WdszyvwBk/StHoZXuYfinW202zbyPmuZOI165PrVDwxpkltD59yd95cHJ9h61S0+CXXNaN9c8W8RzGD+VdrbokcTzykKoX5fYDp+dTuK5Rv1KollbnEspBkPoB2/Ko5Yt11HCxOyPDtz3/wDrU/Tn3STXbEfMcrx0AqeIIyzbjiRhkn39KdrCXmSP9wsDiFeretZyFLlfOlYJAOY0z97Hf3pDMJI3gDkQKfmPTdj+lY88jXUhZXCQp/COOB3pWGTxQte6mjSZ8qMb9vrj+nSi7BudWELf6uI8gdsntS6I22G7v5SfKU4HPYZpNE/1E97cjHmn5R+NNKyC5t5XzRAoBL4z7L6/jXH+Or11YW0RONuXP1yMflXSSXC28bTuB5pHArznxJqJnF1KQCWHye+eBz+tTuEXc42xsF1W9vOotbbDnr2OPxr0SS3f/hGoVH7tQyxgf73X9KytN05LHRbG2Y7ZLmYFyeCVH9K6q9SL+zxAy5PmA49h3/L+dNx7grJaHL31kHh8oKUjTAA6dT1PvgVDoOnx2C3ms3ajaiEW6EffcdOvUVdvZzHcXd7dMPs6gOqY6gcACqdzdlvDKz3bMZJZ1wgP3QSTj2GMVF9SpJtGLqdvNdo97dMfNlGcd/8A9VUNFs0/tSH5ckHLH86344M3ImldymMbOwzxSW9lHa6gNuQHO4Z/lSvYaVkWbaGOWUgcPHMAM/3Qf/rg0uobY7HU4yRsDgcH1J6VPZwFrqcL1U569+lRaxEiPJE4IBG4/Umkn0HYydQtY5bYquFQhQvP4fnVE2/2WA5B5HIx/ntW1LBvmgCj5AM+nTv9ar3yma6LxqPK4AH+fpQmNrQz9KU/ZVjCnavXjPU1CsMkkj9VCy49OK2dOdUeMAAHfx/Ko7wESXIKgN5gIP8AezxmmK2hm3g/f7DkKDkn/GqmooZLhhjCKvH59auX/M7liQpC9+uOP6UxjmQyMBt8sgf0/lVITJtHVWu4QATlGz79qozuG1GMLn5W9Pc8Ve8P5Ek0rA4hAAH1znFU4j5h84gcSfn82cUkIqopNy2AOWx0961Xi82CSBsb1AZe2fpULW4a83KMfMc/gaeWk+0hiAP8BTbFuRGV7WCRVx5rKMt6CptFkV4mSYkqzZz6U3VYGS4jfgxyJxjt9fek0bOydR/CMiqSEaVhGEtotuP3bMfqM10Oo28c1tFMqgEqB+dc9pqM9qcE8SY/OuqEe/TVXdggbenWlfQo40WZ+1XThT8oVunvioLuyK3LgR7Q8W4fUV04iAumTacugyfXn/8AXSXcH+mxwlcrsIPHuaSYvI4GSDNmuc7uh9utYaxLHOjfw5GK7xYYlhvI5IyQMYb0zXIXEMYkGc8OP51RLRC6Mom3g4JwOKpXnyKIwfmHJ9810M8O6GSQqdiDn2rG1GJlkbeBhl4PHSmhFBCYypyApxz6Gui0ryZoljupuTnYw5wf8K5q3kTd5c4+Run+NSW9wbWcwTH3Rv5c0WJN+aMxloJsbc4V/c1FG3HkSZC9PpVuzP8AaNqY5MGVBkfh3qrtKM0MoG4YCnH6Ghdh20GMhhkNtOMxn7jemf5itTS7p7LKOS0Y5GTVC5Ytb7nHzJ04pscoaHc+SpB59PrRcS0OuNxFeQAxBXXqpPb2qvdWZBjuLTIIIBXPP1+lZ+jlYYwYDnnJq+/mkHyXKnqvv3xTuFjc0ySa5jEQIZ88qByTW/aqt3ZmGeT/AEmLlGx19sVxNrdTxhzFhbhT83Yj6Vr2GpfZpI5JMZbhsjv/AI96aC2htWImju1lLlXQgMucZwetddeXsYADgktwSOetcNe36C4STeEDd8dDWnpurJ+7S5wy5AHt7VVkSZfjXR/tsRIQnjhsdDXJeEvEkmlag2k6kx8knAY9vf6V6fPcQ3BaA9z8jetedeNvDyySMyLsuF5jYDrTWmgmrnpJmFxZiMjO0ZRs1lxXixTNCOuPnQ9D2yK4fwX4oaE/2bqTEOhwjH27ZrotQdkvYrkHKHg+9S0ETZlKx7J4X46Mp7j/ABqnqKtMoMbbFYg7sUxpUmBEfETDg9ap212YpXtLo/uz9w+h/wADTY0rDdRsXntnhaVfMI+Q4wDXJ3UTbDBecTLyjf3v9n612MMiM7QMw3fwMT+YrG121W6RwwPmRgZIGOB0pW0GcxEwxtKnd3qrqMSIyiQB4m4Pt71YVt0bbT+8TjOOvvVOSFkiXzXIVj9cZqb2FYxWUQO0eSYycoarM7q5DcD6VpyQhXeF8FM5U1TliLqUb7y9/Wn0JCFsxNGeVPTNNRTgq2OOBUMDGOTYSemKmw0b5blGODRcNiHYVTBPP9ajTdk56Zq1cxlcMOhqlIxAIHfqaVhosqV2YZsDtSMo3Zzx0plt80bowzxxRA2CY36dAfSi+grEoxyO9OU5XHcVDhlbB/CpFyBn3xSGFA7+lKfUUg4oAUU5etMFOHf3oEiQeopRTAf0pQeOKBjuxpQelNzQKdgJQaTiminA9jigCOaIMD61nzwEE8fpWqMe2aa6BgfelYDnXTaTUZ79a0ruHaT6VRZetS0O5FTc+9OYelMPtUWGhc0nY5opOlKwBSc0ppPapAP502newpOaLAJj0/lSc9+tL9OBRjvnrSENxSdKd9BS445oAZij607HajFADRQPxp2PWjFIAA9adg0ADuKUf/WoAbx+NHPan45pPegBP5UgpaWgBAPSlFIO4pwHoaQiWKrUfSq0XX2/nVtPypCZZgrQt6z4fer8B4+lBJp2/vWjBWZbtmtKA00ZyNW161p27etZFu3vWhA/uatGTNqFvlqcOOx6VQgf5eTUu8UElrzB6/rTGl71WMnNRNIfWkNE0knfOaqyS9cGmSSdRVOSXrikNIlll96qSTDk1DLMRmqE8x55osNK5JcXHBwaybmbrzTppcg81QmfJqeU1jEZJJnqeKi3UhpUTd2pcpooli3UmtO1TJqlbR1r2UZyKfIUkXraPAzirYXilhjwlP2HtUuJSK7Dg1CVNW2XrULLWfKMiA9KcopeKBQkS0SpViHk1WTr9atQirRnIv25rQh6VRtxV+KuiBiyYU4dKatOrVCFpppaQ9KVwSIZTxVGY9auS9DVGbvUNlpFV+lVLjvVp++KqXGdpzWTZSRny55xVVjjJqzL3zVVuvFZ3KtoMJ55NAPrSHP4Cme1TcViZWqeNqqL15qZCaXMQy5Hg8CrMVUo2q3CatMhlyOrCdKrRmrCGrTEWo6nB4qvGamB4rRPQQ/j8aTNJn3FJkUriFphpc9aQmkyiKToaozdT6VefoaoXHfpUSHFlaQ+lU5ec8VO5/Oq7d6xZaIGx0qBu9Tv061C+PypIGRUY9KU/SkGMcU7iAfSnCkGKcKTYWHAU4Cmjp1pazYC/TrSH60opOKkmwo9qOlJijvQSOHHWnofWo6cDimhE4binBuOtQA8cGl3cdaC0Slu3pTS1Rlu1NJNUkWh+Rzkmm5PtikzTc8U7AOpc8GmZpc0WGKen1phpT9abTC4nPSm+xpeB/8Aro9qBAP5Uc0nHrxS0EjW6VCx9alaomwDzTsBC9R1K/WoqQB/jSd6XHvS49aAE4op1FAHXKvsKmRcdqagqdRx7V1npCBacq0oFOAoBiBfanhRinAcdOKUCqQhFUU8LTgtSKtWkQ2MVBU8cdKi1ZiStYoi4sUdXIo+OlJDH7Vdhj46VaJuNji9qmWP2qVEqVU5piI1jqVE44609FqVFoAYsY71KqVIq8U8KKBEYXil21KF7dqdtoEVinWmmMVa2U3ZRYCt5Y6UCKrISl2UxXK3lcUhj4q1spClFhXKZjHpUZj61dKUwqOTRYZSMfNRmPg1dKU3y/alYaZRMYqMxVfKUwpRYaZRMYppjFXSntUbLSsO5T8v0qMxjmrpTmmMvFS0CZSMfFMMY9KuFKjZD+FJopSKhQdPSmFKslaYVqOUtSKhXn2ppXirJX1qNlqHFFqRBjim4/Wpcd/T2pprOUUaqRCRSYqUimEetZSiWpDP6UY4paB39qxlE2jIbt9etIV6084pKxaNEyFl44qJl5NWiOvpUTrWbRaZX29hSbalxz0o20AQheacFqTb7UoXigQwL2p4WnqtPC0rgRBacFFShKcq0rlIjCZ6U4L7VIEp4U44ouBBtpdvqOKsBPWgJRcZX2+1ATtVjZ6UbKAK+yl2D8an2H/IpQntQ2JFfbTGTjpVor6VGyUrjKjJ7VGVHPFXGU81EU4oAqMnBqB07VeZODUDr2xRcCg61Cy9avMp5qB0ppisUXWoGX1q86c1XdOwqkxFGReDVZ161fkXrVZ1/OrTCxRdeoqB161ddeMCq7r1/I1aZDRRkByarMDV2VefcVWcVomZtFVvbGKibpxmrDjOarnvmrTJZE2OajNSPUZ71aFYZ69aMUvaimgE7daPoKX15pPyxTHYMelNp340uDQIZzS8Uv8AWj24xTEJigClxTgPrQMQCnAcUYpwFACAU4DHSkxThSHYUCnDikGfrTx+HFAAKeMd6QCnL70ikOUU9RSKKeopDQ4CnLQtOA9akaFApwFApyikUhMUuPWnUY/Ki4WGgUYp30NLihMQwDvTSO2Kl7EU0imIiK0zHWpiKjI9BTQMjPSmnnPSnkUmKaEREc80xhzxUrD86jaqIZG3vmoiBzxUrD1phHUiqRLImHpUZHBqY96jPpVIlsi7cUw+9SkUz14qkZjMZFJ604d80lUibjD6ZphH1qU/WmGqJG9aQClwCKcooEhAKevtQo6nBpwGKBp2FUetToMGolGeoqwgyMelSNMAue9SIvrQoz9alRfWkVFjlXC45NNKj3qxt+Xjpim7eMVJREFp8aHoq5PapYYtwJqzAqofl6g4poCS0tWDgE5c13fhbSorO3e7cZcDkkdO9ZXh3TPtMg2rubGSf610t65kC6fagLGmPNfp0pb6GsY2RDbrHMbi+uZAFHKj+lXvDUc8s7z7Dl+E47f4VhXsoubyKysjmNSAeMZr1rwrpCw2sbSgAhRVpW0J5ty94Z0rFx5ko3SdScdPau0hj2D5ugqppsASPeBjPNXJW2xknGAM1rFaHPJ3Fd9sbN6dK43WGk1O6NvHkopG8+vtWrq+qqtvsgJMrcAen1qPTLE28Crz5khyzH0Peh66AtESabbLHbiNQNgODx1p2s8xCAHk43Y7AVfnCQ2yrH14/wD11zmoXIj3gtukbuP4R609EC1RZhuFWKQx/wCrReKhEgis5LidvnI4HTk9KpJP5cQj2/M3JX0UVka3qD+bHbAgk4LfXPFFwsS314yRBAcbjt6/rUExaQxwwf62TAPsPWs+/uQ1wNxARMAY/iNaNpKbKM3b4M74VF659x7UkhGzfIogt9LiPyqB5uPUf5zU8cyIEDLmIEbR2J9ayI5TECiMXmmI3P8Azqa7vQsqIQMKoP8ATH5ZofYa0RS8WaisI3HducEhc9vXFctpVudS1GNLn5hBiSQ9s+lT6nqaXeo3F3IoMFvwgPfPAwP1qW2J03w7LIwAvL1iox2Dc/yojoLZFvTWTUtZmupP+PW2OyP04/8A1VuatKsOmTzSqcBBnA7k9qydCt1t9Nihb78pBP581reKGjFikbDiQ8fQc/4UpMpI5HX3862JZhvmYIijsOn54qjrwO3TLVSMlQxx6g45/CtW4sgbm0xhmC+Zj9M1BPbCTxFDuxiMYHsayutSxxtt7gH+6B/n8qmuoQ7Rhid0ci4PqK0hb7VBYclsD2ApLu2GIgMMxP5n/OalM0shdOgDX8qEHO0fjzUGs2Ilv5cnjywf51saLGv9oyZIzsA/EVJeWokuJXBP3cD8M0hWOaEPz28aD5fLbt1NVLeExSlCowW2n35610FrApn3NjYox19aqyRYd2wMs2wf1NNbDMlLRdzsgGYpRz+NN1SILLLKcbeCPf2q9JBIsVyoz8zjH4mo9XUCEJtHQNx78D9KpMmxy06NPLg/d7/QVG48+4XDjYFwOOgFaoaNZwgUEBNpyO9Zc8XlhXU9BgAUEWH2JVbS7O4qHGB9Sf8ACq0S+ZaNjAIfH1q3dW5htIFJHzNv2+vamRRMsjwFeThvz4qgsuhE/DnOfl5J/Hv+FLcofP2kjbtq06oZ50I6gDp6f/XoMfmykgHO0Af1poLWJZ0C21tn5kZOfqCRn9P1qvpi+VcbVUEHrV8W/nWduFycNsYnoATSWMQW4BGCFkC/UZo6CsXNPtxJ5gUEHcMjp1HatqzR1gkLH91nJ9wOOtKlgYb+42gIpIZQP8+laVlA0sEiRp8gH4VLbsFzK05o/tVxJIw4TC/hUkzBpbeQqN0gKjjp3zVs6eYbuNo1BXaRjGc/WrrxIy25GBhiPp2oWgHnusRtBaSPghi+GA7jP865q8to2aNkO5Wwc59+/vXoN/p4uRcwk87iw/xrzqXdbTSozEhTjp71VxW6m3PABDNEoOCgNcveITH5TLuOMDjpiu8t4VkAlbJVoVA461gXtiH8xgDuHOPXOadxWODngJUkA8cCnakA1tErr8wPDf5/zzWzNb/aIl2gLJnae341TvoC7hEUlkwv1xVJk2KOh6hJaXIR24BwD7V3ktlDq1r50TBbjGTjvXAXNoXjMqALIn3l6V0/gvVPMb7NKQGxxmnJdULYt3Fo4gMcykSxjr/eHrWNagjzIj07V2mpw+bNDJGAJFUrIPbPX6VzOq2whkWWD7p/Q0W0ERWTNkrE22ROo9R7Vq2F4HUpICrjoenNYTzBZEmjOCMA/nVu6ceYk0bfJJ1+tFgXY05LpkvH8wlZCAVb196lkvRI6tL1Ix65PrWZLN58O2THmqMj3FZ7zbkJydy9qEFzqY7+Oa2a1mODjCH8e5pljfSqDDI3zq3Bz94D196wGk8yxjlUfMDgn1pYLtl/1ik4IOaq/QR6VpGrp9nMM5ALEYart3cQXtq1vcEFwMq3r/8AXrz6K9+QHh4z3HUfX3ra0vVF2FZvoGp3Jscj40sZtPuUuFUlAR8wHvXQ+FvEaXsC290wL4AU+v8A9et28hg1Oza1udpVxgEivJ9RsrjQNUeIscA5RhxnnrRfQFoes2tyYGkhZG8tyT9D9agvXV1AZSHAwaxfDfiGDU7Zrad9l2qgD/bx/WnyXpBaGVvmXo3r7GlfQo1isctqsjnymXlX69Kqz3TIFmC7yow3PUVThu0jzDK+YJBg89Ce9QzMLAMrEPHkd/vA+lHQTKOtQeXL59tjypOR7GsaXdPhWfABzWuztNE0UgIifhSexrCX/Qr4pd58vOPpUi2JpAFwsjBkHGfY1QuoXgcMH3oe9XLuX97xjymwKhk+UeTIQY25U/3TT6A0UpgqkMO9MYcfMTtPSnriNzDPnn7p64NNbLAoSflP6UCJLciRWgfOP4f8KoTfunKSDkdKmaTBBTPy07UEEsayZOaQIqxSbZgw6d6kuV2kOvIPWoEGFwKsr89v+GKLBcfG4miwPvChehB7VXjyrZU/WrONy7l6ikMPX0pKUcjigcGgA78UfWlpOlACigUlH40APHNSCo1+vFOB9TVIB4o5oH4UflQAmacp9ajzjpSg0MBJ4w6HPWsyaLBPHStcc9u1VbiMEGpsBjSLzURxV2ZMZ9apkYyKmw0M+vSkp2OKQ9KiwxtApfrSUrAw+nWigfzpQPyosITtR+FHrS/WkAgGOlJ9adR7UgG/TrR6+9LRQAlFO/pQKQCAU4fpQOKUfWkAnaj14pfX19aKQDSKT1p/qKTHpQAgpRRj2pRQIki61bTpVNOOvWrKdKGKxbhq9Cf0rPiNXIjxnvSsSaVu3Y1qW5rFgbHU1pW78U0Q0a8DdquxN6VmQv61dhfjNNMzaNOGXtU4lB6npWejVKHOOelVcixaMnHaoXk+lQmT3qCSTrzUjSHyzVUkl680ySSqssnUigpISeYZ61Qmm6+lJPIcnmqUkhweaLXLSFlkznFVWJOTSM+TwafEpY1SRpFWCJNxq5FDUtrb8c1fig56VSiapEVrBWvaRYxTLeEAc1oQIOgp8ugyZF+XpSlR3FSqmBg0Fe1S4hYrsnBqu4q43Q1WkHXFZOI7FfH0oA5p+PSlCn0qbCsCDnFXIF6GoY0OauQLjpTSMpItwDircYqvCvHvVpBW0DJokHWnUi0taE2Cmk8U7tTT0pXKSIZRwaozd6vSdDVGYcmspM0SKclU5+narknHSqdx0rKTGlYz5sc89art0OKnl/Cq7dPfvWXMOxGevakx6YzTiRjvSVNyWAHrT1pg708H+dK5myZOtWYm45NU1NTRtxVJkM0Y29DViNves6OT3qxG/wCVaKQjSibipg1UYn9KnDe9aKWgFjd6nFJuz0qDfRvo5gJ91G4YqAN1zSlwBSuA6RsA81nXLZzU8snHWqUrHPNQ2NED5qFqe9Rt9agaZE3GagPfNTsBURBzUjuRmilNJ/OgA7YFLSZoz78UXGhw6UZpmevNGeai4yQHilpgpwPXHJpE2FopKTnvQibC+tKD70zNJmmkKxMDRuqHdx16Ub6pIaJCw5o3flUO/wClAb35qlEaZLn8qM9fSmZ96M54NVYdx+aM03IxQDRYLi5opKQe2aLBcPxo4xyelJR707CuL9RS0n40UWENbpyaib26VKahPBNKwETUwcmpGxSAeoosMQClApw/lQPQUWAbgelFO4oosB16VOnSoEx71OvStz0x4p69aYKetNAPAp6ikFPUVaIHotTItRpVhOtaozY6NKtRpTIwKsxirRJNAlXo1AqvCKsoapCJlApygU1TUi0xD1FSKBTF6VIvSgCRRTwOKavSpFHFAgUU8CgCnChCE28Um2pR70AUwIttG0elSYox1oERhaQrUuKQimSQMvpURUVYI70wjigCuV5ppWpyvWm49KBoh2+1NMdWNo/Gk20hoqslRMnByKuMtMZOKQ0UmX1FRFauOvoKgZetFhlYrUZWrDLTCODSsFysy8GoyKsleKhYVNikyBhxz1qNh1x3qwRxUTD8qixaZXcUwjrU7DrUTCs2jRMhNMI9KkNNI4rJo0TGEZFNPenmmGs2jSLEGaXtmk7UCsZRNkwpjdDinUh71jJGiZHigD0pe9KBmsyhAvtTwtKo4609RSAaFp6r7UoAqVVqQGKtOCVIF9KeFoHcjC04LUirTgvWkNEYSlCVMq04LSuMg8vrSbParG30pNtFwINmOgpCtWNvHSmEUXAhK8UwqKnx3ppWkBXK+1RleTVgr370wr3pgVXX1qu61dZaruvJIoApsvWoXWrjL1yKhdetMCky9ahdfarjrUDCqQFCVeOKqSCtGUdc9KqSL1q0IouOOOlQMBz/ACq1IKgcYrRE2Kcq9cVTdevTmtFxx9aqSoKqLM2ig47GoHHUDFXHHX1quwrRMixVYflUZHrU7L1FRsOtWmKxD6+gpB9KeabVJiAUgzilFH0poYhFKAR6UDvjrQPr0poQAetAHanD1oA65oHYAKBS49MUuKLiACgUo96KLjsHY0oHfFHvTgPegYY46U8de1IKAPSgEOHtT198U0dKeOR0pDQ8U8dMU1BT1/lU3KHLTxTVFSL3qbjQ4AHoKcPpTR7U8ZpDDinAcZ6mgCnDpQAmKMU4UuKVwI8U2paawppiISKYe9SnpzTG6GqEyMjr70zpUh6fSmHmqRIw/rUbVKajbFNEsib2NMPcZqRu9MPcVaJZEw9KYcd6kPWmGrRDIz3phFSkelMPpTRmyLHUUhp5FNI7VSIuMI4ptP8AXNNPHYVQrjMdacvXmkP0pVpoEx46daVetNBpy0hXJVHtVmNTjioIvSrUYOKRSY9U9qlVeOcUseO4qbYMZA61LKWgbf3Yx1qMKWO0dc1YjU7atRxi3Xewy5GRU9CldjFt8RhATvPJ9qvaXpclxdxxJ8wyMsOahtElnlCRgtIx49q7vTLSPQbZfOw1xJgt7A0m9DWEb6loPBo9oLe2B8+X5d39aytS1Ly7Y2Nvy7n527tWdreqPJdFbfoON/c5/pS6bbs9wu5S8zEAd+tXFWV2KTvojqPAWiGXUUZ1LEck49K9ms7UMUgGcDDN+HasDwXo39n2atIMzyYJ9vau2tYRboT/ABt1Pr/9arjG+pnJ2VkSNhIwq44rnfEuptGgtYCPNbGe+0ev1rS1rUEsbOSViNwGFHvXHaTDPeXRuLrJZzv29eB6/wAqdzNI14LJAkckmQsYz/vE/wCJrcj+WEFiM5yfpWfKrPcQxKfuHcw+tSXc+z92pBOOn+NUtBWuV9Svl3tlsKo55/KucluB5skgBKjuR+lVdQv1udQMEb5RDliD94+n0piSiaUqvMMQ6+rUbl7ImlvFgt5J5OJDyfxrA3mNTPKczuchfr61Bq14ZJwqn5E56+neseW8dWaSUnd90Dtk96Eib6Gzp6far8ySt8kX6n0q+t409y8px5UXyRj+tYYuTZaZgg+dMc/SrlpvW1WJD+8ABPsTT6XEkbVs7C7Q5GcZ5/KqOs35NxLDGwHByxHQDr/OnrMFbKnquBx1A/zmua1OYyB1QkyTHaD7Z/xpLzK6WJdJRL6dQMi0ibJJ/iPqfyrS84ajqe8keRCNiDtx3rOuSthYRWsBwzdfXJ5J960fDdsSRuH0H+NJgo3Os0tVZSzDnAVePeqms4utRREbMcQGT6AdT+eK0dohtSVP7xuF7c+tYV5uiYRqxDuOvoB/nNRe5aVi3ptuLi+luGyUX5V7dO4qKxsle8a5kILO2f8A61aFtF9n00RqTuYAfnUlrFtARRwDyT3qGWkMRdspU9/50yW2feSg+Ze3vntU4X/SJCeisMcVauEKM8obBA47e9ShyZX0hTDLKDjeV7j3xj+dXPKLqgLYbH6ZIotikl2rY+Zozn3wc5/WrG0goRnpgcUNdRLszDghAO1uNxx+HrVKNFe7kUnPltgf41syqULM2AcHH41ladC3nXLsMZYfjRrYfUJEDX6x4Hr+fH+NUb6ISSykDgcfgP8AJrSHyXFzKSCFAKn1xnj9ayiSVkJJ+ccc98ZpoTOcliCSSkLlgM/marwwfaJ4YhgoCCx+tX5xtTaT8znH1A9KksbUw2zyjk5I/D0ql3EZ+qOZLlSANkOF/AH+tJYH/TJ5WwRgbf8A61adzZhUZGTaSep9j/iaXTbMTNKuBtQYz9OM07iirmfGpYO/GWG3/vo1aFuY1iyfnJP5dBVyws3mlRYwOu4cdgDWtf2JEVrP8u0nB9j/AJFCYNGNaJta8gPTZuA9GFR6TEGmZWzvBzj6GtFYPKDXIwSXwfpmn6fb+RPcXJA+QgYxnJxTXkS2jZuJ/PCIFzJCMtjvn/61dLodkPsgPlkbx/OuZ0S2ea4lcY+Zefpmu60zEGnjqdox6+1NakPbQyL62+y3dvIv+rYkH6npWXPF5bcrn5t610l3A93YM20/L8w7dD/gKxtWfyBGWU7dy/l6fpSaGmYNrCxv7qRlGxTtP415t4s082usTDAaOTnj6165djylu9yj5iNvPXHH+FcxqtnDPdSCRR88WF4zz7UbIe47RrRX06JQgJEdc/qNvhYpFBVtuD9Oldj4Ykjht1hlIEigr/hmqOqWwKuF2/KTt9gc80IlX2PMbiJIbuMkHazjI+px+dZuqQCOWVoyQNwK8+nH510k9p/o9w0oyyS9fcGqOrWZ4J+6xBH49f6VokIyb6DzrMXUS8kDd79qyrRWikSZRhlYE/nXV6SUR5LORQUdeOO5rMlsGt9Ue1YEgqdp9cUKXQNzoNYuFaz0+6gOx3BXK98//qqqZBqFk5VQs8Z+ZcdcdwPSkWFrjwmqrnzbdnA/z+Fc7Z6m8UiSqx8wcOM/eFOK0JaI5vvnaCCOHX/CprSUPBLBJjIX5fx/+vRqk0Tzi5iBG7qMdDTk8tnWVVGCozj61SV0TexEtw+wDcQ68flSXZWWLzoyd38Q9KpXEwe6kK8KTxT7WZfmjb+LpRbQdx2nXG5ZIJGIBHFL5jKrK2Q8fB+hrOZjHclDncDkfSpJJmeUyAk5IDZpWEmaVne+RJtJzGeMVq2t8AWUYyeVz3FcxNgYAJ+YZFJBcl8JKSpHAJ9aLAekaJdvMDbyEDI+U55zTfFWnf2xpjYwLuHofXH9K5ewvpYHUSE9Rhq6rTtQ89m3AecOue/vTWoHmlhJJ5nOYryE9+M4PpXZG4Or6cLqM5uIsBx7DiszxrYrHcjUrVAoP+s28VjaLq7WOob1OYZRtcfjSA6MEmLzUO7sRnpStKpSNJMMpbhh/I1BO6WszCL/AFUx3Ic9PrVBJzDlZM+Ux59s0JiZqXtx+7MZzt4K45rNu5FmjCTLyOEkqKS4OCA5IXpn0qENsGGBK54+pqhXGrKY8xPzH2PpU+d8RRuSOOtVgWcsrAFT04p0J2YXcG5x+FJBcVx9oixn51phwYckneuKe67HDp0JpOGbpjd/OlsIgkQZJHQ063IKPE/PpSOrR7g2CCMUxDiVdxHTB+lO1w6EO3aWXuvFOgyrlT901NOgEuQevBqLHp+FIEIy7JCD0JzUkZKnnoeDRJllyQdwojO4EegpAh5BU57UjCnryuD1FIBxz2pDE7UfjQKXHpQAn40n4UtJ2oAUc08dD0pgpy9OKaAeD+NGab2ozTAPak/xo+lNP/1qAJFPYUj4IpganZ4570gKkycHFZsqkMa2JFz2qjPCTnFIaKOKac81KVx2pCOOKiwyM02n4/Gkx6VIDRQP0paO1IQlL9aB+ope3tQAnak7fpTunTvR6+1TcBB0oHNHSlpAIKMev8qdSge9IBoHpS0v40uBSAQDrScUo70v0pXAaPakxTvcUnrTQAKUUUfjkUCFFTxntUIp6H86AsW4j+dXYm9TWfGfXNWomoJsaER5q7C/pWdE1WY39aBWNaKX3q9by+prFikq5FJSRDibKzgdxQbke1Znm96aZDzk1QuQ0muRg81WluRzzVJpPc4qF39TQNRLbXGe9V5JeOtVjJj8ajeUYNIrlG3EnvVKR+vPNOmkBzzUKjJ6VSRSRJChkbAGc1tWVjwM9aq2EPIzXQWyYWtEikhsVuAOKsRxc9KnRRipEUelWkaIbGhq5ClMjT2qzEtUkMlVOMYpjrjNWUXikdOKTQii3TFQMvWrrp1qBk61i0UVtuBTlFS7KQKevWosKw6NR2FXYEqvEpzyKv260JEtE0a8VKo4oUcU4D0rRGXKOFA96B70o9qdxcohphp5pppNjSIXxiqkw64q2/Sq0vesZMtIz5uKz5261oXHesu5PBANc8pFWKcrckdqhbv6U5zzxUZ6c5rK5FhD9aT1pTTD05pXM2O6UopoP50fjRchjw36VIrelQfzqRPemmQyyje9Txue5qmp96lQ/nVpiNCKTHepxJx1qhGamVvQmtFLQC15lLuyarg4pQaOYdiwH4NIzcdeKhDUZ9aLisI5POKrt6d6mPeomFTcCBvamEdalI9qYR+lTcCErnPSo2WrO0du9MZeKm4JlUjimNxzUzjioH4pcxa1EzTc++KaSeeaTd19qLlpDs+lGaZn1PFJ6/nSuMmRvU04HFVwfenBuKaQiYt70hbiot/XGaN2apIhj91JuqPdRng1aRI/PU00t6Gm57Uma0SEO3GnA8n2qMd6UdOapICUEetOBzUQNOBx0p2AkB78UueKjB9KXdRygPzSfjTd3BpM0+UB+aPrUe7vRuH50uUCTNGai3e9JvpWGPY+9RMaC3Wm5osAh/SikzRn2osMX3pabnrRnilYQ7A9aKbmiiwXOxSpk6VAnpU6Yx71oeoSDrxT17UwU9T600BMvpUijjiolqRfpVohkq1PF7VAtTR8VojNluM8VZiNU0PtVmI1oiS9GeM1KpqCM8VKpqxE6NUyn8qrpUyUCLCVMtQJnmp0oAkWpFpi5p60CY8U9RTVp6jihIQ4UUCnAAdKYCUYpe1LTsSNApCKf+FJTQiIioyKmPeozQBGwpmMVIcU0j2pDQ3AoxxilHpRjnmkNDcetRlalIpCM0rDK7r3xVZx1xV1hwRVZ1600CKrCoyOtWHB/GoSOo70rDISOKjK9amI57Uwj6UrAis61Gw7VYcdahYYqLFJkDD9ahYcGp29+lRNjGPzqGi0yA00/WnuOePwqM/rWbRrFjTTTTj3457UysmjRMSk/KlPTmk+grKSNkxe1NPej6Ug+mawkaxYgFOUcetKB609V4rFl3FUflT1FKq+1PUVLGNAqRQKUCnKKgBVFSBf/rUKvtUqrxQA0LxTgvHNPVaUCkUNAzTgtOAzTgKTBEe2k28VNik20hkJX1phXrxVgjimleDQBBtppXrU230pCtAIrlaiZetWitRMtAyqy1C6jmrjLwagZeTiqTEVGX0qB1q6y1BIvX3pgUXFQMODVuRarsPaqQFORetU5B1wPpV+UdcGqjqcHFWhFGQDkiq8gq5IKqyCqTJsVX6H1qtIPb2q1IKhcdQatMmxRkXn6/pVdx1q5IKqyd+K0RFis3fioWHBxU7dTioj3xVokhb61HxnvUrfhUZFUhCfyo9qKP61QC9qBSDvSjPrQgFHTg0oyOtApR0IoABS0cUooASloHenCgBMelKBQKeBzQUkAHGDS4+tKKUDilcAHApy49KQDqaeq+9IpIkUGnKKatSrSbGKvqaeOnFIOlOA61IxRUgHoaaop6j8qkAAp4GaQCnCgYgHNOx3oA60valcLDMc00ipaYelUhEZFRsOtSt0NMPSqRJEemKjNSmmN61SJZEf1qNuKlPeoz3zVIkjI9O9MapMdfao2q0QyMj6Uw59sVIfUdqbjvVIi4w/rUZ5zUh70w5q0jNkZ9s0w1Iab9apIgYcelNYe1SGm4z9KpCZERxQMjpT9vWmgHtTsJMBUiU1R61Ii0rASxA9vWr8a8dTmqtuuWxV8Lge9RIuOwsQ5q1GtRRKcGrVugyM0mUizaW3nyqFB69KsyWUkkzEqNi8D6Vd0tPs/wA7DqMD8a6LS9M/tO7CDCwrhpG9qzlLodEYK12J4Z0+HS7B9SuwDKeIgexFZGoagbm5YsTufpz2FXfE1+Jbs28RAt4BgAdyO9c9EhuNRjK529vpTiuopyv7sRuyWe8jgjUsxOK9T8D6NENSWWf5jGox9a5CwgEV0hhQGeQhU47+vtXsPhrShYW8Jky0r4J+pqr30M0rHWabCFiMrdT04qw86qpZulMlkWK3yxAGKw9W1AQ2skrkLGi5rRSsrGbiZHiW9FzdgHJjj6L6se9amgwiOya5n4d+cZxwOg/rXEeG5ZtYvJ7u4JEQb5R+gr0KeFfLhRThB17ZA6mnFCk+iG28hgSSeRf3jnjP6CuZ8Qam8MLLExM8xwPX6/StnU71YomLnCKMEeprzzUb2WW7eUDLMdq+wqhrYktx9lVlDbp5OD/+urE9yLS08lfvv19fes+1lBmaTGQOF/xqkbozXUz9Qvyrz2oSApapdtE4jB+djuc/yFRW37++ijPIQbm/nVCaTzZmlk/hOTVvT3NrYy3bEebN8sf+NVbQl6Fm7mE16xHKp04zwOp/OtG2mKI/UM6ZP1rHtcoI1B3SSkZ/3RVq7mClYcne5+Y+2elD7FJXNK4lMVnEqgjK8se5rHtrhZLiS5f5UjG1BnGcVc1m4xCiKx8uNPm/GsSNt9uxHAB2gD881JUUXbJmvL1pXBPYD+ld/oNttjZmUA1y3hu1xb+aykFiNvHrXYxt5UGxM7mH049alu5SVi1HukndzxEi/Lx+FZccf2jVGcsAF+UDHUVrRtt3DPWPAGfT/wCvUFnAkbqzE+ZK2F745qAJYVZkjJ7c9PerESOoKjOc1bKCOJcqM5AHHvQg2tIABn+VZMuJnSIxnKDOSRVjUCqoFOccf/rqVl2SnA+dsc+gpmoIrw4JO7vQtRst6bGkj2zjBG0j/P5VdukWOIYxkH86qaAq/ZICxJ25HFXpUWZeTwG9aroZp66mTqo3RqQo9/asu3fy0uGYZHBFa+oEIzJg7CMCshIwEnTcfu5A/GpLRXVy1nI3HIP69qyoR5siEkhNv6VrFQtjgHkj86o24VEgDYySBz9TVdLBuYU8PnXcYAIjU5/+vUyjezIpO0MPbvVzy1jYEYJ3jHfpmoto3zeYduXz09//AK1NBbsS3QDSSxk4VMdfc9TSaYqpFImAcjdn8atamqIlxOArBkEYyP4iP8mpLK1jVYzz+8iy316/lwKtK6M07E3hZGNxbnAJ2lW/76P/ANatZ7ZJ7RoiPlUkZ+v/AOqq/h+H7NcQbmAWSQp+Rz/OtfCx25bGWMm0/TOKLaaCb1OKLP5M1uANySgD8citTSw7aZqJVQ6mPJyPTjj34qK6h8jU7tGXBbBHbmuh8L26tol/bsBuMZx65PShaaBPa5Fp0YW4imiyAyAEY9ec10SyG32RuCUm/TFZmmx7ILRWGN0WCfwxV8wSKkIJGUbI+lPzItc0LaUNAygE4b9P8msLxQqGFFAI2EH64NbmnSJskjUjhiKy9eiN1O8UShmwPx57076ErcxNQgcXEnmk7QgZfx6n3rNSzB1GGSddwODtHt/k1t3UchsTLKCGRdn17U+0sxdG2lYnBiOMetJq5V7I5fUY4rXxGp2hFcDHvVq6hMkTZQDHQ1N4i0+O7aCQOEmRtvI6jHQflUWnb5LeSGQ7pI/lHuBSaGnc4iSH91qqsoJEoJ/+tVPVbZl0pGdScYG4dsf/AFq6aGJDcawZAAhCn6duKj1BVfRHUqoGBjitE7CPOp5jDdxSY4GBn2rS1dAbixu1JKj5SfQe9NuLZJECuQM9D7ipdJj+0wm0dhx079+v50WC5N4bXdpl7HsJG4kfjXm2rxNa3soXIAb9K9Z0aP7O8iyJtCnY49SM8/yrzzxpAsesSAD5W4pp2ZL1RnJPG4UnPluMOPp3qxBMlvlQyyROD0PrxmsGKUxSNGx46irStthw2MVS0ZncJGEchVuo/WgSAkcAUT4uIA4++OvvVESk9R04oGWrpstk43IevqDT5CAxIYYIwapySbwwzz0pgkPk5J5HFCQXLYk+TZIePX0P+FMlzkK2AQOG9aro3Az0PrTg5eMxMeV5U0dBdTTsLzI8qc8djW5p1yY51Rm56o2f0rixIc4JIYfrWxY3iTRGGYkOPuMPWhIZ1ctwtxBJFIOGG0j+tcLrNhJp0+85MLH5SK3ba/eK4MUvPGN3r71FqG2UvC2GifoOuPpSWg90V7C4+22QgZ/mUfKfemSF2jKEkFexPpWXahrG5KE8Kcrn61q39wrhZ1Aww+bH86LdiSm9wdu0HnvT7adnhliZjnGRVKZipJGMHoajgmxOCT2x+dJMVtC5bTE5Ac7hV+3KyJuyd2fWsK4Bhugyk4PpV/T5NsuN3DCnswNdiGXI6j+lRuuVLr9fpSIPnJGMHnmlPy7gAcYyPpRcQ4nzoTwN4/lVKZDsGDyKtwL8/BAOPzpGG+MkYyO1MZDIfMt0kA+ZTzj2pi8pkfWnQH5HU9jmkh4UjjilcQ/kxlh95aixtO4dKnTKs445FRLwzKaQImXGARn3pD14pIuMqacRxz60hjfp1pPen0360AJSe5paQ0AKKUU2lH600A7tRSZpe/tTQBTW6HmnCmP0pgMB/KnqeKi+vSnIw/ClYBxpjAHNPPPNMPf8qljRUli64xVZhjrWg4yDmqUwwT7VNh3K5/Cm4px6U00rCG4pelLSfhUgH8qMUf0pakBP89KBQPqc0CkwAUfpR+eaWpAUCjFGOadj86AEHrR3pcd6WlcBMUYHpS9jRjmkIb24pPrninY60YwKEAlH4U7H50mPWmAgzilBOPpRg0DkUDRLEeetXIz2NU4xzVuPp7UBYtRt71YV6qJ7VKrYzSCxbR/erUUvvzWerdPXvU0be5osKxpLJxyaDJ2zVRXOOtBc45NMnlLDSdelQPIOaiZ8ioix9aBqI9pMnr+tRs+c9abj6UqrnNCKsRkZ61NbQl24BqSGDccCtmytVQD1q0gsOsrfaoyK1IUwKSGPFWY1rVIpIcoqZF5pFX2qVFq0holjXirEa+tNiU4qzGtWkMcoFIRxUoXjijbxSaBFcpmmeTVrZTtntWbQykYetN8oVf8ALpvle1RYCqkfNXYUwKEi5qwq4HSklYTGgelApxFJQS0A6Uo+lJTxQTYb25pjdKlNRtUNhYhfoaqS9DVqTvVWXoaykykZ1x3rNuehrRuO9Z1wODjtXLIZnvUeBnHNSv39KYfcc1nczkM9cUlOI4Ipp6UrmbG44o68Gl96OO+TQmQwFPSmDOKeOKpMhkoxnFPFQjpUin3xTTEWYzxVhMEcmqaMasRt6/pVpjiWFFOHSmK3HPelDY6mquaWF9aDRnimmlciwHvTPXvTu3Wm/TvUORIwimkU496aazcgGGoX71MT1qCQ4zU8w0iB+9V5Tx71M7YqtIeuOtCZaIyeuelJu/lTC3XnvSbuKpM0Q/d24oz71HnHXvSbutNASZPpS5qHdxTg3pWiIbH7vSl3d6j3e9KD71aRA7NLntTPxpRWiQhfWlFJR3q0hC0o96bThiqQDhSimj3p3tVJALzRnHSm0oppCFP1pM/nRk8+tN7ZNOwwzxxSE8d+KCeoNMPHeiwri7sDjrSbvemmm560rDQ8mkB496ZnvSg0rDsO9xRTM80oP50rDHCjP1pueOtH40WEOz9aKbz60UBY7NT3qVDUK96lTpTPTJVNSIajUcVIg9qFuDJlNPVveox6GnjB9qtEsmQ1OlV0qwlaRIZYjqxHVZPXFWIxWiIZbi6cVYSoIhxVqIVSJJIwMVZjWmRr71ZjFMB6R8VKq8URipVFCEIq+tPApVFPUUxXGqKkUUqrTwtOxNxoFLinbaMYpoLiYoxS4496TFAhKbTiKQinYBjVGRUpphoC5FTf5VKRUZFKwJje1FL60mKQBQRxQOKUGlYdyF6iYdqkDh3cf3Tj601hzRYZXcetV2FW5BwcVWcUDRCRTG6c1KfxqJsUmNELd/0qFvpUx71E3Q5qWMrv3qFqsPULVLLRXeo+MVK/TH55qI9/WspI0iNNN/PinGmnGaxkbIaaSlPWjtWMjVCfWnAelIKUVhI1iKB+dSKBTVFSLWLLQ9Fp4X2oQDFSKKgoaFqRVpVFTIOKkBqrUgWnKKeB7UrjQ0A0oWnAe1PCigYwDinAU4ClAqRjNvBoA4p+OKTHFADCOMUmOoqTH500jrUjI9oppHtUpHrTCOKaYERFQsKsMKiamBARwfWonXrVhhULjGaEBWccVXkFWn6VWk71SEVZBVWRRVt6rSe1UhlOT6VWk7jjIq3J3z+FVZO9WibFOUYzjvVaQZzVuQHFVWzVIGVZBwfWoHFWnFQsOOKpMkpyj2qlIOv0rQlH0qjKOvrWkWZsqv8AhUTd6lk56VC3T2rVEkTUw/SnnuKbxVIkaaSlNJVAHtR70UgoAfmlH50gpwoAUe9OApBTl6YpDQoFLigUoFIAApwHFAFOAoGgA54pcUCnDpQMBTh70DpmlWkNIco9KlUcUxakHSpuUhRxmpFHFNHTk05fbpSYDl/nUiimKBUi+9Idhw9sUopB0NL60gAe9L+NJ9KWgBKaadTT396aEMPemGnt0wTTTVokjIqNs/WpDUZqkSyM1GepzUhphzzVIm4zsaiPcZNTGozjNWiGRECmnv61Iw9KYatGbI26dKaenTmnnJzio6pENje3OKZjPSnnuKQDAOapMi43sabjg0/t1pMH1FUhMZigDqRUw9CRinbU5+Y0ySBVFSoozTwsX95s/Sp4ooycbjSuCH2qjeKuuMdB2q7punwOfmYH/GtJ7S0tB5k2JG7J/Ws3LsaxjoZ2m2NxdYEUTHt0NdjH4btdMsBd6hMGkbG2McGsW21mS3U/ZlEfYYpdQvJ7hVNxMzkjuelRc0WiJZLoSzBIYxtJAHtXdWUY0zQi0sgWaYYPb8Pyrh/DdsZr1WYDYpyfpV/xJqkk98sIP7tBwP0pW1K5vd1KWpPbtKy/MQTknGKdoEcUl29yxK29uPXG6sud2MjYyc9K0pozbWEUQ+XzDzjv/k1paxCZ3Xw9shquueeyYij5Hvg1628QjmyOi8D2rifhVYvFZGdxjIGOOorupFLMwz16e1OMdAb1IruTzAMn5RjNefePNQzEtnGTmQjgemcV12t3iWsLsSML1Oewryhbv+0NTnvnO5UPyg+nYVSV9yXc7jwzBHFHb20YGIwGf6npmuonkLEnd8qgKK5/w6os9NE0q4kbLtnkmpr3UPLs2Y5BJzj61SfQnlMnxJeB9y5yq9s1yiyttkZgSzfJH9T3qbUrp3uSCfqPc1BaSb2eZj+7jG1Rj0plbIZdzfYrAouS+38s1j+YbewwW/eSGm6reHgMeZGzj0A7fjVW9kHmxgHKxgZ+o6/rVLYQSglooB95yC30/wD1VbvGVp4oAf3cIwP55qpp+WuHuXHTgVXnm++Qx8yQYHsP/wBdNIk17AmR5rgkYxtX2/yBTkY+artzI/A9gTUdohjtBGPv4yfx70tkxkktyy55xn1qS0iTXASIoVbl2yfoKhWEu0MCjGMA+/vU10xa/wA4BwB1+uf6Vd8Pwma8knYcA4X8als0ijptJt9iKrdFAH5VroAw4PJqnFGY4dowWbg9uOtWgCoJJwAtY8xdrl6ziV5mJz5ca7Sfz5p2mIkzLMeisQPzqojNbaLI5JDzf1P+GKu6WuywVfU5/Om3ZE2uaFyD5ZYdMjHtSRqd7Ejqaju9yWrkHoRipk3eUCB2yayuNKw1U/el26cVBqBTYxJAJ4FT54JODt561ka/MVgTaBkmi47GnpLfZ9NC5OWzj2yetaFmQ0DByCQ1YSXBi06BmyRvUfQk/wAq1LTIaZR3IP1qiLEOqqfKcA5wKxoAWMgJ+YLn8q2tSyYHwfmxWJHu83b0ZkNBa2GtGDBkkYAPP41QlQIkTk5w4/Q1oTfJbRRMeScHBrPuMxwsB0XOefWmtRWsIVC2zuVGN4P5mq2wSXsgPQsMfj/+qrKzKNMkBXOcDr3BqpM4Dq3Rzg/zqrXBaDdckkW5jz9zbuI9cdvritvS50uYbObGE2sD7f5FYWv5FxYyhhseLGB6njn8q2fDbJFo1sGHIYr781drIy3ZftFKz2eCQqykn8cf4VtyJG4kRTz5nHboayXhXzRsb5lfP4f5Bq7teKZ9zAkYx+NCYmV/F9n/AKTbtD96VgrcdAas6Q8izeUFPKbCPpT9aZjeRSg55BH4D+VT6epS5O4Dc5556c9vamwTurFyGyJt7Ugk7SR068nmr9woVInGRscA/SiycQW+xsMxYjr70XIY28nXB5FFiExbMRrJPICdpfI96inCtNL5ePMcAevQ/wD16gjmH2WGMDqfm9sVehRVvFA67c/h609BbGRrdsU00Ql/mbnp+FGjQsthYqSQQCD+dXfECB88jIX+tUbS4MenW+PvbyBn60kx7oo+IbHa6sD0YHP41kW4+x3rMSGEq5z1xyQPoetdXqSGWEGVh+Pf3rnntla6uOchAp+vUfzoY4vQxXt0+03seOZowy+xzis/VbZLe0jjOcurPj9K6PULUrepPGAD5eSM/wCfSsbWYvOvbd2BwUYL+NAJnDahbnAaP6AUaWvl6pG+R94KfcZrYa1SS4ljbOVAI+tcuJJItQwc7lkx196aYNHaainlQ30gAB3Kfqc44/CvO/iHBiKOdcfe9PWvS7pfO0y5VurIGH4VxfjKFZtG+X7wUEUnfcUVoeVz4k2vnBHp3qaUhYBknINVWbbjOOuKfesflBII4NaJ6GVh1tMQWU9DVWb93KVPTNIzDGR65ps7b4we4pjFkIzg9MfrSB/lZfx+tMJLKM84phODuB4pisPLtwB0FKzMGBB5FNf5UDDoTio5G4yO1TcCaVgSHPXOKmjkGAynkY/Gqgl/d4IGCcGpLZx8xI46U0wNppjJCHUBiODUbTlkXJORyPqP/rVn21wYzy3yMef8amkfy2wT+77d/wAaNATsT3qrcwiVT88ZGR6iq0cvmJszwOD7UGb7O+9CGRuCPXNROgjuCyEmNgMUrBcRZNpaKQAr29qqSHDcdQeKku+HDqeDwahdsjnt+tFhlu4bzIFcHkf/AKqSOX7pB6Ec1HD80DDsP61GmVUg9AaVxHSxsZIif4uCPepGYlQwI4x+VUNOlMiEkjgA/Wr+VMfH0xQhMcv3wV60kYwcZ6jH5UxDmOMjORwfwpSdrhucZqgI5U8tyR0oQDc+fQEVZnww4HFVIz87D24oaEkTxgFiB/dqB+GVh171IjEMCM+9LOgGMdDUjEGOGz3qT+E1EuNuPepR0pAN+lNOAM4p/uKY3fpQA3vSc96TPPNKOnP6UALn1pQaZ0OcnFKDn64qrAPH40CkH1pw6UIApj5xT+3vTHzTAru2ByaRHol5B61ArYODQBbDfnRnrz0qENwPWnZpWAVulQTLkGpqQjggYxSsO5nNwf50z8qszKOTgYqvUWAb2PrRRz2oqbAHfNFJ9KWpsAg+tHToeKPypR7VLAB+tKOnakH1pwqQFApR0xQOlOFJgJ9aMdadijB5xSEN7e9LilAoAoAbj9KUClxj6Uvai4DP50Y9KeBSYouNDcfSlUU7aO1OC00NAuewqxGeKhUcVKgoGidf1qRaiWpF6c0ASqeamjNQrU0VAWJl6Uvb2pUHGKeBTJsRbeD0pNmam29aljjB6jigpIprH+tWYoM9fSrMcHqKtRQjpjimkNIjtYMfWtSBBio4YsVchj9ua1SCxJGv5VOin0pY4+OasRxj0q0h2GonFTRx81JGnFTIlUkAsSVZReKSNKnRapANC04LUgWnKvtQBFs4pQtWFSnBBU2C5W2U4IKn2UhXiosBGFAFIxApW4zUEhNS0FhxakBqPNOHSpCw8etSKOKYvWpkHrUthYQioJODVl+nFUpnHNZtisRSHrVOVuDzU0j8Gqcr9eaykwsVpTnNUZhnPSrch96qS45rnkx9Ci69fWoyPzqd+pqE4+lZXMpEZ/Wmn3zxUhpuKZkyP+tFOx255pAODQkZigcUdqBxRiqJFBpynHXpTR7UCgCZT6dalVqgB4p4PoaYJ2LIk4pwk9TVUE08HvnntTuaXuWPM/WlDd6rbvc8UBuvJqbk2LW7IpM8VCG5xmng+p4qGwsOz6Cmk0m4frTCetZ3FYGPWq8h9alc8cdqgkPrU3BEEh61VkPX1qw/HNVX61aZoiImmDvmnHvmmnPOatMtAD60mevNBFJ296pAwzSg03vQOK0RNiQHNKKYKctaImw4U4Ug+lOAq0TYBSikozWiJD1pQe9NyMZ5pM1SQEgp2ePeog3rSq3WmBIDx1paYGpQfU1SYC9utJnmj8aTOOmKBWEbvmmNSk8UwmgaQmaM03PvQTxSKSCjNNJ9DSZpBYeD70A9f0pm4UA++aB2JQaO1RhvwpQfegLDsmik3e9FAWO3WpUHFRJU69KD0Ry1KntTFqVMUIGPA9qeoHXuKaOtOXFWiSRPQ9asJ71XSp4zxWiIZaj9qsxqe9VYz+dW4j3rREFuFeKtxDiq0XSrUeKpElhBU6dKgQ1MhpgWExjipVFQoalXpQhEo6VItRLUq0ySRRx0qQCmJUo4FNEibaTbT6TvTEMxSU8immmAw9KbT6bQA0+mKYRUp703FAEZFNIFS4pMe1AEJXvTcdqmK03bRYdyKkPSpCPSmEHpSAiIxkgc00+tSGmEcUAQOODVdxVxgMGq7r1pFIqsOoqJh61O465FRMO9Iorvnt0qFu9WWHpUDjGc1NhkDZx2qFh1qdv1qFuB71DKRA9QsOOOlWHH0qE5x1rORrEiPQ0zAqRunNRn3rGRtEKSl7e9JWEjVCilFNFOHtWEjWI9envUq1EtSoOOaxZoiZKkWmIKlAqBjlFTL0qNRUqipAeOlOHSkWnAZpDQqinAUKKUUDQYpRSjpSgVIxMUmPWpNvtRigZHjjimkdalIPrSY44pDRERTSOKlx35pjZxSAgYcH0qNhUzCo2FNCIGHFROODxU7VE4poCpJ3qrJ1PpVuQdaquOapAVn71Wk6H1q29VpB1q0BSk71Vk9KuSDrVWTvnrVIRVccGqrj61bcA96ruOO1NCKrgcioW71YcVBJ3qkQynN0NUpe/rV2bqcVSlJ5xitYkMpv1+lRNx0/nUz/oahYda1RJEenXmk479aU02qJGnvTfpTjz3pue9UAfhQKKBQA8fhTh3po6Uq+x/SgB4xTxxTBThUjQ4elOFMp4oGhacKQUvbmgY5acB1pvalWkCHjpmnL7frTRTlxnmgpD1FSKOOMcUxR7VIv5VIxwpw9qRRThxUjQ9MYp4A7Zpq+maeKVxij2FGKXjGaPrSABRxjNFHb2pgN+tJ9T1px9KYf5U0TYaaYacSelMPX3qkSNPf+lRmnn60w45qkSyNu+KYcinnvTD1q0SxhHFRnuKlYcHFR44OBVozbGngUw96U9DzTeee9WiGMb60w++aeajOMe9UjNjT+NNGMnvSnr7UetUiBAOvrSj0pvrigdM96okcD7UufTFNB9aAeKdhDx71JH7dahU1IjY4BoA6LT5lt4BtwznqTUrzeaS5PzfnWXbMfKz6VKjVlbU2voX4xvYCrDg5AXk9BWfGxB6mtnRYGlm8xskL60WsNam7aY07TTu/wBa4rAunPmiU9W5FW9QnM10IlPyrjNZ9y4ac45ROKSRU3poXdItTe6lFCB8oILH2ramhGoa0kcQ/dxYX14BxVPw4wtbG5uXyJJPkTvzmuk8H2Jl1OCIjLyMGb2/z1P1pijHQ9b8NW/2PS4lx0UVoXL+XHuJJZjxUkChSkQAwBzWR4hvhb7mB+6PX/PpWl7IdrnD+PdV2R/ZVyZZc5A7CsTR7QyTQW0Yzt+dz1BP+eKz9S1P7bqM08nJByPaun8F2vl2kk8jHe3Az26VPqTfU3riU/uoFwW4ZvoOOaztXuc4UZIQbj+H/wBerBmEcU0xwXJ4z2B4/wDr1zGs3xRGRDjd79R0zVIaMySYzyyAYz3NHmhUZVPyjj6471Wj3JG23ls4/wDr1TvbowWsrDqBtB9SarqJsovMJr55m+7H90fTp+tRxt5g8rOWZwx+maomUKqqDzuyfcelXoAI1kkGPX86uxKZdZ12SomPLXCg+uOf51n2WZ753Y/IvT8Kmg+a3fPpmo9Mx5zBT8o/WhaCtqbVq2ZPwx+fFPDeVJbKR3z/AJ/Wq6xsZo9jHBOBz0qxCwl1DL8JGv4cf1qLmqIrmU/bnxyx+UV1vhy38qDLjn3rntNtDNfPcSjjPyDHau0s4jDajj5iMnj1rKb6GsFoXoctuJ6DgfhUN3Iyx4B++QB9M1LykIGOarqBLeRoSdq/55rIaLmqTgvZW3QA7j7ZrVjBjgAXlQwH/wBesCKQXWqu5HyphB+FdBZndFKOxORRPsKKsWLtvMtyAOoFTpzEuOwGaZgtAQR0FLHuYAjONtTbQdtSGfAJx3/XvXPX0/mx5PUOR+VbVw3ys56Ak/Tt/SueLbNOuLmUAclV+p/rQhtWL29pNCJHUMGH4Gtqyk2jkjdtGe9Ymkgt4eZmByP0Ge9X7R4/MC/8tQoJHtnrTYral29YgDBHPWs0Sbr1WOMgbRx0Fad2oZUkAG3HT1rH8xRPEdpyzALx160xIi48oeZ1Vsj/ABrN1IDymVTyxBrXEZLnefl3Y/KsC4kZZJTJhsNxTj2HbqSvsNvNCCcKuQaoSRrJNHjOxEGT64P/ANerM7LHp7vj5nULmqTzeTZxKCRvxz7DtWsUZvUZdF5nh5JUDap/Ot3wxIJtOaOU/NHJwf0x/OubuHImtYwBgHPp71v+FZB5MqMOVbJ/M8VrbQh6K5s2cgM1wpPzKy7fbOf8KfPcvIS6kbAMntyaz5ZPJmupY87yRj2qA3hbyoQBmRgT9PWpa1HHY2pJXnkEjMAAu0fTgfnWloud5mlfI7ZHTHFYH7z+2YrYY2xx4OOhzzmuh0ZfNZwxASMdOlKWhKWhqxTjzx8owTxWrjarmQZBrlbi9kF0mMbVcY4xx611DzZtDI3TGfrSuQ0YN5GTK5jyAhyKtWsoRllkf/ln+p//AFVi32pBd+HYZ49PapdSnMVnaYHzMACM4zihbjaL8Ey3cbSth92QPw4qtZMsqleB5T/qKTTX8mwjAUHLc4/lVSSaO1vZZDxCRgj0JoWg7XRoahOX80ggqrY4OeKxLOTfeXRbnKBfyNPS6LwsVGEJyDUdg2IJZTjljz7Ur6go2RZkQyXkGw8GMqf1rJ1eH7PLCoOc8Ln+E+1W7SWRry3dSdnIFV/E0nmRRSMVxG4PSi4knc49yUudy5P7wA/5/CuW1tPs+sysv3GYHpXVthrhlizhjkVzuvDdcypISWwCDTTsU0b0N9+6JUEoUGfpWVqcJntHAAZQvH0qOyuPLs9rZ6cH86Szn8y0KsSTjH1+lOLvoJo8jv4hvljPDKePfmq8jeZAOfmXj64rS8Sxbb6TA5zn9ay15TPRh6VSM5LqRo+UYHqBzTAw2EHqKcRsmyehpHUKxHHzDiquK3UjBxkZqNjycdKe3yjrUMh44ouImhYFCp59KT+EgjpUMMm1xk1Yk6bgetJ9gWpFnsTxUkHyqxzx/Ooj070vO0KucmgCRMmIYxgVPbyeYjwse/y96qhwYiiHhTyajjk8uQEfQ07ha5aDBlaNh8y8VPGQ0Bz1HH4iqt4374OvQ4B+tKjkEdsii4rDX+ZSVHB6iogecdQKsHhj5fcZqFwJGJQ4YHpQHkLbPtlKkfKRinMpV2Q9CMioT0PZhUjt5kQcE7l/pU7jsaGlv5c2w9xitc/K5BxyOKwLZgzK4IyMVvFg8SsOSKCdgiIERPXBJp0hGzk8HpTLUja4PShQPmQ9iKYFkNmIEdutQFf3vHccVIvCsBjpUb/KvPY8VTAULxg0o/eREZ5WkY7iCDQp2seevBqAGKflIqRTxUMnyufTrT1Pp3oAf2pr+lLmmN0oHYjP86ctNNOQc47U0IRj+VIDTpl21HmmgJVIp4+tRKefapF696aAkApjrwanQU1160wKTrxVOUYJx1rSdevWqdwnBwKBohjb6VMrcVSRsH6VZRuOKQiYH0604fSoweePSnqRilYCOVcgkVRcY61o9evSqs8fcUrAVe2DSCnY9aQjiosAg49aPX0ooxnvUMYD3oHvRQOnNQAo6+tOHSmj6808dKkBV6U7+VNFPAzUgApQPWgfWlHHBoEAHH8qAOD1padj8qAGAcUuOtOxzRj86AGbfWjHHSpAOtGPWgaGAU8L9M0oH0pwFFxgAKeoGetIB6dKkUd6LjQoHWpF9qaoqRBQUPUe9SoMfWmIvHFTximhEsY4qZV7Uka8e1TItMBqpxViJKRE6mrMaetNIpIVE/GrUMfrTYkq7CntVpDHRR9sVajSlhT2qzHHWqQgRfap0WlReKnjSmARrxipo0NKiccVOiCqQgROKlRaVV4qRVqgEVaeq04AU9RQA0LTgtOA4pwFSwGbeKYy8VYC01l4qQKTg1WkFXpFqtIvWs2MrYp6D2oI9KmhTuakB0aVMBgc0ZAFRO+AcVDAZO+AcVnSv15qxO/BqhK3JxWMmBHI9VZG4NPkaq7t61jJgRSN61Wc9RUz9agb2rFkkDdTTGHapD7ioz061BnIj7e4pD04xzTjSd+apIxYw/TNIentTj0x2ppAxVEMSk+velpO1ArCjmlFNzSjvmgQ8HNPHSogeOTTx+lAEg46U7tyeKjU08UDTDNJn0OaD0z60d6hlIeD3pwPrmox+NKD61DAkyMdOKYWppb3ppasxAxqJulOJphoBET8jpzVeRfzqyw7VE464NNMtFVh69aYR196sMvtxUZGKtMpMi+lNxUpphHv9KtMCM+oo7044waYa0TAAf509TUdAOOtaJg0WUPepKgjb16VLnitERYCfamFu1Kx61ETWiFYXNAJ/CmbhSZ/SqCxKG60oPeoQR2pc+9NCsTbuKN3Heos+9KGx1NAWJdxpN1M3c0gb0p3FYcWphPHWgntTSfWi47C7qbn0ppYjrTN31qSkiQmmlh61GW7UmfegdiTcO9Aaoc0Aj1oHYnDdelKGqENjvS7vpRcLEu8UVFmii4WPQ19z+VTp0quh9KnTp1oO8lWpE61EtSr0poViQU4GmD2NKPbFWiSVSP/ANdTJ7VXU8VIhNWibFyNuatRNVGI/lVqJh61omQaEL+pq3Gw/Cs+JuOKsxtx1q0SX42FWEYVQjarCPTAuo3FTIapxtx1qZH96BFtTUimqyuPWpVfjrRcllpCMVKp4qqj8VKrjrTRLJxQTUYcUm6qQhxNITTc8UmfWmIU02lzSUAFJ+FLRQAmOKSnUcUAJjg03bT+MUY4oAiKioytTkVGRxQBAwqOpnHJqI9KQxhHWoWFTNUbUDRXdRzVZlPNW2HFV370ikyu2KgYYzVh+5qBupqWNFdh1qE96neoWx0qGWiJhxioX6Gp26GoWFZyRrErt+lR9zUzYFRmsZI2iMpDTu9J61hI2SAelOFNpwrCSNESJUyDmokqVP1rFo1RPH+lTKBUMdTp6VFih6ipFHFNUVIoqbAPApyjjNA9qcBU2AABThQBTgKAQgGaco4pyj2pwFSNCYpKfikIoGR0mOKeRRikxojqNhUxqNxSArtTCOtSN3ph70JiIWFQv0IqdupqB6oCu/eqsgq2/Wq0nemgKjjrVeToatP3qtIKtAVJB1qrIB7VbcdearSfjVoRSkzyKrvn0q1L3qpJ/wDWqkSV5M4qrK3XmrMveqcnvVoi5XkPWqcmeatSdDVZ/YcVoiCq4qJqmkHXNQPVoCFutRn609/WmHpmrRI00maDSDvVCFFL2pvelHJoAcDTh09+1RjOKUe1AyVTxjNOHuaYtSDjnOaQ0OFOHrTRilGetIY8Uv8AOmilGKQx3finD9aaO9OXGaAJF9jUg6YxUa89+KkHp7UrlJD1AHepFqNR6c1ItTcaJAKcBTR6YpwqbjHL74qQd/WmCnjilcBw70o6Ugx3pfX2pAIKD0oHHejNNANIprdKcaQ4wapMREelMNObvTCeDxVIljT71Ge/vTjTCc9qtEMYe+TSH1OaU/Wmk+9UiGMY4OB0zTGPBB/CnN9ajJHSrRDENRt1xmnnoajOMVaM2NOMY4phzyc08/SmMatEMYfwpPYmlNN74q0QwHcc0nfjpR9KQ96a0JFzQDmm0CgOg4GpE61GBx71LEuSBQCL8TYjAFWIPmJ54FVfugKOtWrcZXavrUlplyzXzHwOpNdTK6adYhFYeYRzxWTo1uvnjIHHWmaxP5kpVc46VG5a0RGlwDvJJyR19zUMKeYcAnGfzpJ1CxIg+8a19A09rrUoIFyQSC3tmgErnQCJbLQ4yygyNyufU16B8J9GfYb+55kblfpXEa9GG1GOzXPlxEKPf3r27wZZC20uPIwNoApwVzSWkTR2rG0jnG7HFec/ELUFgg8sH95Jz+HNd/qtxHAru2cAZ614X4n1carrrrn92hwcdgM1UnfQhbGdbRKsQyP30zfd9uwP869Et4jY6LHEp/eOoB/HrXI+FoBeX3msoKow2/Qdv5V2WoybCS2MA8D/AD9KEriXYx7+ZhtgB+Y9eO5/+tXO3MqzSysTlUGOnp2qe+umDTyhgSBhfdjWW7bLVYgRukO4/Smh3sgEvO70HH1rnNfuThIgeeSfxrZuJBnauMKMGuTvZTNenknnFXFdWSxsbFpEA68DrW5c/JEsagbmIz9KybJQbw9MLWi77rgseiYAqmCWhZkOyDylxkjmk08bFYjGBz9aiu5OCT0IAp9mNtqCTy2AKL6DSNGNmGzP3icD8e9XJgkTIqgF2IbGM96js03y7yBhBkVJbMJNSLPgsDwPSouaRR1WmWjJEGl+++Me1bhxlQOn+FUbNmyGcgnaOlWZAVKuTgkf1rnkapWHzSHPOcdKrWsgSO4nPPBx+HGKW6l8uFy3ZeDVDUpvI0h8ZBOF9KUSSz4akMsMzhed2TXXWygBgBg4HSuM8DOptJwc8gH+ddlbuokRB1IpXH1NFANoHUYpmQiMR0UVZCBVwPpWfeSeXIqDGWIzT0sCM67dhZuB95jtFc/4ol8m2tLVf4yHPuR3roDIJ54oUxhTvb69K5fxfIW1uBFH3MA/nUxH1O18NW4+xFJBlcDjHBrNu2C68yxkgCLp9DXQeH2H2Xfxyo/HFcveP/xUrsOhjZalbiR0EMiy2OMdz+lYkBWSRMHiNs/ka0NJcSWEuT0P9ao21qRBJIWAUNj8zVJhaxZuE/c3JHITkd65O6fzFcE8gZNdpeEQWEpCnhc15/clsStgAt8o+nrVJoVi1qXy2EZGNmBk+3+NYtzcgpDIx4GAue1a+qqV0eIEfKUzn1rk9QmHkRFT8qtmtIMhI0bm4O23c9fMNbnhqYQ/ajycOPyrkb64JihYfdBGPxre0OcBb4k9cMPftVuQmro0hqSy6ldJGPnCA8+3rUto3m34lJGxVxXFreyJq0+0nLpg/wCFdnpSIdHmfJMnXr+H9KuOupL91Gjoty0l9NMeXkPy/wAq3dHuGjMjyDhzs59cdK5HSZhHPCOpLAfzro1nAjERJLAhsdMc4qHIOhoTXEeBlc4YEY9OtdHPcxtbyIMY8rNcZ5katICcEbe/TrWtbzrLp5cHkRH8cc1mFrnN6jcCWZdgPyMBwfetPX52jayVgQua5y2uJDG/ygh2HP0P/wBat3xQ3mPaYPylh39RV9Aktja08408D3yKwtXl8yRoFBJY81PaSyPEIYnPX9Kp3AzrMUYYjPDH6moTuVFWIbW6kDG1ZTgDIzWiUZLRYiCuQD9fWs24YLqH7s52n730/pWhfsxhhlUnb/F+vSkimhLUvEkMZHt9eao+JEYaY5yMZA/HNSyymOON0P8AGOveoPEG59KkxnIxQmSkc/ZKDdojYBI/P6VjeJIM3j5xnaPxrUAZTA5GCD61V11XPzKAcDFVcLHOWkrtbsGzmMYpiXBRUA4xxSSuYxFLGAN3Dj/GqtywTYx4JbNF+orHMeJkP2wuc/MM1gnuOa6jxGpfZ6YrnHGF5q0yGiBhuXbjnOR700qDkHqOnvTj0yCcg0s+NsbgHB4NUmRYrSDIyKhPQg1adBtyPwqueSRVCsV2XBq1AfMQox6cioSMg+o/WkUkMCO1SyUh3TgZ64olO1AM8n+VSybTiVRx0OKrykk55I7UD3BDsPXimORvYDoeRSMe2ajf73NHQRc3iS291/pTEbcoxioIX2sR60I+1ivY07hYuFyDkY45pso2sHQ4Peo1br6VIpDIYzzjgUXCwHbLySPT3pIwFcqW4IxUA4DD+IU0MeCTyKEwsW428qUoD0PFdHp7h4ACa5mY5dXTvW5pcm6DryDSsLoW4zsldT3NEnySoR34pshzll6rT7gq8Cuuc5BqkLYmXAP1GKjPzJg9+n4U5WyE+mRRLwisOme1JMCGA4BU9jUmeoPeoSdsuc8EVJkkt7Uh2Gyf3SenSljPY0ybPWlQ9CKARMPxprexpRQ3Q0ARGnQ/fAzSUgOGGaEKxZuk+XIB6VT/AJ1pOQ8Yx0IrPcEE00wBalU9hUC8U8GmmBdiIxxSv71BCxqRufwpgRN3qCUZBqdzUDmmBlzDa59KfE3ripLlMjOKqglTxQBdHc+tOz3PaoYnyKkz+VIdh2eKa3PBoz1APFMY0hEbAdaiI6gVIx/EVGx68VNgIz3NJ7c0p6UlZy0AX+tLxz7032OacPSs2MB704UgpR9ahgOXp1FPHpTF/pUoHHFIAFOGcfhQB60o9KBAOn4Uv16UAYGO4paAEpR0NLjmlA9cUAIBSgUo/OnAUANA/wA4pQByKUY7YpQODQVcB07VIoHfpTQKeo68UrjQ9RUiCmpUqjmi40PQVYiXNQoKtQ+9NFEsa8d6nRfamIKsIOMVSAkReKnjXjNMRee9ToKpAiWFauwr0qtCvINXoh9a0QyzCOKtItQwLx71bRRWiEKiip41pqrU0a00hEiL7VKi0KtSKvNUK4qipFWkUVIooGCj8acBTwtOC0ANApQKeFpwWkAwCkK5FShaUrx0qRXKMi4zUDr1q7KtVnHWs2Mq7ealTgU00A8GobC4O1V5H4PNOlbHeqM0nXBrKTsMbK/WqcrdakkbrmqshNYSkBG5681CaexqM1lcBh6VGV4qYD6UY4+tKxDZScEfSojVmYDmqzYx70rGbYw9eaTijtSdOlNIzsNPekNKe/GTTTTJsIe/Wk+h5oNH1oFYM8daT8aP50g9DSsJoeOKcP0qMU8HnFFiSRfapFHHGc1EvWpI5CpyeaQJD9jDqKYRUjSFjzjFMPSpZSEFIT/Kl7GmtWTHuNLUmTSkU3tz1FQMKPal+nSjHrRYLEZHamMKnK8VGR1oQ0iAioiOtWCKjYdhirQ0iuR60wipWFRtVoaRG3Som/SpW/Woj6GtEUkN7daBSH2pM/pWiHYlVqkD8VAGx1pd3qa0iTYlZ+KjJppb3qMsfatUTYkLdf50m7jIqEtxRuNUFiYN2pd1QBuppwagViXPvShh0zUW/wB8ijf14phYlDYFG7J61EG9c0Bz60BYmzwc9aYTx1pm7Pemk/TNSFhS3vmmE0E+tMJPWkUkO3U3PFMJ9qYW6/pTHYk3dqM1AX54oD0XCxYVqduqsH9acHzmi4WJ9woqHdRQFj0lG54NWYzkdelZ6PzVuFqo7S2v1qROn0qBDU6Y9aaAeOlOBpo6d6N1UiWPHFPU881CpqQN6VSZDLEbVajbiqCGrMbe9aIkvxPVqNqz4271biNaIguo3ep0bjrVSNqmU0wLaNUqP71TVqlVvTigC6r8dalR+OtUkb8amjbighlxW4qQNVVGqQN700SywHzTg3FV1NPBPrVoknDUoNRA04H3oAkBpaaDxSigYvY0UlLQAUo6UlAoQC0GiigBKY3Sn0xulAiBx1qFsc1M3eom96RSIz0qNqkIqNu9A0RN0NV3qw3SoH9aTGVZKgbvVmT3qu3epY0Qt6VC3Wp2+lQtjtUMtbkR71C/Spm6GomrORrEgbqc1Ec1K3Q1Gf51jI2iMPU031p570zrWMjaIoNOWmdaePpWEjREicVPHVdffrU6H1rJo0TLCVMh45qCOp1qLFkyVKtQp71MtRYCQUopBSipAetPFMHenrSAco9KeOnvTVp9IaCk+tLRQMZ68UhFONJUjQ2o3zipPyprjikBWb6VEfapmHB5qJh7UIRC1QvUzdKgcdaaAgf1qtJ0NWX74qtJ3qkBWfvVaTvVl+9VpOhFaICrJVaTue9WHPUVWk6VSEVZRycg1Vk71bl4qpJ3xVIkqyd+eKqSelW5O9U5e9aIgqy/pVZ/arMlVm71aJK8ncgHFVX61ak71Vf1z+VWhER60w96e2MdTTCfpVoTGmmGnMfrTCe2aokXtSjryM03NAJ7ZoAcPWlHpTc0o6UDRKvTrTx6Uxf6U4UmNEg96UdOtMHrT1+tIY7tTu2KaOOtOHNAxRTxmminCpBD1FSr39KYuPxqRaRSHrUopi08cVDKQ5Rx708eppop340DQ4cVIPYUwU8VIxR70vagUdvegQdqKX+dGOKBDDTGqQ9KjPTtVJgRtUbdD71I3Tmom71SZLGPUZ6U9qYferTIGmoz0p570w9OBVIzYwnimN0p56Uw/hVohje31qPtT6aa0RmxhqM55qQ1E361SM2NPX60lB6005zVoi44dKTtzQOenSlGKpCYz1FKB2paAaaEOUY4NWbVCX4zUKcngZ7VobhbR7BjzCOTQFyPB3ED1xmteyhEUYLEbzWVan58nnH6mtBXI4yS5H5e1Zs0ijXsJxHFPtxuIwT6VQmk3OFXGSc9aLZxHHIueSMmq1uC9wW7Ukii643XCLxxiu78AW3kTzXjjhUIH+NcLYKzXPIG5jj6V6e8X9n+FvkCq74LHvzxSkXFdSjpsb6r4lVc5DOM8V9B2MYhso0HZRXjHwms/O1UzSAEp839K9a1q/TT9OmnLABVyKuLsD7HG+PdSK+ZBCxz0NeJOW+1NFFlpHPzd+/Sus13WpJorm5mY7mPHPrXM+HoyWM7jLM2Bn69aUdXcmTex6N4Vt/strGiqc/eP+frS+IrsLcJCnHGT/Kr+mSR2+nKWPzEZP0rj9SuvtN/LKDwP6U9RlC8k825WFF+7yf8aqTPuudoI+UY/rU9tytxdHoDgf5+uKzA+xGkbl3q0J7le9kKLLg8gYrn4fvO7HqM1Z1O4ZQU53McfrVWX5Ytoz6GqS0JuW9LT5Xkyc9frircLEylSe/P1qtARHbxxj7xxn39qlgb96ijGSeT7UhoszASOq4+VRz9PWp4h5ixseFB446AVWu5NimJepIBPpU1y/k24VeuBii90Ul1NfSW864mYsSoXaB+dXNAhMl/JK/3EOenSsXw5IwSYn2rrfD0PLxn+IZP1NZN6GsEdJbgnDbRggflT5pRsZ5flAHFSBfLjXHYAfnTL7aUjRgMu1ZGlileskkKqe7AVk+LpNlgkYPzMwP1xkVp3bDzrdSBjfk/hXP+LZf9OjQ42gcj6mktxNaHSeDAsdowAJOBnj1rrrIGS/74Cj9K5jwZGW00yEjJb0rrtLTBZyeSfyFRfVjtoaq42kmuf1GULOjE9G5/Wt2U7YevI5rldcYeXvORtcDPrTTvoJLqSaYysbuVRyjgfgSa5nxE3meKJFVQAFU/ia6Pw8hne/Rc7SwNcvds1z4xKbfu7c/gcZoi9bD8z0jSP3ekocjOyuWhkEmoPM2M5IrqocCwwMeXtP41yunxlr5Dxsd9v86BI1/D8Y+xyox6sSPoTV1bNVs5EDZJOelUdNU2dy0Z5Vm4/GtbO1JS2Mr/AEo6E3KWtYNnMnYR56V5xcEyEKMkZzXousyKumTSHGTHivOo8tGXI7enrVLQaehe1didHgUDquK4LUW/0MbT0bB9q7u/c/2XbDHfH4VxF+DGsyN/FJlfYGtErERIJJy1hCR24b2roNHm2rdFsbTGp/GsC0RWtZFIPUe/Natj/qXQgY28/UU2x20KFmQdWuHLqAVOM+vPFdP4X1DbAYZMYkUoc+tcSj/6UxjweMenNXNKuWW5QqeFfFVF2E43O/010hlwQCVJI9snrUs1wY72SQsCcgcHPB61lRTGItI2Cvt+hpY2Z3uHY8gjPvzSFbQ6Gdk899rZDop+hrQ0S7TyWjb7u09/qK5qxn82KUFsvg4+lX9Cl2yQ+Z92QY9fUUluFrIpuzLFHHGw5cg++DW14kZ/s9ntwQCvT8qw5Yz9phRcjbKWP0/zitW/lZrVeSChA59Ov9KGG7RY0yXyjPtxvG38Kd5qN582D5nQcemapWJbF5OBwy/ljinWdwqXSDaCr4HPv3qYjasPtT506ZIywbtWpZKZbaSCQ9FwO3Wq1wnkakFVVGemKns95kPPPpilcdtDKBLQmFvvRygfhmjXnaS3njQcLg9Px/pTtSYW99vK5DHJ7Z96tX0fnrdtGvDoppN6gkji33GRYTnaBu/Gr89uGEaNzvH58VWeJg4Y5+U7f1rRuFzDayDPynH4VVyWjhb228szxsvTp781jS/NDhycq3H4V1uu7WuCFB+YYrl7yM+XKF/hbNPqSZmpoHRyw+XAx7Vzt5EEYg424rp7k+ZYHAGcYrAmUPESccdKa0FuY4Uh9tKVJjZSTgDipnUjmkfHljPXNUmRYp8sn6VC33+h4q04wTjuf1qCYfOB64zVktEB+/xQVAbIAwf0qaXavyr19cVCxKjjvRuBJbnazK2Np4qGVSpI468U6U8bl9s0FvMj3DG5RRsSVmPJ54FRscjJ7VI2DnFR+xoAap+bINPkHzZHXv8ASomyKkc7kVh16UASRtwQacCV6g8dKgzgbweSKlQ70OCcjkZoDoOYhwSBhh1qI8jnqKcvI9xTTz9aECJl+aLj7y/rWposuCfQ1jx/6skHBzV7T3AkBGMd6Yje3ASOMdcfjTo2GGj7dajkxuVhjFLIfLkjbHBGPzpXsK2hZg+6oP8ADxSAgxsh7U2NiMejcU0HaxJ7nFAIhQ5JU9ulSqc7xjtUMg2THGcHmpN2JD6YoAGyV5pIfu4PNObPB9aYg5IpAWE96VhxTEP59KkPQ+9MaIe5zSPnHXpSnqaRuaBFq3YtHgnpUEy4NSWp45NOulwvFAilxTlPNNNA6VQE8Z56VMTxmqy5qXdx14qgGSGoSe360+Q9cGoSeuM0AI/IqjKuCfWrpNVZu/NA0RRtirKNuFUuc1NE5pAWM8e9ITTd3XNBPGc0hEb1ESKe/eoz371LASj8KSgdKzkAD606m+4pwrNjHilA9utNH61IvWoAcq1IB+dNX604cGkA78aUdOlIKBzQIUUuOeMUD0pwpXAOKAD36UCnDpzRcAHTrS4oA9KUAA8knjNFwQADOKUClUU4dKBgF96eo60gGB6n6VIoGDQNCoKlWmqOalQelBSHIPSrMQqJBzVmMc00UTxjirCDjiooxxVmNeOlUgRLGPWp41qONatwxnrVJDJYFOKuRJUcKce9W4k/+tWsUBNCvFWkX2pkS4HvVhV+uKtCFUVPGKYoqeNapCZKi8U9RSoOPapFFMkRVqRBQBUiigBQvSnhaVV4p4WgdxirTttPAoAxU3FcaBQeKWkbgVNxFeXGKqSd6tSkHNUpT1rKTGiImmE4GaCeagmfCmsnILkM8nUVTdqfI2STUDHisJSHewxz1qB+9SOc1C3esWw5hhplPIpKm4XG96Q5wafTWHFBDZVm96qtirUlVn6HiqRDI/Wm9fqaX8RRTRNhjUz608imYPTtTsKwh9KTtz2pTmmnpzQFgpD7UppD096kVgBxT1qL6U5T7dKCbEy479akXFRKR2qRTxUsVh/8qXsaaKWoYIWm+opwxTahjG/nSYp5FJioGMx+tKKX+dHOOaBoTt7U04xinc4pD0NBSRERUTDrU5+lRMKpFJEDe9QsPWp296jYHHarQ0iu/Q1EfpUzj9Kgbv0rRFJDDSetB6fSmk1oh2F3UhYUw00k1pElofvppamZppb1Naoiw8tTdw/Coy2OlM39apBYnBFODdhVYP605XHNAWJ93al3ccVAHHJz0pfMHrQKxNu4oDcZqDzB2NJ5lA7Fnd9KTdVfzDzzzShz05pAkTZ60xmx1/SmbsCmlqTKSBmxTGYUxmHTNRlscGlcaQ8t1Hak3VFu96TJouMlD+vFLv54NQ54oz70AT7z6UVBmigD0lJPerUMpA61lo/86tRv2z1rVI6TVik/CrkbVjRP78Vfhl9TTsBfB4xTGb0qJZc0pfNUSSBqkVveqyn8qkVvQ0JkllWqeJuaqKTU0be9XFkMvxmrUbVRjbHSrMZrVMzLsbVYQ1Tjb86soaYFhTT1NRKeKeKBk6H3qVGHeq61MhoJZbQ8VKKrxt2qYGqRmSLThjHSmLTx9apCHrTgaYKcKYyRT604GoxThQBIKOKQUooAWiigUWAXtRiiikAlMfp1qSmsBg5oAqt39ajP8ql65OOO1RHvQMjNMbipD0qImgaRG1QPU7YqF/0oGVpOlV3FWZOlV36VI0QGom71Kw688VE3es2WiE1E9StzmoWrORrEib+dRnjrUjdTURrGRtET8aZ9TxTzim1hI1iIP0pw6Gm07rWLNEPXpUiH8qiXOKkSosaItRH1qdKrRnirC9KhopMmXrzUy1AvSpVPFRYolBpwpg9qcOahoCRakWol/CpBSYWJBTs0wUc0rDHj60dqbS/jRYYUlLSVNhicU1v0p3amn3pWAhYVC4qw1QPSEV3qB+tTydDVWQ9aoCJ8Y471WlPWp2bqKqykU0BA3eq0x4OasN3qrN0NaICq5wT71Xc/lU0nvzUD8ZqkIgkxiqjnk1al9aqSHB/SrRJVm4HB4qlIetWpjwapydTWiJZXkqBqlc+p4qu59KtIgikPFVX6VYk96rOatITIyaiJ9CKcx9ajJ681aQhGPXmmE9qCeOKZmmSPzQDUYJpQaAJBT196iB/KnpQNEw6Ypwpg6e4pw+lA0PBpwqMYp6nmlYdiRaeO9RrUgpDHCnimCpFqWCHr0qVOtMXpzUiD0qS0iRc9KeO1NWngDvUlWHAdKUelNHtTxSBIevpT1FMUU9aQ7Dh0pR0oHTij6Gi4B9KT2p1JmkKww5xTGHtUp/Go36e9NCsRN0qM+1SGo2q0xMjbHOaiPtUjd84qM1aM7EZxzmmZ4NObv6VG3TmrRDEPfFMPTilz+VNPWrTM2IT70z6UpNNOOtaIhjcmmNgg048ZqM/WrRkxvbnoKTg0E9eaaCBxmqRmOHsaXtzTR9fejPNUFxcj0pQwx0FMzzQD600IuWR/eg8cc05judieuaZbfKhNWbOEzTBQOKTeg0tSxbp5Vv5jfh702BiGMh6ngfWptRk3OIkxheKqhtp29sYqFqa2sXbeQb2JJ5XBp9pGcs+MA8D3qKxG4SOR8qjn8av24DSoMYAOPwp6JC3ZqaBbF7tCVJ5Fdp4jkKaesZyAcAZ9qyPD9v8A6ZGq9ua1tVj+3aikKn5EIz/n8qxveR0RVo2PQvhXYCDT/PZACw6/jUHxY1RIraO0RuW+Y89MVueG9ljoKknCkbs+wrx3xjrJ1PVbmXcfLViBz/COK1lNJWRkldnPaxK0+yBTkdW59a2PDcBlUAAeWpAH19a5hHMkpA5dz+QNd7osHk2ahQB0GfenHRC6mprNyI7IRRth5BgfQVyOpSsiFVJy/Fa97OZrhjkbUHy/hWDOry36D0waaZXQmu38nTooAeHxn8D1rJvZwNoUH5R/OrGpSefeER8RpwPYVl3k28vjscVSZHUyL6Xdc9OlPlPzLn6mocrJetn7o4NStIrzbgp2rwKq+hJbfBkTB525p8ZHnDBOQKr2uZLklvTgU+Ng05PpxR0Gi5C3mTojEcNmnam20bQ3fNQ2Z3XDOei0y6ZpbkqDU3saWOi8LRAwMzcjP54rtNBtw0jSNnk/pWDolkYdOXPcfzrrNJhIdCTgYxWEnudCjZGlKigj0J/lVe4j86eNiRwRirF7gLHnqTVSYldmD3qQM+7Krfov90frXP8AiKPzdVlJJ+UDA9K2j82rS56AAde9c/OWN5czyNkHKj88f0pID0XwTHnTB06c109im2M5PI6fSuZ8Cp/xJweeQCOetdXFGQhx65+tRa4+g26Yrbtk9eB+Jrk/FkgitIkB5Zw315611N3zEqsec5/KuN8ZNt8jJFOIjV8JqftF2oJ5jUj35rltN58c3SNzwR+RrrfCR+aWRunlAGuU0Fg3j25Y9CSB7ZqYP3mD2PQpiBo4Cjopyc1h6WqySxBF5VtxNbF38ukMFI+UHP51l+GPmSSRgfvYqmxJaMs69m28t42/iB/WtNyWjfgZZQayPFistosinBHI/OtCOUSRwEnrGtC2JsZ/ipgukugI3HArg3YxQRoAdxJ/IcZrufEMayooLfL3/DmuJiYXDlhjCcDPoKtWsNbEl7Kf7PhGejfln/8AVXMagqmSfcSSrAj8637hSbMhyDtkH61harD5d7cBuS4U/pmqJS7FGxX5Z2GcZHH496vwuq28mR8zKT+tUrLH2qdVPBj6D1Bq6kOQm7O0Kc0+g7GBAy/ahySoOW/Dj+ZpNNlK3Jx08zP4GmuohllAOSxx64Gf8aq2+Vl4J4YD9aoaSPQBKEt5BIAAwUD2IOeKnDoq3BUn5lz9TWJPOxKRkdgT/jV+GQNGy8fdqbiSJreTYAA4GV4/Cr9rK37ja3G7HH1rDbcHRVPCjA59adFfMPKCkhRJtz709AsdU0qNeRqSA6Nx7g/5/Wp5pOZmYH5GUkEY9qx9QZgm9fv8EY9jWtY3KX1uzyAGQgbvfFJslKxI8ph0obUIaRsY9uv5VB+7jeFmyGJHHqfWr18okaBEOQUyOPQ4pl7F5kVsQmGUAcdsGovYtK5o3UyStbylPnDjJ9QeMVp6TFl5SyjH/wBesyNNrokgPJXH1rpdMhCSTK2Dg4+lTcHojkvE8ISU7gdp6e1bGktFNaSxDG8w9KZ40tf9B81eqcn2rM8Nzf8AEzhAx88P60r3QmtLo5+7Bga5h9GyeKltJN9gmeduR/8AXq94ntRDrvUbJBzVOyZFDxx52hv50cwWujlfEP7q8Ey5Kg4NYupIjMxjztfp7V02uRJJJMjMQD/SuTZ/NsmiX76Z5+lap3M2jMk2LE8Yzj+tYDLsndD0Y5relXEeRnOKxb5eVkXPBpisUJI/vgjp0qu/IGMcdavyFQ4PrxVWVAjn0PSqTJsVmHzjOMVRvZtj8f5FaMq4yfasq/XI4Aqk7iaHSENGr54xURYbRTLZ8R7H+70FNYYJXPINFybEitwVJ61CMxyEg/X6Upbcpx1H601uRn0p3Eh0gAO5eh/SoX9hUqncpXtUfqPSmFhre1EecEDHrR2OfWgDByBSENUcEEinq+0jH0pkgw2R06GlLEAYp3FYnfCsGB4P6VG4xRu3Q4OeO/pUYY45PFMSQ+IhXIzxUkDlJcdu1Vjwc08n5sjtSGdUrfuEbqMA1K/zxKBjI/Wqemv5tqATyABVtDuQDuDigRJA5aMAkcGiY/Kw98/rUMR2swyMZyKdI5Pm5A4AoFsJIS0WT1607dnafahDlSCBgimJxwTnHWgCVTuQc8imjpnuDSxHHFNPBPoTQMerHNWFOVzVXPpU0J460ADVE3pz1qw3Sq7dev1oQia2OD7VZuBmH9apwnB4q4SGiIPWgRmHuDSg8e/SkfhiDSA4zzxVpASqRT896jU8fWl9STTARsYNQnrwalOSOtRGgBhPFQy9DU3Y1DL0OaBoqv3ojbB5ok+lQbsH2pAaAOR14NB6GoYGytTHpSERP68VH609/bGKjJ560gEPf3pBzRzikHpUSQDxSj/61NH8qeKyaGOH61IvtUa4xTl9PSosBKPfrTxzTF6U4VIhw4pwzTR704UrgKOacB6ikHc0opCuL9OlOHtSD68ClHFACjrz+FOHvSY4yacKBgMU4f5xSL6U5aATHL7YqRcfrUa+1SrwKCkPUelTIOOKjQcdqlQe1MaJoxViMcd6hT3qeMDOKaKTLMQyKtxrwM1Wh6Vch9MVaGWokGKtRrUEXv6Vajq0BOg4q3CBVeOrUHXmtEBZQfpUyDio0HHepo6pB0JFqaMVEgqeMVQmToOKlApqCpVFMkFFSoKaoqRFpXAeoqRV9aRFqQdKVwuN28UmPWnmmOeKlsm4xiKhd+Dg0SP1qpLJ2zWUpDuLK45qpK3Wld/eq8j+9YykFxrv15qnM2eM1I79eaqyN1rGUxXIyaiY8U4nmo2PB5rFyJ5iNzURpzZptZthcTtSUtHahMLiUxhUuKQjNUgbKUg61WkGDV2ZeuaqSDqKpCIDRSkc+tAHtVIVhjCmY4qYrxTCKYJER96ae9SNUZpFpDKDQenFNJpXDlDtSjPrTcj8aUH0qbkcpIp4qVCOahSpFNJkWJQcj1p2f1qMU7P51DESZpPWkB456UCoYhfc9KTFHajtUjEo7cUv4UnapGhKYRwak/GmHp1oRaGHFRtipDx1qNuhq0UiNqiYd6lNRN361aLSIXHX1qBh1HpVhxxUDfpWiKSIDmmEdcdamb0qNu4FWh2IW6H1qPNTMPX0qF/Y1rFk2Glv0qNmHrQzcVCzVoibCl+vNMLe5zTGamls1VwsSbvU0b8d6i3dqTPWi4WJd/vR5h5zmod3XmgNRcLE+/3oDd81DupytRcLE4b604Nx9KgU+lODcdaVwsSlvfpTXam596aT61Nx2ELGoyc08jmm4xn1pXCw3nFH170uKOaVwE7cUD86XpmincQvHpRRRQB2ccnvVuKT0NZET1bik4rdM6TUST3zVqKX1PPvWUknvUySntTuFjYjk9KsK2ax45u1W4p/U00yLGgp+tPVsVXjkBHFPDDNNIktI3NSo1VENTxmtERcvxMcdatRtVCI1aibsKpMmxejb3qyjD1qjGasxtTEXENSr9arxsamSmgJUqZOtQrUq0ySxH9KsL0qtHjPWrC9PaqRBKtOFMFPXpVIQ8deKdTRThTGhy09cYpi+9OHNA0PFOFNFL2oBi0UUetIQuaM0lJmgB2aZJyMGg/WmE+tOw0MfpxULVIxqJqQEZqNqkNRn9aBkbYxUL9DUzVE3egEVnqu9WXziq71JSIG68VC1WG71C3pUMtEDZ6VXboc1ZbvVdhWUjWJE3WoyOtSHpzUZHpWMkbJjTTacep9KYen0rCSNYgP5UopBmnVkzRMUfpUqVEB+tSJ6Vmy0WY6nXp1qBKmSpZSJ0qRaiTpipFqLFkg6U9ajU09TU2AlXpTxTFpw/SpsMePf9KcPamZpwNIB2aM0gz36UUMBaM0UlTYaYUh6Ue3NIaQyN+9QN3qZ+9QP3pCIJehqnJ3Aq3KeOKpyfhTAhbvVaTqasP3qvJ3poCs1Vp+lWmqrN901ohFR+pqB+lTSYzVZ+/JqkBXlPUVUlNWZT3qrJ3q0JlSY1Tk71amPr0qlKeDWiIZXc1A565qRz1qBzya0SII3NVZD15qeTvVWQ+p4rRCZG1Rk+mMU5j61GTx0qkTcQ+xpmeaDmmnFArig9sinCmDvThTsCHjrxUi1GtSLx9DSGiQdad/Wmj2p45oGgHtT0pAKco9OaQ0SLTxTV6U8CkMctSL3AxUa1KntUjRIo4qVelMQVKo9OtQWhy9KcBxSLT1qRoFpwFHbg04dKTGhVp4pFp3agY6lpoPFL+tIVhR3pO1L+VJmgBvrTWpzYwRmon6HmgQw96jbkU9qiarRLGH6VE1SnpURq0QRmo26mpGHeozntVpkEZpp+tPNMbryatMhkfHSmk05umajbpWiZlIaxphI/ClbrURPGPSrRlICeaQNTCR2pARzWiM2SA8UpPfNMBH5UflTELmnJ+Jpo5p4GB1oFctW5wK3tJXybWacj5h92sKxjaaRUUZJ4rrdRt/sOnw238Z5aom+hpTVznmyzsx69aj3HceBUtwDE2CDnvUMPzTAGhFMvLIIYNgGWfrW3pMBmCsRwOn1rnHYs+T16Cu/wDCVn5lqm4cdc/0oqaIukruxr6Yv2S2e5brjj3Jq9o0ZkkQliXkcKOOx71Ff7dnkgDCcHHqetaXh5VBNycbY1wv1rGL6mzXQ6LxjqX9m6N5ETgFUC9cc14zd3ChHx0b9QK6Lxpqr3koG790v/jx/wAK4qZzJIFB4FPdkJcqLukJ5lwG7k4r0CQi2sFRT8xGPzrj/DEO64ZyOFrodQuD5ioP4ef6VteyM3qyGYY+VTzj/wDWazkk2SyysenyrnuTxRcTN2PJ4H+NUpplEkMZPGcn3oQ2iKWTy5BgjBODWZO3zSHtmpb+QI4J7GqlxJ+7kJxirW4rWM6LLO+OtLAx3kNnbREQFfB5xgUisR+PH4U7kly0OZWY8YHFOtDkMx7tiqgbacA9ufxq5ZKfIJGMZzQ9EVFF23CndjOM8n6VJosH2rUCSMonWq7fubVjzvYcVs+FYvLGCDves29DSK1O2gXESIMcAYrc05CCmSOeKx4U5jUD5ulbtuuxkHGa57m9rC6gSZokB4zmqszEnarA/Nin38jC5iwOvFVbs7VmIP3eaLgZzyj7ReSdAOc/TisBmJshuzlpQBWxqAaK1lVjzJGPyrnjIzT2qZ+UkGqQJHsPhOPZpkQAOcYroovu4wcVieHgFtYwM9K34+BzSSEyrdKGIyPuiuH8WDdeIhyQoBP5138y8SE+gx7VxniOMfbZsLyIlI56YJqUrD8jX8MqDYyOBxsI/Af5NcZ4WXzvFE8gxkNn9a7nwqpGiQsV5ZSD79a4nwwuPEbMnQSkN78moSs2G53V5E0mnuoOMtiotOgFvAqAnqOfU1enGEZW6FqYikW4JI6/nzTWxK2KHiyNm08EEkD2pLUg29mxzzGB/SrmtqZNNYlhjHpWWkgTTbRycfKB+Rqo7AloVPExAtVjXJ3HBINctpyBxIvZTg10XiZ5DYwpGvzM/J9vWse2jEO6MAluuaeyDyKgUk3CNnaGH4AVkXQFzHNJkb1Hr1ArcuOGmABFYcG0xz/KCeT169s1S1Cxk6Yhe+4/iQ1qTIU00MD95Tn86zNNDrfLGp4+79K2tUiMOmKm4HacVSegNanILlp9oGQoqmp3XJIJxuz+Rq07Ou8oOrVWUsbhwVAPGfzoQ7WOjluFkeOPnAQDdWhaICwjBJBXqOelc9byh5mRgDwMHpiug0bO+PPAI/Ki2grDmPlhsgP+PWsqGcsRGuQgmz9Ca1rlP3bsCeDisCEFUmcdA4P0oT0Cx3t1HJHbq5ClGUYq34TIM88MuNxXI7d6iuQ8vhO2mUcoOT6VW0CR5NWjZScGPH15qdbCR090oW/gAOBsIra0izW6t2Yj5lzisW7DJqWnuRlckfWut0CPZC5GNpY4qGxt2Rg6vE9vLE5zjKk/nXRWaBVkcE8gEVT8UjEKkgEA8/nVqFsEqDwUFRcL3RU19PtGmSpg5KnNcdY7o9S0/AOCuPrXW6hLsjYHOGGM1zbKIzYEYyWwT/QUXshxWgzxWR9vt5cZLHaeazdMVd859Dg1Y8RON0TEkhXA/PiodKAIusHkMCKFsDVirrtqkkMrqDuArzucmG5c4G3HzV6xfJusT8oyeK8t8QRtb3TZA2vxWiZnbQyZuZB5Z/dnp7VnTKNzIRx1q5GNmELdDkVBeBlcOOmRVpkW0MduNysOQcGm3H+qDD61ZvFwxIxg9arIQwZD3FUmSitJ86dOorMuo+MYraRQMg9VrOulzlsGqTC3QxyMoc8YNIr5+V/zqRlOWz0zUHqvpVGZI4ZG7YNN3YBBPWlQ70KnqOlMXr3yOKAFQ4br7GlmQg7h34NMOcZFTDMkJ9RRcErkJxjvSgDB9MUijIIzSdODRcBJcbaaG4U0+QDZwTUcY3JjuKoVug+Jvvoeh6Uwdx6U0HnI7GnP9/cPxoTJ2EPX60uTyD1ppPNK2cA8cUAbWiS87ST6Gtg/Ixx0bj8a5zR3PnjHtXQud0ZweQRQwIyCpOOtPchoyR0NMZjtJPfmkDAOw5IK0IklDYK4xytM3fNkUgbHl56dKaOGI/GjoBat8McUSfePpTLdtpPNDkFmz0oQ0C9DipoxzioE6/hU8XHUUATkDHuKgkGO1WOq81DJ9f1pCIlODjjirCsdnJqoDg1MrDbg1SAglYbjTB7mnSjkkYxUY9+lWIlU+lLnPXqKjB5+lKD9aAHE9aac496dkev6U09KAIj3pj9OnIp7Hiom6d6Q0Vpvaqxz0qaVuoqA4zxigCa2JzjNXD92qMP3uKt7jtxnjFICJ+tMNPbrUfNIQmePejt1pO2KB7VLAePWnr9aiU+tSL0989qyY0PXHSnrntTR6etOHv2qGBIOnFOFNX9KcO/pUEjh04pw96aO/SlFSFx4pw6YNNGPxpwPHOM0EjvrSjHemg44pRj2oC47FKOnvSDHNKPwoGmKPbtTx39qaMUq/rQUPFSJmo19+tSL70DTJlqZfaoU9qlXp7U0UixH0xmrEfWq8fTirEYPamikW4e1W4v/AK1U4versX1qkMuRVbiqrFnFW4h69q0QFmL8atwrVaLpVyAcVogLCCpVpij8qkTiqQEqip4xUSAdqsRiqEyZBxUyjimIKmQc0XJHIKlQU1RxUq1LAcopaB7Uvai5Nxp6VXmfAOKlkPBqhcSYzWUnYW5FLJ1qq8nvSSP1qu7gA1yzlYY53/Kq0j0jyj1qu8npXPKohXCR+tVmalZqjJrBzIbAnimHpS/hTCaXMTcQ03FONJSuFxuKBS4oHtVJjTEpdtOA9KXHFaIdytKvHeqUi9a1HXiqUyjmqQLUolcUqinlTzmgD6VRSQ3HHNRutT4qOToaLlJFV+9RGpXPPI/WoTilctIaTUbHsKcx/So2P61LCw0n86A2OtIec0g6UhcpOj46nipVYde9VVPvUitxQZyiWlb3p4PfPNVVf1p6vwfSoZFiyDSg8c1CrcYNKGx3qBWJc8GimA5pc1IrDqKTNFSNIO1IfTNHrRxigpDCOcVG3QipTUZpplIiYdajPTvUp+tRsOtaRZaIXHFV375+lWmHFV5B1rRFIqSNjpmoC59asyDiqrjGea1iNEbSHtUZY+1OI4xxUZ4BrRMBrHjrUDHrzUrGoGPWquSMJ96aWpGIqNm600x2H7sCkLCo93XmkyaaFYl3/Sk3VHnFKDTHYeD2NSKaiBqRcUgsSKaeppij1qVR7ClcLAPzFHrTgvGc/lRt61NyRvam8/rT9pHcUmKQEdGKdxjijjFArjP50uPWilH6U0FxMUUv4UUBc3kkNWEkrNR/U1Zik4rZHUaKSHHXjtUqye9UUb3qZG7E0wLqyehqzDKaz0b0NTxtz1qkTY1opOetW4m96y4W7Zq3E1aIzZoxtVqI8cis6J6twv2qkQy9GasxmqaNx1qeNuaZJfjPrVhDVSI8VZjNMRbiOatp0xVSE1aU1aAmX0FSLUK/WpUI9aZJPHirKdKrR4qwnSmiWSjpTlNNWnCqRBIOtOH1pg6U9aCkPX0pw4pq9KeKYCjFLTacKADtS0CiiwBQaX1pKEIaaiY4qRulRPQMjJqNqeajNIaYw9KY1SHFRnHOKAI2zzULDipm6e9Qv35oAgfoagfNTt1OKgb61LKRC1Qt1NTMDUTjrUM0RA1RP3qZqhas5GkSFv0qI9TUzdDULcVjI1iMb2NM4/Ont3qP2rCRsgHvTx9KYPY1IvTmsZI0iOFOSmD6VInWs2WidOlTJmoU9KlXGallomQ1IvTNQp0qVelSykSinr71EKkUjvUjJVp49KjU+lPFSCHClB4plKKkZIDgdqXNRg9qM0MVyTNNzTc0maVguP3H1ppNNzSZ4pWGNc1A55OKkcmoHPB5qRkUh4NVpD6ipnOKrSHrQgIm71A/fFSMfeq8h61aERPxnNVZW6jipZW6+tU3bmrQEUnfNVpO/rU0hGDmq0jVaAgkPWqkp61PK3XFU5W69OKpEleYjkd6pSmp5W5PNU5Dwa1iiGyFz1zmoWPHBqRz1qFya0RFyKTrwaqyZ5xU0hHNV5CKtCbIW6e1Rk05vammtEiGxv1pPrSn3puadiRR3p46cGmDGOlPBosNMetSL0qJakXipsUmSD8KetNHSnqKRSHjpT144pq9KkUfnUjHDpTgM00fSnj2NK40OAqVBTAOPepEqSkSp0qQdaYvSnr0qblIeKeKYvtUg96gocOacBSL704UDFXpTqQcUuKkBaUfSk/Gl7d6AD6Uh9aB9KO2KEIYf5Ux+9PPSmN6GqQiJsYJJFRHpUrDtURqkIYeh5qNqkaoz3BqkyGRnpUZqU1G1WjNkR6dKjbpzUhqNuKtEMYehHao2qQnGfSom61qjKRExPPNQk+/Wnycc1E1aJGMmNz1FGaQ0lUjO44HkilFRjrTlNVcLk8a5PFSgHnr0qGM8cVr6JYyajeRwRKWZyAKL21BK5veA9JaWSS8lB8uIdfWm61dm41I4Y7Qdv613Wu2sfh7w5FZQkeY4w5FeaTMPOY5+Yisr3dza6SsirfSfv35PBqK26MfWmTcnOfrUtr0x+dWhXLmn2xnuY0GckjP517Bo1itpZopXG0ZJ6cVwvgaxW41FWYcLXpmtjyNMk8vqwCDtWNSTbsbQXKrmKiiUSyEZ3H888Crd9IbLS0iUhdwwfrzk/0qG2hMcECNjLfNx6D/AOvVHxPKwmjhHYevc1Bpc5fVZSx7Y7Vk2itNcNz0FWdWkw7bTx0pNPj8u13H77nirgjOWp0ugDyonIPy9Prilu5S0zyc46Utr+709UAG7+earXDEEA4GBV6k2sQPKZJcEjjisydw+oZ3cIQKtNJtjdyeQMj61kxEmOSQnkng1URS8ibV8Y3A+mPpmq1ztMEgHQAGpJv31o4zlkx+NV/vQNk8YqoiepSUjGBj1pRkt7CmLgNnvUyD92T71QrCKdzvxwelamlwmWBlB5zxWVajdIwNdD4ayDMxA2qOKUnY0ihJo/MnjgA+7wfqa6PSIws64BwmBx7VhxAmaaVhk549+a6rRYSI13dTyOKwk9DWmjorWMOwfn2/rWmQQyEH/PQVBYRGO3GRkHj6VbwDg/3RWRroVbl/MvYo1U5HNU9Qz5VwoxzkH8KsFT9oS4bIUtgc9ar3y7DKDnLRkiqEkZ+rDdChHTys/XFcnprGW8tSQcFgAPxrsNVAXR432/MI+a5Xw2Fl1K0TJJR8kY7ZoixNHt+jjZbxA9wDW4Pu9e1ZGngLEmR0xWshB6EUJiZHL905PBrj9fGNSwAcvARj1wT/AI118mSTk4FcxrS51u2JOcxuv9aV7jSNrwwANLiVeikj9a4nwxg+KLoMAAJSB7ndXaeFgV0Ukk5LMP1riNIZh4onjPDCcnjvzmkwXU9BnjG2bd/D0qQxjygBjGBUkyBXdjnBApxh+RTg4GOKEtCLmXqi/wCjkZ7Y+orHcgWNqpHCnFa+syeXH90ZNZNyFjs03dd2B3pqxS2Kt3Ks1kGbpHKQB7Csq3K+dI5BIJyOOorQwP7NnLDkSAj8c1AqlQRj5QBzTa0F1Mu9XcZtvAI4/OufiUQSOhBZnU/nXU6knzZXhWWuZvf3V2GJ9vpQnYpamJEzx6kFIPJrdunVrP5kyR1+tZl7hNRjYY+bA+lWEw0MwLEkH9PemmFjmd+6O424G1vyzVOOTc8so6FcfXHFXXQILtF7kH8qz0IW2JA7H+v/ANatFsHUn0+R/OznPb6V1Omzf6ZCrN8oOPxNclo7HzVzjJ45re0h2F2kbMDl/wCtK+gzfdBtnCkbSciuWyy+fGSc5z+tdhFGJGmiBGQ2a5G7Cia63DnHH51MdhNHo+kAzeGhEMlQh7dPes/wqxW9VG6AYNangGUXOiSRjkhcfoazdKjMerJCxIycH25pJ7isdffblitJAMhXx+FdN4aZ2s3Mnd8j6Gs37CbzRpBGDuj6e5FX9BmI00BwcpgH2qFsRJ6aCeKVY2pxjFSWa/KhJ6oKj19vNiCjpjNTWnWBQBtKcUWGtjP1kqlqzMeneuZikL6dasBkifg/jXUeJkb7HJsAOBXE21w32aOIfdSYE/XNSzSK0JPEY/0bC/eZwfxzTLBPLkYAHJ60ursXdgCcLj8etAZluSvIwgbNJMTLF2S0PlAHmuA8X2ronKkkd/Wu6mkZGQkgqepz61y/ixcwHJzmtFsZ6nnk+5NjjBHSi5xJblh2IzRIB5bqSeDUVnIAxRhwf0qrkNWKko3xkjGf61SI2uGHUVoTr5cjADgdPpVW4jwqtwMmrTFYgkPzKR1PBqrcDbHgjrxVqYeWy56E1DNhl5GcYxTQjCmXa5Bzg9KqMCGwfwrRvFHmMOOtUZBjk1aehDQwcNkU5+GDDoetNAJ/pTl+ZCpPIFMkTn8KdAdrcdOhpB93pz0pGXADrRYFoLINkmRypprcncDwealA8yI47dqi/hyOgosNiHBXrUcZCkinx9Tk8VG/yvQJidHYUnGOecUrcMTTM80yGHUcU4H5MEdBUeRTlB2E00BY06QpcAg49a6lTmMtnjjNcfA22QHHQ11FrIXhbpgChgxZcq2R0omb94nuAKTfzz0plwTlM+9FxEsnAUZ6UrsN4JzioSxMeT1BpsxwoNIRdj6nHpQ3Uj1FNtjlTz2oc/MR7UxpD1PTirCY6jHrVNW4Oe1WIGyODzQBZB9KjkIxTg3FMk+71+tICuxpQePqKae4pM8VSEKTxzUZx2pd1JVIQA8YNKDx7Uwe/JoyeaYEgPp0pCfypmaM/rQAh/8A1VG/3T6ipDjBxTGzg+lIaKEvU1Fn8qkl6mojQA9G54qyGOPwqoODxVhG4pMBx6c9KjP407PvTTSCwnAz04pKSkFS0Fh4P5VInrUBPFSRN2JqGgRMPanjrUYPvT19zWQEo7c04dOetMU/lTgeOcZqCR4paZ2pc+uaQmPB55pQfeowe1OH1pEkoPpTgcfjUQ4HBp4/OgCQH0pQfQ0wH3NKDjpQNEgOORSj1pgp/wCNBSHqakUnHFRAmnqaCkWFNSp9OKrp0qdDQhosx9Ksxdqqx/pVqLp0qkUi1FjNXYhVKLpV6LtVIaLsPSrkfpVOGrkdaIZZjxV2H3NUou1XoenrVoCyucVKoqJMYqVPerQrk8dWogOlVkFWYuDzQIsKBipV9KjSpFouIkWpBxTE6VItAhR0oJx1pagkbANQ3YkbM42nmsu4cc81YuJOvNZ0r+9c05gRSv1rPmn9DU9w+AaoNyTXDVmxXAuT3phJwaOKPeuRyZFxKSlpKSlcm400nanU2rTJuJSU7FJVILiYpKXtzR/KrRSYCnj9aaPanrz9a0iNMaRkHPWqk68HFXiKrTrleMVRSM1hyaQYxzTpfvHFMBxVFpEg71BJ09qkzxzUMjcY7ZpXLRWkPJz0qFj706Qnn8qhJpFgxqM+9KTjJqMnPekMD1+lNzij69KbnryaQh4PJFKG689KizzRu9aTJaJg49qer+9Vi1Kr8+lQTYuK/NSq3pVNWqVH46ipIaLIb8aeD61XVqkU1BNiXJo96YDxzTsmpEOHv0pM9qBntR2oBDcDrTTTz9RTT3potEZqM9akbpTD71omUiJulV3FWG7+1Qv3rRMtFVxxx2qu69R+VWnFQuOwrRMdym61C3TrVph14qB1PpVpgVX46VA3Qgd6tOKgYVSYFd6hPU1PIPTOagYGrTAZn9aM+9FJzzVAKDShh603tQKAJFPFSqarj096kU+lAFpD+VSg5quhPfrUi9KkCYN2pQfSowR0p4PqOKlksDSH2o4xSH+VFhCHpSdval6dOtN9aBXEz70opKKBDs0U3FFAF4NipEfHeqgf3zT1b3rc6zQjl7GrMcnHWstG9+KsRye9NAaaP3qxG/GazY5PerMcnqelNCNOKTFXIZOOtZMb1chfjrWiZm0asb1ZhesyJ/ercbVaM2a0bZFWYmrOhfircbdhVIk0omq3Gaz4WNXYmHrTQi9CeatofWqUTVajPGKpAWFPYVInWoUPtUsfWmSWY6tR1WjFWU6U0SPFPHSmgU5elNMmw8fjThSCnLmmA9acOmKavSnDrTGhwpRSDpTh0oAKKKKBBRRSe9ADW71C9Sn1qFqBoYfemHpTz3qM0AMOKYfannoajNIdyNveoW71K3eoW6cUAiJ+9QPUzVCw5qWUmRNUT1K3TmomqGWmQPUL+9WGHNQuOuOazZrFkBqI59qmaoj1+tYyRrFkZqM1IehppHXmsZI1TGDvT1pv4U4VjJGiY5T271ItRg09T71m0aJk6VMOlQIcVIrVDKTJ1qRTUCmpFbipZSZKtSKaiB9aehqSidacKjXp2pwpMCQUU3NGakB496WmA560Z4pMBfakJozxTSaQXFzTSabnFNZutAXEc8VA54pzvUDMec1NhoZIfeq0p4461M5qtIf/ANdUkBC5HNV5Dwalc+lVpTVJAV5WNVXPXNTy1Uc9apIVyN26g1UkbrzU8jVVkPXNUkFyGU9qpy9DU8h65qvIfetEhXKUpqo59KtzH3qlJ3x0rRIzbIZG9aru3B5p8h9+KgdutaJENkch61Xdvzp8jHNQsfyrRIhsafrTSetBaoyf0qkiLi/U00e/ekJ9qM+lUA9f85p496jFSD60AmSL0609ajXpxUiipsUSr+dSJ9KjT8qlT8aktEgp600Y/CnCpKHDinjFNHFKP50hokXpUkfqetRqeKen6VBSJl96eP51Gue1SjpUlIevT6VIvaolqRemOakpDxTx0NNXpThg/hSuMcKd700HilFIBf50tIM0ooAOtJS9qSgBpqMjrUh96Ye9NCsRNUbVKenSo2FUiSE/nTD9R6VI3eoj39qpMiww0xu9SGoz0q0QyJqibkGpT3qNvrVpkMjbvUTdP0qUjriom6VtEykV5KhPfpmppKhPetEYSGmk7dadSVaMpDR6U4U2imkImi5OBXe/D66i02aS7uFG5B8hxjrXB2y7nAHWuhmc29qsQJ3Hr9KmXYuCN7xL4gfVLssCVQHiufvdreW6ddvP1zVLzMtjPNRtIS+MnihRsWtiQg4JI6c1cto9kIYjk4xVWFXlZUCkknFdNbaeVu4IpACVxkehoukVCN2dx4DsPKtk3DEjjca3ddl8y5jtozkIoLfXpS+HohAjzEjAUbfwqpA3m3M85PVvl+lc3MbPcfGP3o4O2MbQcce9cjrd55t3NJycdPwrp7+4MNm5GRxk1wV7MPLkb1OBzTTKWiMqYme4VRnk5Na9um6RR/DGKzLBd07MeQOK2tPT5Md2PP0rVGdzUkwEVRx0FZ94xwAeh4/Cp55DvVeeATVKdtzhT0A/nTJ3RS1GTba7QfvfyqiDi0IyOCBTtQk3zbc/KD1qrM+Pl7ZppiRYgYb5Izzu6fWoQpAkU9VP6U1pNs6sO2M1Ncj50cHhlwapMaRQ2gtkCpIv9WzE01kZcnJp2Alv3ySMfSi4C2PVmwcDj866LQl3LKNuFUbic9AKwoF/d4wexP510WnYh05yQd7jbUzKiXdMiFxeoqjESjj6jvXX2FuyzKMDA5rmvDQEl4ij7gGPqfWu2jQbwVOD0NYs3gaFo3yEDGBUk0eYuDy3WoolCqT1OakHzDJP/wBaoKKs5LSQxk4RD+eaq3h36mFH3fLIFXBiWN2HbJzVaUFNQtT6xkU1ohpGbrb+Xoirzkrj8q5/4XwC61pyw3bQf0NdHr+BorgDJAOD6e4rK+C1qy3V3KTnD7fwNKL0YNanslqo24x0x+FXExzioLdMbz9KmH3DkUEiOSz4HpXM+IQF1bTJB0LlfzFdKeFVh1INYWtoHudOYqPkuB1980IDU8PYXSNhGMOf51wNn+4+IErsflMuFHqDXommR4tph2315zcK0XxCyx+TepPvSTuOPU9QmXcCAT0zUzEiJODjApkhyRtGRipM5hUniqijIwtcVWmtweAW6Z6+1ZF4qm1JfPyPg1oa/J/xMbZQTjcKzbuIqlyjE53+vai5oloVZmU6dNkAKCCP1pMfMV42suTUVywW0lhwd+0Efie9TRISkZJ4MYP4076EopzoChXtjiub1K2/cltwJXqcV0t4rBYwnU9ffFY1/GXg6Y5waTfYtaHP6rbh7WKeJgdpXOPrjNQ2jb5nAJ3Hkj1re09Y5LSa3ONysMfSsuZPLu/kIDE7T75ppCvqzl7wMtzdAH71ZmQunsDnIIB59Sf8K29Tg8uSc7wH6Csi6RY7CJAQXl+97Y9DWiYyK23wzRADh+Qa6bToXjuLZtvylwCeveuX0zfJIgYlsHGPQf8A6q7nRYS9vuHJikH4Ug2R0slm8ElxJjsCPxrhNcUxajyvySDP617DLbpLbJIYzl1AOf515j4laG210QMoZGU4+ue1JKwk7nY/CqdEuvs+Rh14B/GrF7ai18YxxH7rMD9M5rG+GnmHxAqBQCvT8a6jx3bsl3a3sB+aOUK2Px/Tioloxo6vw9Mv2a9iB+65AqtpTkR3sJ/h5FQeE51uFu8cNvBb3qzp+w3l8Bjdtz9aFsZW1ZYv/nsckHIXn8Kh06U/6OwyVIxnNaMKLNY4Pdaw7FvLjVDn5GIH50hrYs64xNrJmvPYHP75B1EoIr0HVv8Aj0YkEivOnLoZ2XpnNSaQVzQf/SPObI5C5/PFFvl5QxzgRhT9RUOmqTayyHsB+hz/AEq5ahhGgHIZAwpIH1IJnGwZGRiuZ1w+bD8p6HkV1H3ojlejY6VzGqqTu2Afe5qkyUjhHCmWZTnOc1lkbJCQTwa2r5At6SO5596ybyMeblTx3+tUmiZIdKfMAJ6jAP0qvMm6Mg/SrTx5gUk4YjANVJH+YBhzVpmdim37yEg/eU4JqIHdDgdRUspEcx67W4/GoCuyRgfwqhMo30eYywH6VlP92ugnXK4OMEVhzx+W7ematO5FisOOaU/Kd3Y8Uu3gnjikADKcmqTJsOUA9+vNIjFSQRTBlehqRzlQyk0ATw7UYMOM9abdRhHO0fKaZG24cmpC+6LB5xSvcRUAwwpJRz+NSuARlTSSZxnHPGaYmQOMcZqInDe1TSfhUD0yWNY4OKfGcEjsaY33fpSKcHrQBIvDEV0GlvmNlPda584DZrW0pu+eAKAL/U4P1pXJkCnjOTTGP7wEd6I3+U5HQ0dAEVjgqezUTt8o5pi/65s+tFxy2Pagmxbsm+QkmnF/m/CobUnyyKVj0NND6D1PXNWLcnkDpVUGrNv3oAsg+nUUxzwaXJx17U1qAIWbn0xTdw7UNwT1pnr1qhWHZpM00n3puf0ouIfn8qTP5U0n6UgPXnrTuA/PbijNMzSj2oAdxmmSdOfpTh7Ujj5frQMoS9SOtRdKmlByahPqaAEFSIfyqIepp6H+dICUnjNJSD0NGPxpBcKYPYU/HvTDkZ5pWC4Uqfe5pv0HNKPX0qWhFgH9Kev4VArDpUqfWsmgJ19ad7Uxad7Gs7CHdqKM0nPU1JIoPFKKbx070CgRKD6dadn8qiHTOacp7elIRKD6GnA1GDTgcjigpEgNPB4qNelOBoKJAf1qRahUjqKcpoBFhD71NHVZT6VOhoRSZcjq3Fn1qjCferkNUikXIsVdhqlFV2GqRZehq3H9apxcdatxe1aIVy3F7Veh6ZqjF7VdhHHBrRBctr0zUqeneoVzj2qVKYFhKsx1VQ1ZjxTEWUqRaiTpUqilcRMtSL0zUa08GlcljjjFVZjwasMcCqVw/pWU3YRSnbrVGY9eatTN1qhM3WuObFcpztkkZqtj0qZzk1Ga456kXGd6SnH6UmKwaIuJSCnY5ox6UkibjaMdadijFapMkjxSEVJikxVJAmR49qAKfigDjpVpFJiAVIq8UgHNSqOOlaxRaIyKgmHyEVbYcVXm+6aotMx5vvHnvURNST43t9agJ7elSaIXdwc1BK3GKGbjHp1qKQ8cZoKRC5qJj1pzkc1GT1yRQVcCfemE0EimE+lAXA9fekJ7UE00mlYYZpM0hNGaVhXDPekB/Sk9qTPrSsInVqkVuetVQ3vwKejVFiS6rcdaerccmqqtxUit71DRDLaniniq0bcVOpqLEEgxSimrTu1IEJSEHHNLTT3popEZ6Uw1IeajNWikyJs4qB+9WHHXFQOK0TLTIGHBx1qJlHvUzD2phH51aZRXZahkXrVsjionXirTEUHUj1qB1xV2ReOKrOoyfeqTC5TccVAw6mrbioWHerTGVyOPem7alIppFWmBFj3o9RT8UmPai4CAU9f1pO1OWmBMvTFSjpUSCpRUgOFO5B4pi04fjSJY6m0uKOnpSJY31pO1OpMYpiG89RQPrzRSgenX6UAJiilwf8iigBob3qRG5qkH6809ZK3Ou5fVuKmR/es9JPep0f1oFc0I3461aikrNR/erMTc9aaEakb5FW4ZKy4n96tRP71aIZqxP+dXIW9KzIW9KvQNWiINSBuKuxNWdAePer0VNEmhCauwniqEFX4RVokuxH9auR+mapwj1q9EtUhEyD3qxGtRItWY19qBE0YqdRxTI1qdV4oJBRTwKULTgv5VSECingelKq08LVIQ0DFOHSlApcUAFL0oFFABRRQaAEpD+tLSUAMbpUTVKaiagaIzTDT2qM0gGHocUxqeaYaAImqBqnaoGoGiI1E3Wpm6GoGpMaIz05qJqlb2qFu+ahotEbDg1E/TIqQ9D6UxunFZtGiZWcGozUzdMGojWUjWLIzTDUhqM1jI1TG0g+tL6ik471izRDhzUi9KiFPBrJmiZMp7VIpqFalWoZaJVqRT71Epp61DLRMp5qVTxUAIFSIakonGKeKjU04HIpMB+aUH86ZmjNSA8Hg0ZptGfekAuaaTSE0hNFgEJ4pjHilJqNzxSsBGxqJjT2NRMaLDInOKryN1qVzVaQ1SQETnrVaU9amcjmq8p61VhFWQ9arOecVNKetVnzg1SAhlPWqcrDBqxIeD6VSlPX2qkhEMjVXc9afI3JqtI/BrRIlkMrdR6VTlPU1YlbrVSQ8HBrRIhleRveqrtU0p5NVnPbvWqRm2RseuelRM3XFOY8GomNWiLjSaYTQfem9apEhn1pRjuaQfrQKAHp7VMufw6VCtTKfTNBSJFp6/SmL0p4+tSMkWpk9qhX61NH9allxJh7U4Z9KYOKcKgseO5pwpnFPHagEOWpE9KYtPj+hqGUiZelPHSmJ71KOe1SUhy5qRaYh4qQdKksUfWn9sGminL3qWA4YxS0lLzmgBw9xmlA9qQdKWgAxSHoaXjFJ2oAaaYenNSVG1NARsPSo2qQ1G1MkgamH0p7YyajNUmRYbUbZqQ1G1WiGiJvbFMPQ1Iw4OO1Rn04q0ZsjPSon+tSt04qJ+nWtkZy2Kz9ahPeppB15qI1qjnkNpD0pTSVaMmJRinAVYtoDK4UUxE2mIqt5kn3V/Wrc8hkBdjzUUmASqfdH606UYhHIzxS3ZaelkVkYhyTTolLNnBpIY97Yzx3NX/wB3COAP8abY0bfh2CO1ikv7jBCDCD+8avxsZGSYH9656eg61i3E5W0gMrHaBkJ71r+Hw0t5Apz8zAVi9dTWD1sekNL9i0DaTyUH61V0j5dPZjgluQTTddciOOHnsPyqeLalhAuDknB7dKyijZKxmeKJzHY4AHJwa4W+fCqp+prq/FEu5Ninpya4uR/NuSpOQODVRQSZe08bLZmJ5ccfhWrZkKh5+bAz+NZ9iqlXkb7ijAHTpVuBvkZjjJ5HFXexCRJJMPP9cVTebBkc/T8qa7EZ+o5xVJpN7uAeg/XNOLC2hUdt7HHUkH9aivmIJzQ2Q64Jzn+VQX7/ADBeelMksOuSOvIBFWYm86zKgcoP5VWLYWIgnlcVJp8gWQDsxqkNEdzlkVlB2k80pIby0OOBzSzthmj7bs/QGmsuSwGM96EFiaDmUnsK6BW26YSSemRWFaoGkC+vBrfnjJjhiTB4yfwqJMuKNvwfEyRLKy/ewRXaxqoUHucVy3hZv3CRnhYzgfSujWdQGLHhelYvc2S0L4dY13P0owzKxAKjbj6VFaqZVEsvQ/dHp9RV0kFM4PTHSkOxW2hYViX+LA+vvTbqFvtFp04BzVmJN5hweAKNRQr5DAnhsGi5Rh+JgP7MkUEYFQfBmPcb3GcBgfrU+rFJbK6Yn5VB/MVN8HE2xXTYGG/XBpR2E2enRcEgntSjPPpTYweSTxSow6ZqiOo0jcFPYGqGrKsvkMRjbKv860FP7rjjJqC+i3wADs4P60LQCW0cql0AOEbj8a851pjH4zMjnh9oA9K9EsmCz3ULctgH65zXnvjEr/wl8IC8hVOOnQ9alaFR6nptu+5IeRkoKtMAFAHQVR09leK2ccblH41oTfKO1aLYy6nI+IcyarAEPKnP5VFeLmW4JfIyKXWGDXZeMncrVJdRs9vc4HO0Vma9LGIVWb7WxJ4j4/Cn6UA9nlidwAB56c06eEw6d8n3mx+VS6TEhiCjBD9T6YquhLIJgNqSAcKf61kSkbpQwPTI9q3LiIpaMCRhWPP1NYOoSosbuSeB1oGtUZFqvkpcSHh8/Lz0qrcxtdQylQFkClj26VYtFPkzSOwJY8ZPQdKZE6pdKzH5Cu0++aoLGDeRNcQQkEBmGWJ/rWTq0atBCIyMZPI9ORXSaoBaXckIyf4lPY5rCe3LaaWK5CuU/wA+1O9hJHN6VdeXdoVPCv8ANjuBXrHg6ONo7vblkk2uD9eOa8eKi0jussNwbAwenf8AWvZPhm8dxpHzEeYUGfwqvML6HosEYfSwMEsox07ivG/iFauNXSZEbcvT35r2ex3LC0Y6MN2f6V5t8SLYwywSZOHYqfbvUyFAq/DfU5n8SQKM9QpHTPB616L4hhmltLkhT+7lDY+hrynwbI2l+J7SQ4KysB+f9a9vMsc13cRYyjct7ZpctwbaZgeGLjy9Ru5BhY5dpz6HpxWsziz8TAdIp4evbOa5exRpL+9t4DmCP5hjjHXmt7XHZdPsrs4+RVJP+fwqV2G0dNbDypGVmGG+6Kx7gC3vjkfI5qzYXP2gW02QV6fnUWtN3C8A+lS9EJLUlv1zZvjnivLpZAHuVO7PTH416nCyz2QJPUYrzPV4hDq9yueCM/WpbuXB20JdNfNq684xV+wYukJJOAuBx1qppCZtGb0HNWbFfMt4iOi9fzpIGEpVSwP8RwPqKw7uL5pFUAuTW1qG2NlfHRqzkkD3UjFeAaaEcHr9s0MjHAzx26ViXUW5gpwCRkV2fiSMMsjEYzXJ3MZkhTB+baAPwpoOhTg+ZJLeQ84G2qVwAykE/MvH4DvVm5WRSsi9VHPvUVwisqzrnB4P1rVPQya6lGdVkgOeo6VSyGjzzkHmr20mRwT8v86qSqI5GxyOvSqRNhoUPGTz/wDXrPulDKTjkdavlsj5B0H6VWuBt+YDKtwatEmSy9QajHysc9Ktzrt+ZclT0qCUfLkVaJISOSM9qIWxlDTmU4B71HJnIYfjQSOU7WK5+lSxnBOe9Q/eXJPIpR0IB5pAPZeSo9eKYGwMMOlPxlOTz2qNuTznNNMQSJ6Cqrj1qyCWQqc5qBjnr2p3JIh3BqPJ/KpjweKjYck0CHk8da0NNbbIFPcVQxlOgqzZn94uDQBtH7y03oefXmkc5jDAdCKc2NoJ9RTTFsN6zc9DwaST73XgU7jzfoKY/wB8+lAXJ7fOCKU9OaS2GWAHenEcfjQHQM8e9Swtg1AOtPU+9AF5WBHOaU9Paq0bmpN+R7U0AP3xURHUYp7NUZ96YDfXmk7d80E8YpD1OaQmBPWm59QKCab9aAsOzxTgetR5PrTl6cGmgHA/nSnpjvTRnHGKXqCTzTAqTDk9fyqs3qaty+vrVR++KAGj2p6n61HSg0ATr06/pTqjU8d804H16UABphxzx0pxNMJ60hCd6AR7dfSk+v4U3JqbASBuvP0qaJu2arA980+NsdKhoC+vPWnioI2yKmBP41i0A4UfWm0tRYlh/KnU0Z5pR/8ArpWEOpQSRTRjsKUemaLAPGacvtUYpRSAmXvmng1Ep96cD+tA7kg/SnKTUY5pwoGTp6cVMh5/lVZKnQ+tMdy3CeavQ1Qg+tXoaaLRdi9quwegqlF0q7D+lUmUXoulW4c1Th6e1XIatMm5ciq5DVSKrcXvWiYrlpOmKkX9KiXFSJ1p3HcnSrMWarR9asRmi47luPpUq+tQR1OnpSuImWniowe1KTxUXENkbg1RnOc1ZkbrzVOU8GspskpTN1qhMOtX5aqyL1rkkJlAjqKYQasOKjIrnkjNkOOKMc1JijFZ2MxgFGKdgU4Cmok3GBaNvpUgFG2rUSSLb1o2+1S4ox7VaiNEO2jFSlabVJFIaBTxjFMFLn3q0rGiBjx7VUnb5TmppG4OO1ULmT5SaLloz7hhvPNVi1LO2SeahLccVJomDtUDtwfpSufeq7tweaB3Edv1qMtTS3NMyaoVyTd154pueKTP5UmaQ7gT1pDj1o5pDSGmJzRRz1pOaLBcQ8Uhpf5U3t7VNgAZ7HrT16VH9KevWlYTJU9+lSoeOKhWpk4PWoaIZMh71Zj6VUWrUR4rNokmGMU7tTFPGKdnjk1NgCm0Emm5poaEPrzTD6071zTCeOtUihjd+ahfH41KxHrUDmrQ0RtUZ74pzH0qM9frVooQ9OlMbpT8009/SqTHcruOKqyL3NW26VXf6VSYim461CwHNWnA59qhYcGqTKK5FMI61MR+dMIGOlWmBCR1xRj1pxpPX0q0A0AinqPSgCnp15oAeg4p4pEHFPA/lSJBacP0pQMDjpS4pAJQfal9aSixInbrSU7FFOwhnFIPan496QD2oAMfSil49KKAMnd704N71CDmlB4rc6C0j+9TI9Ug3vUiP78U7Aacb89atRt71lRyds1chk9TQkBoxv71bic9jWbG1W4m569qpE3NaB/StC3bism3PStK2yfpWiINe2PHBrRhwazbXpxWlAKpEmhbjpWjCtUrVemK04UqkSTwKavwrx0qvAnr0q9EuB7VSEPjXtVqJfWo41qzGKYiWNeOanUVEnSploEKFpwXmlHNPUUEgq08KcU9V4p4A9KpMRFt9aXbUuKTHWmBFijFSY4ppFADO1JTyPyplADTSdqd6000AMNMNONRnvQAxuhqM1I1RGgYw0w96eajNIBjVC/v0qY1C1A0QtUT1K1QtSuNERqJ6lbvUJ71DLSIz3xUbdKkOajbuKhloiaoSOtTN0xURxyKykaxI25/CmHrTz0pp6VhJG0SM0nrmlNN56ZrFo0Q4U4expgPFOFZM0RKvsalWoUqVahlIlWnr0qNakBz3qGaIeDT1NRA/nTwakonU+nepAePeoFNSA+9ICQUU2lpAOz6UmaSiiwBTSaUkUw0rABNRMetOY+9Qu3WiwDXNQseOaczelQu3FFgQ2RutVHNSO3XmoGNUguMdutVpDUznrVeQjk0AVZT1qpI1TzN1qo7DpVICGVuDVGVutWZm4IqjK3XNWkIglbrzVV264qSVuTVdznNaJEMidvQ1Wkb3qZ+9VJT19a0SIbIJGqs54NTyGqrnk81qkZ3GMfeom+vFOY9aiPerRAh9qSg47038aYh1KKZn3pQaAJU+tTLzUCE+lSigpE6U9etQKakBz2qRkqmpozVdTUqNipZSLA6cdactRocjinipLJBT1pi09aQ0PXpUiUxOlSoOahlIlWpBx68mo1Ax71IufXpUMtD168VIvpjiowKlGKkoUD0FOHFIBTgKQCjpk0o780c4p3WgYg6UopR0oHvQAduOtJ2pRRxjNIBh6e9RnvmpajbgU0xbETYweajOakbvUbUxMhfPNRmpX5qFvQ1SJGGmHvTm6daYe/NWjNoY1RNUhNRtWkexmxh6cdKhfpUpqJu4xWqMpEDjrUB6mp371A361qjCWg3rRxSUHpWiMWPQitGz+VHYdAKzI+uTV/dstQAeWpsECtkk7TzUrDfHlTwOtQxsNpB9KWA5fHYnFCQ0x8LeXx61ZA8yWMdckVCcGU57VZ04ZvN7fdQZqWy0T6i2+5VP4UAAFdb4Ht2lvRMT8qDg+lcXkyTSu3XtXqPgSyEemeaSORu/SpkrRNKS965o3qme/xnhePxojctbM0hPBOKktkL4lkIGRn86rXTBbdkDY78e9Y+R0Puct4jn+ViCctXOxgBWI+8Rj6VqaxMs14Yx/Dx0rKjAa5Cqf4gPrzWkVoZSdzaRPKsUjI5bBqUYBCjpSSkZhXuOv8AKopG24I5OKEgRXlcjdk9TxWbK2IyVPOefWrU7hQ7E8AYH1NZ0j/Jz3OaaVgb6CFy0w9MelVblt9zx2GKnjbLux7f0qrD80xYnr0qkK3Qtq37sYP3DUttgorZGAf61Wh+44FSQk/Z8A9GpXGixcYe4YA4x0qGMn7T1OBipJ8789zjFMjYJIFI5NO4JGvpUXm3Y9AM10EEYa8VgMrgqPfHNZ3h2HMjFh8uOf1rcsoSxiIx94/j7fpWMmbxWho6IyLNKBwM1rQFZJXY8qGGPesSNPLZu3zAV0tlAAuSDt/nWdy1sacQIRePmIwKssvlx4Oc4otkwNxA4GBS3PEbMx5xigBbNA1ujD6cfWm6sMWDEHndVjT0It1HQZqLWgBpsnPII/LvQuokzlb5S2gXG30yT+NanwnjaPTpCFGMkVn6gFXQp8Z/1f8AWui+GcezRj8pyTmmloCZ2qn9wScVAHG4DPtUq4MJGOcVUh+e6xxxzSbCxbT/AFYz1BzT5l3RnNNjw272xUj5ZeQMVRJQG1NWkYk/cB+tcJ43IHim3lUjlB/PtXc3K7tRYg4Ji/QV5p4zEp1K3lBJKLge3JqfIqO9z1TQXLWFsSOQME1qXPAP0rN8P4/sq2b1QGr98xW2Zh6Vr0MpfEcjfI3m3LFsFSGA+vFWdzFJFx96MZqLUV8m8R2BMchCn+dSOD9oGVO0p+YBqFaxT3K8KB1aNiMKMLVfQ8cRMMEPt/WrYG2eF1HGdpFVb7dBNHcxqAu8Z+vSmkPcZq53WswAwFfafzrmtYCiwmHt6da6HVWja1ncsNpIJHvms7V7bdY3JA+UR5HHWnYE7aHP6fZiV2EmdmwMvvU/9mRhkByUfnr6Zq1ZxPi2borR8fhWhLF88CZznIFNIdzn/FdlEtjazlTvD7SfUEY/nXM6WGuFm0uTBmYmRPoOMV6N4q0xr7w06R5EkXIx7VxHw9jV/FVpNdMAiDypM9cniiSBaHnOpWLC41CMIRIg+ZM9MHFehfBy58yxmhJ+ZCVqj8arAaJ8Qma2TEN1Ap49ehqv8Kptmu3McWSsib8dOQcVViEz3TTGYNEjemATXM/Eix8zSGK8tFlx39a6a3DBrR1HyscVB4rtXuNPnAAI2GlbQE7M8b0eWOWW2k3nejKcY6nNesw3LJPdurkkqCD614vYsLa5acnCwNyvrzjivU7BLm8kmkTIVogc+vFTfQrqa3h6JY0uNoZ5JE3N+tbOrRreeECFUlljBH4Uzw5ZrBajLB3dMs2Mcj+la+mwq2lBGHByCKLWJbvocz4Nuw9tFF1ZGwT/AErptZiAiDbeODXEaK39l63JE33PMK/rXoeoKHtsY4NRa6BuzRztpIY3aM/dPT/61ch4sjEGtLIfuvHXVXRKyHplcZrE8aRpJaW84XsMms1oWijpABtJVGcY4qTTVZbcqcjBIpdIYNApUDBAFP2tHHIAP48fnVWVhXGajGrWhIbkYNZUv+scBeCAQfWtqaMG3dT6VhMSHIbOV/lSSsh7mTr6eZakAHNc0LdSkQC5PQ47112p4aIgYxisIx+VHG2OM4NCGtjnb+2kiO8L8h4P0qhPCyKXUZiP3hXU6rEPJ3jkD9QaykjzA5Qfu+n0q4vQlo5yZdjB1bK9apzZ3ZJ4/pWvqdt9mfcBmJgPw96y5VyPlwRjitYvQza6lQ/u2BHQ+lMbHK5BBHFOY5GPSmsQwOPvCrWpDKmOsbjg9KrOmxirZ9quS5dTx8wqHO9Pn5x3qk7ElRsYI79qgZcA561ZmXaec47VEQB15Bp3JaK6kgEHpUsfKkA+4qNwAT6Gljba/PSiwh8bHlfxFBHzcnOKdINj7h0NEmMAg0gsQt7dqgzknjmrHYA1C+ASBTRLGOCOeaY2M1LndwaibjNMm+o6MZRhU1mf3q5qCI9RzzUtudsyn0NAG2oJiYccGljOYzuPTrTY+VbGeaRSRI684OKFoIkX/WNk9gKbzv8AY0mcSD3GPyofAximJksTFQG7VLJ0yOlV2bCKo781KrZjIJoGBPzHB6UqmmZ4PvSofegCdT3pw7g80xelSD9KEwD8Kaad296aenvTuAw9DTT9aU49KYelILCUmaU03jtzQIB9CaeMDvximZpR0yc00A8U4YOc00fhTl/zxTuOxXmHGTVNxyfSr0/Q81Sf2phYjNIDilPemHpwelILD1btn608N61CPapBnH8qBEmeKYT6GjnFNPvSuFhCaM9elNNJ70hDh9akXpzUQz3qROaVgLMTdqsr0qnH9eatIeOaykgJO1FApfzzWQrB2o/lSD3NLmkSLzSj8M03Io+lAh4+tOGMVGDgc04H1NKwJkg6U4H0qMHinA+lIdx4OaepqIdD09KkX360ATIfSpozUC1NHxQmWmXIfwq7AR61QhPrVyJv8adxrQ0YTV2HtWfAavQn86aZVy/DV2GqMPSrsNWmTcuxe9WosiqkR4q1GatMVy0pqZPrVeM81OlO40ydParEfvVZOtTxntRcdy3H9amU1BH0qQGkFyYNQzUzPFNJqbiuNdutV3qVzUL1lJiKzjrUEig59asuOtQsODWEkTcoyKeaiK1ckXiq7CsJIzIse1JtqTAzSfWosQxmKMc0/FJ+FUkQxAOtLilFPUVaQhoWl2VKo4pSBVpDWhWZeDULdTVpxwarSd6LDTIyahZxSyNVV3680zVD5JODWfcyZzipJJODzVGZs55qGWmVJT8xqMkY4zT3PJqFm4NK5VxrtUDnrT2bmom5FFwIz1pvanHFNPpVJgL2/Ck7UDPrRn0ouNMPpSUUetIExuee9HrS96O3Pei47jaaelKenWkHuRikFw7Uq0lKnWlYVyZelSr3x0pidMVKB+VRJCY9f51PGagX26VMnT3rOxJMDxzSZpn1ozilYBxPGKTPrTSabuHrQkNCk00mmlqYze9UhoGbjBxULn0pWbmomPpVJFIax75pv1oPvTapDFppxg0tNY1SGRt9aryZqdupNQv3q0BWYc1Ew9fwqdh7GomHp0qiiJhUbDipiKjI6imguQketNqUrTMc1aYDetPQetAFPUcUwJEFPUUiCpVFBIgFBFPA4o20ANApMU/FGOPanYkjxRipMUmODmiwiMgd6QDsal2+wpAv40hDfwop+2igDnA1KDUWacDXQbkoPvTwf8ioQfSnKaALMbc1bgfnFZ6H1qxE2Mc00M1om96uQn07VlwP0rStzkDHeqQjStzz9K1rSsi3zxW1YqTgirRDNW0HHFaduD7VStU4rSt0qkSzRtFrUgWqNonFakC1SEWrdKuItQwDirKCqESIMVMlRJxUyU0STJUq1ElTLQIkWpFpi9KetAiZMYp4piDipBimmIMe9FL+FLiqTEMIppFS4phoAiNNNSGmGgCM96ac1IaYaAIjimEVIfSoyKAIzUR71MRUbCgCI1Ge9SnvUZFIZE1RP0NSt3xUb0DRA1QtU71A1SykRP0NQnvUrdPaoW6VDKQw1Ge4zTzUbVLNEMPfNRHvUh6VGayZohpqI96kPWoz3rGRtEjNN/nTjTaxkaIBSjrSUo96yZoiVKlHpUSdKkHSs2UiRPWpBUS09TUGiJFpwNMFKKRRID6VKpqFakWkIlB/KgGmg9hS0rCHZozTaTPrRYBSaYTQTUbNRYAZqhY9acze9RMfyosNDWYYNV5GqRiKrytRYZE555qJj15pWY5NRMe9MBrtVSVutSyt1BNU5X600hEEzdaqO3vzUsrVUdqpIRFMwqjK3BxViZs9KpSt1yatILkEjcn/ABqFiKc7dc1Czdc1qkRcjkPB9jVSQ9amlbrzVVz71pFGbZDIf1qs5qeQ1Wc+/WtEjNsjY+9Rs3WlY9aiJqkiRc0gPFJQKAHA8c0o/SmilHagCWMVIDUSe9Sr060ikPHrzUi/So1/nT1/SkMlFPXrmo16U9aRSJ0PFSqahTpUq9KkpEq1IuaiWpEqSkTp0qZOBUKVMvSs2WiQD+VOTpyaavvT16Y7VDKQ9fY1Io+tRrjFSjpUsoevTHenCmr0p4oGA6UuKMUo6cUgAUuOtH4Uo+lACUGl9zSc4oAYajbvUhxUTY9aBEbVG341K3TBqI9DiqQiNqhf1qRqjbpzVIlkTe1RnrzUjdTUZ+lWiGRtj1qM/XipCKjatEZsjbjvTG61I3v3qNsc1pFmUiB6gerDjrmoG6HNbIwmiI03vTzTatGLJIhlsVZmzkAYqtF97PpTmbce9VcVibgLktzSwH94uCetQMcDrSwth19iKdwW5pnazMW4xxVq3URWUkhB3P8A5zUCKJNxb7o5PvU6EvauBng5x7VC3NUiKBdxXry1ez6BB9n8PJlcEx/qa8o0K0FxeQof72fyNe4eUI7C2RQArELjFRUeppDRFS0tv3R3jgLiuZvXYPMGPQ449BXXyFhE4GcAVwerzNGs2etQ49TZSujlrqRhcSyA8twKj0xd94pP8OWqOeQ8k45q3ovAllI4HFUnYx3NEndcOQBhcCoZ/lGCR6mm2rlsu3Rj/WmXLDDc9qZaRl3shMgTt3qpNIMkEcDmkmcs7uT7iq8rfL354oJJUYLAzAjnj86ZEQBkgZA4pJT+7RBnkZ/GkX5l/T60wtqWEz5eTjkU61DfZ3575phBWE4PBAp6EpbSep4pXKsTuxECuWBbjH51EjFrhM9TgfrTmZfIRSBnP6VY0yAS36AdjRfQa1Z1Wkxhflw2SO3tXRabCG2RgH5PnrGsSYpow3fj/wCvXRab+7jlkLHPQVzyZstrEWBJetGo/iB+n+cV1Fp0CYrmdF/e3U7EdxzzXVWKjfjnjmlctGkoChQMYqtf5YBc9TirUagkZ5qC4Aa5jHGNwpiNG0VlgUEfpVDxQ23THQEBmx/OtZOEAOMCsPxXhliiB5LACi4jC8QqkOh+UGyWUZPqa7bwNb+TocJx95Qa4LxY5FpbRADcWXP0zXpvhyIxaVDH2VQKpK6AuXPyRnb6cVVtD+/BBGT1qxdHMbHPSqmnODPv5wBioAvxZEsqjnBFSndsJAqOD/XSeuBUzcqR3qmLoZt4Sl1E+eShFebeOSY7+zBbDbu3uTXpFwpe7t8YOSRXnHxEjxrdqp7EH9aXUfQ9R0Jv+JPaHIx5a1fvmH2Vs+n51jaC+NFt1JGAoArQlkEgkQn+AHj3qlLoZ2uYeto5tckkheRRDJ9qjtJAcAoAfrVi9YtYyk4ztxWToLmWxtyMBoyVI68Ci2g+hfEYzFg5+fmkkUN5kTYK5qWOLH3if8PemSjy5NxyVJwf8apaAjjNUVbO/ZJHJgLD5T2FdQ0a3FpIqr8jxZ+o/wAaw/GVsVRZ0jJAPP8A9etuwmLWcKD+KMfjQu4SdjnWBS6s9wwgUrj8f/rVozARXFo5+6GA+meKzdYL/wBoRowwCOCPXNbIhefTY5BglTlhjrjirUkLUuTyKsMyHBR68P1eRtN1fWfs8jKY2V8DjqK9mkmEluFQjjg5ryD4kWhtvEJkXGLpAr4/ixSY9baDPibJNqem6XrHmGUiNEJJz1/yaz/A8klh4ks32HZP8h49f/1VehD3/gW9tySGtJgqjrxycfpVWxm8pbW4jYFocMy+mD1pLbUUD6G06NvsSY6jkD61JdAzWsq7c/Lg1R8P3wntYnz1Ck/jWsUMs0qp904/CqWpLdmfOviCIWer6jEyAITn8K9l8OMkkVmYyux7ZTx9P58V5Z8UbQ2fiG4TYVDoCP8AGu++H7F9GsiOqxAH3pKyL3VzvdORYrmBQBsYECtKxiCxMo6bjj86w7aTfCLjcf3LZP8AKtiymzZeYe7/AKZqtLGTujhvFNmLbWEkBIEjZzj0Nd1A4l09eSQUHNZ3iyxjurPeQNyYIP41a8Mus+lFXIJX5TWLjZlyleKZiagF811I6isW6K3mhXETAmSIV0esQhXDBflAxXLo6wagyEjypvlP1rK9maLVXMrRbgLbRqgyVbH/ANatGaJ8u7ZALVkWUi2upzWuOknHHvW5fhjbyDJyADmmkKwrcycegrFnTbdyk4+4f51qhzhGwdxXP1qjKvmXDHt3p20BXMaRQ6YbtWTLCXTYMgBq3hFmVxk4FUJYys+w/dbnNSWjPaNWiaJjnt0rn4kaKS4iOcYziuokj8uVsngdax9Xi8ucTx9GAU1SfQVjIurUzWrKRnj+VcrKDG7RsMY6V3aruC4yFxXN65ZbmLIMMPwzVxlYhx0uc8/qBzn0qFwB82e9WM7shhhl/WoZVEgIHatkzNkbEA5C8d6rzL5b7lOYzVggbSAB05+oqJsqDjlD1qiGiEAH5W5XtVWSLa5U9D0q2ycZU8GmEFl5HTpTRJSmjyCPSq2McHnFaSr83zdO9Q3Vvt+ePJWncmxGh3oVPUdKaMFO/BxSIDuznjpUqDk8HmpH0K27nn6Uko5ycYp8g+dh3601+VI9KZJA38qa3qKeemaZ06VS2IY1T3FSfdYHNMI4OOtK33RQI3bRwYcjOcUrnE+exFV9JfdA4JyQKnf/AFi59OtNDsLKOUIpRzjOODTXP3T270I3ynjgUCELbs59amjbhqrD7jfUVKCdtAIlB4IAoTp1pinjP505elAE6YxUinj6VCnvUy9KEA76daaaU9Pemtj60AMJphx+FKx9aYaAA/SkpP6UhPHXigB2eKVKjzT4aaAfTl70mPzo9Qe1MCKboeeaqP3q1LVVu9CAibvTDT24zUZoAUYp4xioqdn0NSA/NJ7UmT60D0oCw0+vp2pBmnHvim0CsKPrT0Pp61GMe9KpoEWUI71ZjPcc1TU+9WIm9azkgLIIx1p2cfhUStx0pc1lYQ/Pek3Gm54NGakkcD+dLn3pgNLQSOpVNRinA9/zpWAlB4pwNRg04EUrASLjtUiHsahBqVKBomTPapkx2xUCeoqaP2pFItxVbi56fyqpCCR0q9AnIoLuXYB+taEK+hqpbrxmtCFf8igVyxCKuRCq8S1diTjjiqTJuTR9OKsI3eolFPX60+YLlqNqsRn86pI2KsRt2JpqQ0XUNTxmqaN6GrMRpplFxDxUgPFQoeKeDVX0AkBpCabmjNSA1qYehp5phrNkkLgYqFhjNWG6VAw5rJolkEnQ1XbGTVmToarN3rGSIZGaQ0UhqbGYfjSUvakp2EKOKevFRg04GmiSdT+VGRUQbijdVoAc9aqympnbg1VmPWnYpFWZutUpX/Opp25qjK3WkaRY2R/eqsjdeaex9arydDUMpMhdqiZhzQ5OTzUTHk0hiE8+1NPelPSkPSgdxh6UlOI44pMcU0NMb9elIadj1pMUDDtSUoHvS4+lFwQ2kPenH2pppXGMPoKTseOaU96bzQAtOWmj36U9elAiZOn4VKKiTpUg4NQxEi57mpFJFRCpF+tQIeD6mjPFNB96UmlYBhPFNLChz6Hioyfeiw0OJGDzUbN70hbrUZPJppDQE9s00/rQaQ+uatIY00lLijn1qkhpjaaaf9abiqSHcjPeoXB9eKsEdajYZzVJDKrd6iYVYZccVGRTQXICKaRUxXtTCKaHchK03bzUxHr1pu3tVIYwL+NPVacq9aeq+tUAIB3qVVFIi1Mq8U0hEe30p23g1KFo20xXIMUY4qYrTcDGaCSPFIB2qTb3o20CI8UBefrUmKUKfSlYm4zaKKl2iiiwHGA/lRk0goHtW50EgIpwPFRinqaAJlPHFSoTn6VAvTrUqdcVQy/AehrXtASKx7UcVuWK5Wi4Glaocj9a39PjHFZdlFnHWt6yQDA4qkybGnbR8fyrRgXn3qrbjj2q9AOatMmxoWo4rRhFUrccVfiFUmRYtw9KtJVaIVZSqTAlT3qVOnvUSYqdaZJInvUq0yMVKoouLqPSpVqNalUUXJJF6U8UxakHSmFhaX1pBSjmncQmKaR+dS9qYRTTAjIphFS4puKYiEimEcVORUZFAEJFRkVORUZFAERHpUTD1qc1E1A0QkVGwqVqjakNELd6hep3HWoXpXAgaoG6mpnzULUikRN0PTNQHvUz96gNQy0MNRt3qU1E3fpUsuJGelMOKeenvTD/AErKRoiM1GfepGxURrGRrFkZpKU98U31FZSRomLSim04GsmjRMkWpB9aiU+9OUjvWdi0SjrUi1Cp7VIpqGi0yUU4frTVP604VNihy1IvAOetRg++KePaiwXHg0v403NGaLCFozx9KaTTc0WAVjUbNQTUbH3osAMaiY0pNMY9aLDRG54qpKeTViQ8e9VZDkHmgZExqJ265NOfAzUDmglkMrVTlarEpqpIetUkFyrKetVnbrUsp61VkI5IqkhXIZW4NU5TU0rZzVaRuD6VaQmyrI3JzURPBp7nrULdK1SIuRSNVZ/xqWQ9arOa0SIZFIeKrOfepnPX0qsxHSrSM2Mc0ylPfmk/GqRInWlHSkxSj2oAUdKUUgpfWkMkTrUg6dqjXpTx0pFIkX2p69PWo1p60DRKvX2qRKjWpUqSkTJ04p65pi+lSLUlIetTJUS1ItSUidKlXpUKdKmX3rNlokX6U8cdKYvSngZqGUiRM1KtRrUi9KljQ9aeKavvSii5Qopy02lH1pAO4paT8aX27UAH0pOe4pc0hNADT+FRN34p55zTD1xTQETHjFRnjvzUzVE3WmiWQt6VE/Q9alYdaifpTTJZE1MIH4VIajI784q0yWRmozzUpqNhwa0Rm0RmozUjU0j+VaIyZXf3qF+4NWG61C/fNaxZjJXIGGDTMVIe9MrRGEkKp60q8GkAxSjjmqEObmnQj5gPU4pCM9q0tNtDLPGMdxTvZMErsvtCFZIQeeC1SWQH2iWJSMlMUlwQbsqh9vy4qW1b7PcBo1Bc/Lz6VMTbyNjwhB/xNoV5Jx6V6/c5X7OuOA2ePoa818KRm0voNygySuBn0HrXpGqyNHbxNkZDA/zrOUrs0S0K5kEjTIei4FeeeJnQzSqDwDkfnXbNIVt5pGbl/m54rzbXJfNnfDGktSkjFlPJyOK0ISYdKxghpKzCN7qozjOK1Lk5WJcdOfwHFMlKxKuEhUAjqDVfVW2QtgjkAVI3Ea565Aqlrku0Kg65yee1JDtoZMp+XGR1qLlnAzkCn3HBHqBUcfAyfSqIe44kvIQMfLxTkOYsEdDUVtlmJ/GrMYwAD1Zs0xpMmlAWFAOpx+lMkO1evXH41JdfwqCeB/Oq8jZkVR2ANJbFkj5aSNc9s10fhe23TPIc4XH41zg5uERASeAK9A0SAW9kFVOWGSamQ4LUtW+2SdSRwGzn0ArV80C3nwc8jb9Sayo4ysBIxkkfhk1oWy7p4oQAQDuJrFo2tc2tFtfIhB/iPNb9rgdepHFULNcYAxwP1rQhI3c/hUlItwAc9aaFD3aqBnbz9KfARzk9KdZAGWU+9NEl4qCuOmP0rF1qMSalGpPyxrv/AKVttgRE96ybhRJqB3fd8r+poBHFeJJvM1aCJR8pYAZPYGvX9NO2zjxj7orxq4BuvGVqhxs3kAV7JZgrbovsBVp2Qht4wET+tVLIn7UqDoR/Ortwuc8ZyP8AP86zbclJ2OcHjFR1GzaVSLhvdcfrUwA2EZqGEnzAzNzj+dTtjoOhq7XIvpYy7n92LZhnIfBrzf4mNt1OymXns3516PPgrEOySZ/WvM/iWpkuo1XA+fA+malopbHfeHJPM0a2aP7pX19DWpD/AMfDAnjZ/I1yHgG9Z9H+zvndEP6101rIWuMdiv8AWpW4rj3wUkBAx0Fc34UJW6uoS3AYn6c10Zdd5HBrl7acWPiFiQPKk+XPuTn+laIDqQh5JPFQzgCKTPJ7e9DT/eAyQKSVgUbPXHFV5Eoz7xPt+lSrkhlU/mKztIcyWsB3HcigMua1YJglwY+QHUnp6VzU0jafrjrGT5b4IHpQtCmrieJlK3VjLFkkuVbHPBH/ANat3SZVFngkA9D+NY92fPtFmXBCyfNz0z3puh3SzJdZfIVhj+VNE9DQuQInuI1JIOGH41xnxMsPtGixXagebDID9a7C/ZGAKtyQB/8ArrE8RSCawNsQNrD+XeqVmmO/Y898JzT3UF9BF5avIA7AjrjIz+WaybaZUs1I/wBYkrRtk9MHOcfStbw7IuleI9vDIcqM/wAVcvduYru6zwhnJA9Mn+VJLQFoe6+EdUj+y2+6VQxA4P6V3Wn3Ya6mUfdwMH1r510q+XyEBkIZfu9u9exeHdW86WMs2HaIAj17f0qU7aicdTi/jVtXVYy2TuQHP04rV+G90YtNsQclWyre49qyvjYAZLGRs5KsD+YqX4eTp/ZlpEScrJ2pt9Rxf2T0G0u9i30bfcdMfU5NaHhW6N3pUiy5BiYL+Vcqt6r3V3ASRtyAfwz+dS/DzWCkt5ZT437sjP8AM0kyZI9LvUV7MjAIIxXMaBI1trMkGfkdTge+a6GKcGHa3XqB7VxHiSaTT9SjuYgVI9+vNE2iYLSzOu1VFKAgDgEfSvOdVDmU+Xwqtn6YPWu5guvt9osykYZRnmuY1C02202cht5INZSVzSGmhyhl+1XXmAYuYGCuc/eGetdJPJ5ivgkgLzXDXEzQaizEjdkE9siuqM5KmRGAjMYz3zU3HFCmcBQ/ouAKhtuLd3Y/M/P0qMzBbHzGwW2gAY79KVUdbVeTuai/UroJFHvBZh14rO1CNo5FP8IYVqsSYsYxjiqd6uYm6nAoHYz7uMsSw6gfmKztShDW2QewrYU+bDnHbFVXhDQfN0xQgMMxlYonBGMciqmpW2+MnqP8e9bcUSmBVcdDwageHasiSZ2ZwMdv/rU0wsec6vbfZ5N6gkE+lZ7x8bl+6eDXa6pZgxOrYI/lXKzQmF2AJMZ6H3raMr6GcooziByozUAYxEqR8pq7NHsY5J3Cqlx8rgnODWqZi0QfxHGdp60NnGYz35Bp5xz7H9KjcFeVzj0pokif15A6UscuAVPK9KcSduQPl6kVE8e354+VPJFMRE8YDZB4zyKYz5fjoKnBXt1HWoXAy3oelAiO5UYDg9KiyCPbFWHXMTCq0XOVIoJsRkEAg1GelTgZUqe1RHkdO9UiGMHBp38JApMU5ehHan1EX9JJ/eY9AKtzdEbNUdKYiVwOhGa0ZwPIQ8f5NAxj5wBk0jNiI+9Dcpn8qSU/u+T6UEsF+4xPelU/LTR905pV+7QC0JENPX1qFetPU9aBk6GplPHNV0NTLnHFAEmfypjHigmo3brQAjEetNJ4pm7ignr1oACfekJ9e1Jnv2pv1oAX61JCahz1qWHvyaaAm/8A1UdjQM44pO1MCKXoetVj71YkqA9CeaAIW+tRmpW//XURoAaaAT2PNJ3oH1qQJAfwo7EimjkU7vQAHpTaWikIaKcKSlH40wHKaniJ/pVdanjPYmpYiyOntTxyPao098Yp49O1ZNCDmlHcU38aX6VAmHalpKKRAoPvSg00Y70dqAJFPoaev61EvXpTxSAkX6VMmPeoF+tTR1I0TJ+lWIRzUCfhVqAc5FTcpIuwKMVoW64P8qpwLWhAOR1qblF6BeKvwLxVWAcDrV6EfypcxNyzCvFW41wKghFWkHFNSJHDFKOnSgdOlJ25p8wDg3NSxP71X59Kkj9utUmUmX42FWIzVOOrUXWrTLRcjb3qUHNQJ0qVTVpgSClFNXpTvcUCE9aSl+lBqLCI26Gq71ZboaqueaiSJZBJ0qq9WZTxVNzzWMkQxpNITSFqbu96mxncdmkzTQRRkUCHZpc1Hmk3U0iSbNJuqPNJu4qkgFduOtVZTwalduKqzNwaY0VJ264qnIanlOc1WapLTIG7nNQS9D7VZYDBzVeQVJVyk/U1GR1Aqdxyeaj2nPekO5EBxS4qULRtpDuR4pCvrUu2jaeaLgmQFTikxUxWmYouUmMAxRjj3FPx2ox3oGiE+9NPTipG71EaSKGmk4pT3xTeaYC05evNN/nSr70gJ0qQGoFNSA88VLESg9fSnA1GppwNSIkBGMUueKZk0ZpANY8GoiakfvULUIaEpp6GlpO9UkMQ0D9KXA9aAPWmgE/pRilFLj0xVoBmPQUmM0/HXNGPaqQ7kZFRMKsEVGw4NUguVmH0qMr1qwy+tRkCgLlcr6U3bU5HembaaHcgK4yaQD1qUik21SGNAx0pyr+VOC1Iq/lVoARamVeKRFqZV46VSQrjQvWk21MFo247U7E3ICvNN21YK0m2iwrkG2gJ61Nso28UrCuQ7R6UoWpdtAUelFgIttFTbTRRYDz+lFNpRWyOgcPepFwRg0wU5aARKtTxj9arr71cg96Yy9aoeOK3bBcYyKy7JeP61vafF04oA17JDgYratF4qhZxjANa9uvFCEXrcccdKvwiqdv6VehFWiTRt+lXYqpW/Sr0XtVohluIVZSq0XSrKelNCJkqdagWpkqkJkyVMvSoUqdaZLHrUq9aiSploJHjinjNNWnigAFPFIKcopgAHNBHFPxijHFUhEJFMIqYioyKaERHvTDUrfpUR7+lADCKjNSGmGgCJqiNStUTd6BoiIqNqkPSo26UhohfqahbHSpm6VE2aTGiu/eoGqxIKgbvUjRA3SoW9hUzdCe1QH1HQ1LLQ01E3U1KelRPUstEZphp5/SmHp/KspI0RG2OcdaiNStzUTVk0apkZ69aZTzTDWUjRCUo9KTPNANZtFokB4607NRj3609e9RYtEimpVNQoKmXFQ0WmSrTh0pi08VNh3HinDNMHSlH8qAuSD8qTPvTc0Zx1oC4pNNzSZ9aaTSC4pNRMeKcW7VExoGITUbN1pWNQueKLAMkb1qvI3WnuxqrI3BpWAa7VA7UrN71C7e5oSFcjkPXmqczdankaqczcn0qkiblaZutVJG4qaU8VVc+tWkBBIetVnPBwamlbr1qrI3WrSJuQyEZJqu7cU+RjUDscVqkTcikIqu7dcGpJG4PNVnbritEiGyKRueKhansevFRGrSIuIaSl/Cj2p2JuIB1pfwoFA/OgEKPWgdelKBSjPY0hocOtPHH0pg68808ZxSKQ4dKkSmCnrSKRKtSr+YqFPfrUqVJSJ0qRelRJUq1JSJBUiVGv0/WpF9qkpEq1PGeKgX3qZfbGKzZaJV68GpF71GvT3qUYz7VDLRInSpBUa4qRRUsY9enNKPpTR0pelIY76UozmjPFAoGL3xS/SkHWl470gCkNO4ph+tADTTG79akNRn3piI2qNvpUh5qNu9NMRG1RNUp9hUbYpkMhPtUdSkVGfatESxh6c1E341KT146VGw61aM2iM96jPQ561KfbrTG78GtEzN7EBqJh1FWCMVE44NaxZlJFdqjxUzDiowOK1T0MJIb9KQCngYNKB83HUmqTMx8S569q3dKBhR3P+sK/KPQVmRKI8HPzdhWtYEfvyTk7KUmaRVgiRAzEtmVuvsavaNbiXUUQsDjnr1xWUMcsp461qeHUkaZ5BnCjmp6Fo6vR3D67ByTsYD1Fd94gZRFACf4ga8+8Jr52sED7qnk+tdxrv7xIVORtbP5VmzRGXrs4j02c7uMAA+tea3suVbJ5Y8ewruvF7bLNVGOTXnV2SZh6DgUR2KbsNtV/wBIX5jgdauzsHuMknAGKp2wBl4PAIqVm8x9wPGc/rTvoIso2Zec/KOKx9UkD3JHpgVqlgC7Z4x+grnbiXdI7ZPtQhsbI+/kgYzj8KQsc4FQI2TyaajGSdsdBVJkdS7aL++HPSryLtmYH+HGKp6apLux6CrqZ3yE+1BaQ24fMpx2xVaAhpHcnJqa4xk9c4yarw8RsB/EaEI09Dh86/jz0zXoDfuLMnJyBj8647wxFi5DE8jGK6zUX3IoJ6n+VZzZrHQfayeTZDcSzGtnTICsZlb77jP+FZEMasYkOc5+tdJboFZVA5xmsmaI2LFMQjjtV6LqpI6VWs+IwCKtRfdAPUnFSUWVbajcdqm05QIsjqarynChe5PNXIF2r8uKfQgssA0ZGaxiGkvJWB+WIbf0NbG75Hz128VgbzDZXLk/MxJ+mOKbHHU4jSUMvjGN8/dfPX37flXtEBIT2FeL+EUM3iIHd83mZ/nXsysQuCKpuxPclk+YZArIi/4+ZQOoH9a1C2U4zWRbtt1SRTkhk/rUXH0NmKQmONm7gZ96sM4GPmFZe9sIp7dPzqNp2DbmY4HH41UZEuJLPIot2BwWD/1zXnXxI/1lqQBhn/xrvHYeVKX9Qelef/EJ+Ldz0V/8aTZS2NDwVN5Vy6MTgx108FztuimfvdPwrz/w5eeRqEZdhtkU49hiuga7aC7iIbMbcZ9KLE2OkSXb1Oee1c1r8iRyl+Rhw2cdqWfVUjSQO5GPftXK3mtfb45YQDnopPGcd6aHY7i01YMWjZvm2gg+1XGvUMf3xmvLH1N3tVct5cicZHGCOKWLWZdoYlnIHUd/eqsyWegXV8u6OVHAkj5Iz1/CsTX9QQ3NvKeQrjn1B461y515ZM5OGyAS3eqs+qGWMxvyoPBoV7WGmjo7fWxHcvACDFMTke471nabqDWmoXVvv2qxG3PGQTXNfbicozAEdTnuKfLdLdTYkbbOg4PTcvr9aEK6O8l1dUiwX54rE1TUmnwFY7SCSazY7oNCgfBIGP8ACoboOXQofkH3vYVaQtDIvrgJLBcKRlZcNWTqmGmkKg4LE1dvkDxyqqnDHd/TNZxZ7q2VBjKDH1I9fwp20sDL9kQ1hvA+4cn2rs/CusPb3ETM25cAc1x+gKALm3YZDxZ/rU+nM8MphYH5TxU20sF7HffFW4N3p9gWAIGcMPz5rB8E3xtYAScBZQRS65ete+GIFOSYy2T9DWHZSmG1Uo2FHzH3oXw2Ff3rneyaksdxe3G7e3mKQB3BFVLXUG0/xEs4b5XCk8+tcq2ptLEzK21cc7aiW9M1uJDJmdOPwFJIL3PpDTrwXUUUgfgr+tZniZVurV1b+IcfUVyPgDWzd2IVpDvQAYrpLubzrZ42yJE5BpNBFMzPBur+VNJYXTfMrfKT3FdJeqJIpYz1PT2rybVbiWz1FZxlWzjI7816P4c1CPUbINuy4HIpJD2OA8SW5WdmPDL79a09EuvP014CRv2/pUvju3WON5UH1x3rF0SVYbi0cEFZF2t+NZdbFpmsknmxwKSQu7+Vazx7kyeMDj61iQJt1CNWJwTnFdOVXyjjGadugaGT5oyykHcP1qOYLsyoJJ/SrssIEjEAbiBn3FUpCY22N0NTcpFCIFJWQg4bmmqN0ciEcjp+NXJRtdGPaqsw2SKwPBODTTHYoqm63Zccq2KaoaSPjG4cGrCxEPKRnbuqCQeRLuXOw4z9KLgZt1aHcQ2Cp9u9cvqViI5JAykxNzx2NdzcL8pA5DcisLUIvmBAyf5inFtCaODa3wp3fMB3FUbhODzxn0roNUh8py0Y4zyKyZ03KSuNtdEZXMZRMtlAUnPFRkFeh4qeSPDNtPBqLsQegrRMysNGeqng1EG8tiD0/nU2VI4BFMf5kz6U7isRTRbhvj5PpUTLlTipv9WQQeDTmwe1FxFXgNyeoqtICkx/SrbR8nI+lQXC5XI6ihEshX7/ACevFMYYYin9QDmiXrxTTIK+Dz6UqdDmnMOuaYveqTEWdMfFzg9MYFbEh3W6gjjNYNo2LhfyrbjbzLU4AyDTFuRf8s8c8YFE3QgUh+aMnnjH86JhkGhAL3HNHTA9KF+bb9KTqc0CFHA4pwNMpy0DRMh96nU1WQ4qdD7cUASE8H0qu7dRUx6Y7VWkzk0IBpPpRmm8c80n40AOz70hpKT6YoAWpYOtQj9Kmh64zTQE45FIT1zilGKa3vTAic8Y7VD27dKkl6GojnHagCJ+BUZqRqjNIBmPSgcfSl9cUL3pAPHt0o5oHHrS9qQMb/Oj+tB6mjuaBAKKO3FJn1oAUVIrY/Gos+lOBpNCLkTAipR+lVIWqwpJHA5rNoB/9KWk/GlHuKgkTt1o7UvFHc+tSSH40dqO1A75oEKPenimCnLQwJF68Gpo/SoFqaH8al7FItR1ctxVOMVftl4HTPWsm7FIvwD16VfgHSqduPQVowL0rO4XL8A+XpV6AcVVtxxV+BeR7dam5LZPEPWrC0xF4qUfShMgKb6mn03j0qkwCpIhTPpUkf0q4spMsx9PerUPWq0fpVqHrWqNUWlp61GOlPWtEOxKtO7U1aWmIXPFNJ4pajY1JJG7VAx680+VsVWd+Dk1DJZHOwHQ1Sdqknk9Kqu1Yshis3NM3U003NSZslDUbqi/GjNCESFvem7qZmk3U0KxKG96TdxUW6kLVQhzsMGqcrZzUsjcGqsh60iiF8moDUr96jOelSwIW6GoW6VYIphX9KQFQoSeBR5Zq0FFLtFIdyp5dGw88datbR0pNopMakVdhpCoxVrb1xTGWkNMqFaYV9qsstRstK5SZDikxxUhUUhFFy0yBxxUDVbcdc1XcfWhMpEJ60nrTiD2plMpIUe1OHpTQD/+qnDpQA9TTh060wU4dKliZIp/Ong1EvvTgakklB9aM5FNzx70Z4oAQniojUh71GfxoATP+c0gzil/CgDmmguJilApQv6Uu2mguJj2pcccUoBpcVaENx6UoHrTsd8UbfWqSHcjK+1MYelTEUxh61aQXKzDrTCtTsvXimFfpVWC5XKnnFNI7VYK00rRYorlTRt+tTbaNtNILkSrmpVX0pyrUiJVpBcRF9RyKmVaVF9qlC1aQrke3jpRg49qlC0BfWmK5DtpNtSlR6Um386RNyPHoKNvrUm2kxQAzb3FAFPx+VA/SkA3AopcfWigDzcGlFNFOFbHUOH6VKopiipF/SgEx6DvV23X8qrQqTWpYxbiM0DNDT0JxkHrXSWEeAPw7Vl2EA44roLKPAFAGjarxx+FakK/WqVsvGK0rden0FCEW7dT0q9EtQW64X61bQfnVIktQAYq5FVSHpVuOrTJZciqwlVY6sxnjimIsJUyVAtSp1qkyWWEqZelQp0qVaZNiVanWq61OlCJJVp4pi08UwsKBzUiimCpVpgKKTHFOHvR1FNCGEVG3pUpqJhTTERMOtRGpm71CaYEZph7080wigCJulRN0qY9PeomxyKBpkLd6jb2qRqjNIaInqFvrUrcVEe9AXIXqs/fFWXHBqs/epsUmQtioW96mboahepKQztUb089KYxqDREJ9KYcetPb8KiY1my0NJqJqcx4qFj69KyaNEB96b9KXPHXNMxWbRqmHrmikoHWsmjRMevJp49qYuKetRYpMmT+VSCokqValopMkB4pwxUYp4/SlYB4pRTB0pR1osO47NJnrSE8U0njrSsAu6mk0hNNJosFxSeaiY0rN15qFm96LDuDHrULt2zSs3WoXb0pWAidqrSNxUsjdarOetDQDHb3qu7E05z19aiZqLCZFIcCqUre9WZTwaozN1xVJCIJW61Vkbg1JK3XmqcjcVSRNyORutVZH4NPkaq0je5rRIm5E7cn1qBm605zwcVC7da0SFcikY5NV3anyMecHOahY9a0SIuMam07PFNxVECd+9H50tApiAe9KBQKcKQ0AA6CgelAFOHFIoB1z2pwpBTlpDQ4cGpFFMAqRRSKQ9KkWo1654qRRSsUiZOlSKaiTrUqioZSJF/WpVqJakWpZSJU6VMvSoUqZOahlIlWpl6VClTJnqO1ZmiJF9qePrTV/nT+KkaHClpoz2p1IYo6e9KD+VJ9KUdKQxwpR0pKWgA9aD0o9eKDQA01EetSmoz1NCYiM96iNTN9RUTd8VSER+tRN396lbpULHHFUiWMPSozTz7mo2zVpEMYc84php5xTW6Y4rRGbGHpx0qMipT+lRt9RirRDImH5UxhUp75pjVaM5EDLUPQ1ZcVAa0TMJIQCnrgcL1ph6delOXpmtEzOxOh657Vq6ZhhLkkfJWKDjOCa1tNJW3kJ6mhjQyNcjg5rq9GjEOiySEfNurl7YYjJrrtyw6HBEOXdg/4f5FRJmsUaPgT5Z5mIPY59663Up90ypg42gn25rnPCIVWnjyNwCn68mt29Yi6GOhTH5VnfWxrFHN+K5PNhXP3QfzrhJJCW3HpXVeLJgBFEM8D161yUoywQHgn0qtLAxykpbsTjLcfXNTAbYcA88CoJwCyIKmYkNjj1pBFEV5N5cLYPUBRWLcHoQetXNVlJKrxkVmyuemfammxsAQI3PemWoI3HuaGz5IHfNTWandzVJ6GfU1bAAR7QD2zUy8GTHQj+VNs12xMQeTUqjCEZ6ikmaFS5cFP9o8VFEh8yOPv3/GlfnLNnCj86l08EPvfkscUybanVaBHmZQMYWtmf95d8glE4NZuiIEyenar9uDIzAZ+bj9axa1NU9LGvpULPIZuwOB6YrdtstMCapafHstgF4AFX7Vd2MH6VncuJsWx4FWoCDIc9uKpRZRQT25q2jBUJHU4/M0kUWF+di2OnT2q7Dkrn2qnCPlOM8CrsY/djHSmSxd2GGc9Kwr393ol1KxGSGC5+prUu5DvjCj2/GsTxZI0Hh64AHO0imgTOZ+Hif8AE43n7xOf516zFIcnJyK8q+GOWn3kDIX69K9OhfO7OOgqnqhtalreMEg8Vku3lamrdip/nV5nCEZxg+3Ss7UH8ueJ35U5X/D+VZ2AtzPiNTzkHNV5pT5eBnqCfzpizD7PwpODn8Kgu5cQll9R/OnFCZZvJD5bKOrGuG8eqZLBMfwkH+ddfO5A3H8q5HxY5ewZQuSzZ/LNO4IwbRgn2OQkYKEfpWrLqatbRBSMq3r0rnIGLWaBfvRA7h61DaXYCAKu5i2Dn3pCsad3dNcOV3fJn8z7VmztukKxg5zwatNA3zZYAkgfrT5YQjnYPm28Y/n+NUhGXNBm18q6kKZ+YY+veoRKgh2lJWVRgY71qXVtny2f5mwDzTEh3RxrFjrz9P8A9dUmFjPaRJF2yQsFx7VUlt2UMUDInvW6IyWUbQ2D1xUGoW29iCSvQn3qkybHLXB2nljuBx9Pen/a2KhmVcLgZ5rUmtLfaUVGyB1Pf3qtDp+SY1wd3b1oJWhYsLgGNvLYHgcHnNWJnkxutWDLjJA5/GqMNnJZylWQZPX3q9bW7qkjwqdxOSAeCKAMtpXE7AsASMHisWIssjDccht315ro76FTbyFD8xIJHTvWDOn7+JlHA6/nVp6DsXoJzBexSAny2xntweMfnWrMpjvNwyYpeN3p+NZl4oV4gE+VlyK09KzcQJbS5J/hqUO2hGl0Ps15bFv4Cy89fpWFHcOunnB56H25q/dxMk8m0YljJUj1HrWSx4lC5CnHHpRYlouWkxaKRcgNjp7ZpsMxinVlxwMH3quvyzI3QH9QasXMYS4jIP3hg/UU7BY77wFdotz8h27yOPTrXopuGML7jk4wOP1ry34fxj7cFbHHNemIvHBzjnispPUtbHHeJla5iYA5kj7Yqp4Y1eWwmVlYlM4YZ7Z9K6LVLbN75yAbWI3D19653U9La0vDJAcoybiKmLYSR1viC6h1DS2kjbll49jXD6dLujt2UnIYqw+h6itKxV5bZgrnYRyPSuYxJa6jJEWOCSV5x3pWuPod0Zd13HKTgAqM/XjH511EJ3gggZrg7CczWLoWO+Nh+I611miXonj2lhvAzRYq2hfcYkKt1I4qlcovmrnkYq7MxkwAPmFQSgb1yMnH51IIpvGGQkmqUygp14HStcqNmMYPSqDoSGU4BB4pFIzrYlg6n16+tLJHwUIJB/zipLYAGZXxnqKk2l0z3pAZSAqWhY+6/SoJrct0Bq9dxhgHXhl/CmHEkYIPOefY07jOd1LTg6NgAOa466t3inYEAHOCPWvS7qMOnB+ccVyeuWBYM6r8w6/41cZW0JcTkJ4vmO0gGqJB8wqRz9K2JIcqSPvDtVGePzR8ow4/Wt4yMZRKTDaeOe9MU84xxVhgSmQPmFQsPb61aZnYglQEFSSCOlMjBwQTkVMOpyMgdfpURXa+5D8p/SmmS0I54CgcVH5YKkY4p5OfmBOBQrAtzx2prQllBl2sR6Ur4eMEAdKs3EWcMO9V1GAwI4pk2Kzg+vUUxT1zUso+Q+3SoAfTtTIHRELOvPcVtWb/ADMhPBFYbfeBHUVpW8hKbh2xQJaE+3BkU+vFOk9PalmH7zcDxgZpJOGX0IxTuDGQnK9KVetJEQFNID8x570xDvWnKaaeppRQBItWIuRxVUdKlhY5oHcsMODVaT26VabG2qsnf1oAi4xRntngUp79aTt2oAPpSe1B6UlAC8U+I4amUq57GmgLimkbHOaYp4xmlOe3amBE/TjmoDnJzVluagfGaQELZ5qM1IepqM5545pANNFLim+tADgex6U7PHPSowacvSkAtH8qTtzR3oEH40dM4o9fSm9qAFz6UoPBptAoESxHBq4h49qoISDnNWom/Ks5ICyOnSgUinjn8acKzEAHvRj8qSl4yaklgPSgd/aijGM+tAhRx0NOHvTacv8AnigEOT9asQ1AtTxDHOaTGi3DitC3FZ8PWtG37frWMkM0retCAVRt+mOa07YZ61nYVy9AOK0YFqnbrxWjAuBU2IuTovH0p+KFHGPSnYosTcZ600jrTyOtNPehaBcbUsZ61AfapIzzVx3Liy5HVqI9jVOM1Ziat0bIuqaeKgQ8dakBrRDuSqaeDUIanBqYmPJ4qNjSk0xs0WJK8/tVGU+lX5RwapyL1rOSJKT+9Rnvmp3Q8/pUZU1k1YhkBFJipttN2+oqCLEWKSpCKYeKCbDCajJpznmo80IB2aQmm5ppNO4A54PNV3qRjUTGhgRMKjIqU03HXrSFcjx60m30qXH0oxnpU3C5EFHejZxx0qYLS7RSEVyvpTdvrVvbTTHx0pXC5VK1GVq2UHao2XipuUmVGXrTGWrTL1qNl9jU3KTKjLx0qMjAOfpVll4z3FQsOtK5omRHoagap2wOAahYc8iqTNEQkdajI/OpiKYR7U0ykMFKKPXpxS+39aYCilFN7c0ox2qRMePTNPB61GD70oIpWJuPU0uf0puaUY75pWEL2pCKcKAM/SgCLHUU4DmpAo7UoXvxTC4wDjpTlUc9acBxUgH6U0IjC8c0u2pccc0uO9WhXItopNvFS49OlJj8q0SFchK1Gw/WrB7ioiK0SC5Cw60zHtUxFMK0wTIscdKbt71Lt4pMUFJke2kC1NtoAppDuMVRUqrQBTwB+NWkFxUHpUyoMc01BxUoHFWkTcbtHak2jtUlHanYm5CV60zbU56UzHOR1pWC5HjvTSOKlxzzTSODRYdyI+lJ/KnGkx1yKkdxMUUuKKAueaU4daQdKUVqdVyRalT+tRL+lSx9eKBlq3XJrc09ORWVaLW7p6ZYDtQBuWMXA4rbtkwBWfp6/KOK1YV9qAL0A9RWhbdqoQjitC3BoQGjD04qwnpmq8PTmrKVSJLMPTFW4xVWIVcjFUiWTxirUYqGIc1ZjFMRIgqZKYgqZBTRLJYxxUqjimIOKlUVRI5PepUqNalWmmIkWpFPFRrUi9KaEPWnjpTF6VIvSmA4dKWkFFNCGnpUbdKkNMNAiFqjbrxUzVC1UgIj0qM+5qU1GRQBE3TrULd6neoWoAiNRNUpqJuhpAQv3qFuhqZ/pULUDuQv0qu3U5qd+ntUD9OtIaIW71C3epm71A1QaIYe9Rt3px6VGxqGaIjaoW9qkeo2qGWmRN3qJqlbpUbVm0aJkeaSlPoab+NZNFoDQKPSgVDRomPHSnr+tRrTwfeosVcmWpQahU1ID60hpkgNOBqMGnA0rAPB4p2RUefejNFh3HE0wn3pCabn8qmwC54600kU3caQtSHcRjULnrmnOetQO3JoC4jH0qF2pzmq7nrmgLjJG61Wkbg1JI3Wqzt1osO4x2qF2FDt+dQM3WiwrhI3BNUZ261Ykbg81TmbrVJCuVZW96pSN15qxMeTVKRhzVpE3IZG6+tVpGPPNSOarSHr61aRNyN255qB2p0hqAnrVpCuNY/WoSaex7VEf1qkSBNFJzilHWquIBSj8aKUUxWAdKcKB0pQMDpzSY0gHT0oAp2OKKRVhB+dOUemKBTlB9eKQ0hy+tSr0pqjingemKRSQ4DtTlpAOKcBSY0PT6VMvSol9qlWpKRIvpUi0xakTpUMpEidKmj/AEqFelTJ061DKRKlTL+NRJjHXpUo9QeKzNESCnjpimr096evQ1I0OX1paRe9LSKFoHHQ0UD9aQD+tKKQdfalGPWgQd6Tml7UGhDG+uaYw4NONN+tCFYjbpUR61M3sKibvVARN7dKhapmqJsY6VSJZEcc81G3FSt3qI9Tk1aM2hh6GmH9akOPSmEVaIaGnGMmmGnN0pMdcVaM2MPfpUZzUppjDtVozaImHB56VC3uKnb2qF+vPStUYyIjSjGKUgc80h4q0zIXOT7VqWRAhGKy1FaVp/qgKbHF6ly2QMFUdd2K6KRv3tvCOdkeD+J/+tWBax/vowMk5Bz+NbQYi+faeFwB61DNoI67wxCwFxI33mAA/DNaM+ftXJ6R8/XNO0a3aHTN7Ab3GagyWjdyBknb+ArOxqrW0OE8Wyb9Twp4UAVz6k/aQSeK09al36jNk9DisyP5pjzQhDnybjnOAamkzuyeBiol5dz6dfen3TbbctznGKNwiYd5JvmY9hwKqJ87c9adO2c0loBuJ7DmqB7kjDLYHYVctE2IW4JPAqtF8zMcZJPFaFtHiRVB4Uc/WgSRbT5LfA6niiRsRhR94/oKXPzY7AU3cpV2OAF/lTRRSm+aVIF9eauWe1rkL2UAflWejDzGYnknH0960NOXdcqFIyfan0JR1mnfJC7Hrjj2rY0tPl3HqcAVjwA7WB+6MCtzTwRGp4rFs1ijdtDi3AGMtzV60XJyMZ6VWhBKqO3H5VdtF/eHHrxWLNEX15jw3rUszBUXHVmpsA3E5/hPeo7j/j4Qc4UVNxo17YcDP1q2D+7wDVO1b5QTirAceXkEVSYmipOwLRA9dwxXO/EKcw6JJnPJA6djXSbA8ysT8qmuT+Ir7rKRCMgYP5GqT6E2sVvhcAsZXncFyfxNeiwkiRht4Irz34ZHzJLmUfdKYHtg16DGcfNVMdySbDDaT9PwqjckzW5RsbgP1HerE7HblRyvOKqyEgZUDtmpYyG1m3QtGB8ynBqK4dmXy2IwMHp71G7mK48wZ2s3NPu8iZWAyDgGkrg0PunG5ATxXMeIiFhL88dR+NdHLueVAOnXp6Vg+IojKiqOMtgmhISOUtECxmWTgyHB49SarGAwzEgYBbpjqM1pmHNqCMfK+3Hpz1/nU89ozxvJg5T5s/jQ2MZbW2XYnJIGRkdKmEIM4XHzNFx9M9au28fzkgHDLj696seQxkjYLyFx+FNMkzLq0+RF2/MoAP8An8Kp2sLNCEAAAc7jiulMQERBXkkZP0qpbQr5UuOnmEfhmmmK3Qz4kXftjUbVGM465PWq09oZpndiQpPHH4V0UVmrPIoAwcYx7dcU97QbtuAB6kfhxTTFscjNaxq33SePSqb6fLIMxqVX1xiu0FivmNsAPapfsB2nOMY/WnewHFCylEySCNnIwv8ASrS2dxGSUhKHP5A10ZtMMQByrj8s5q/9jdncgHaef1ppiOJOn4l/ex/MxOfcjvWBqVksN4YgoG5Mj869TudOLyqQo+Ubhx/n/Jrm/FekEuk6/KUH8/WncdrnL/YftFnaMVHA2n8CahsW+zxo38SS4z64P+FdJotsJILaRgNrErj3z6fWq9zpHlJdI2Plm59uT09qSYJXMrxNCsU8V0vIfhuOp/8A1Vzbwk3Lqv8AEua9J1PTvtvhrG1S8a7gR3INcGke2VzkbgvHvTuK3QoyIXKpg5UE/l/9arN3bxy2EU4DeYgJPvipYYiJE3YyykA/hV+ztw2mbm+6WYH296pMllvwFcoL9JEG4MNp9q9WtWR8shHHBFeCeH7o6XrQAY+UW4+ma9n0y8QlCucHHfsfWs5LUtK6NK7tkeFx6jNUZ7AXliCDiaPj2rb2q6EEds/WqZUwzjaeGHI9xUWBbHJQobW5KLgbeo9RWJ4qtkEiXUBBKkZxXT6/aB5FmiyHzjj+RrNtGW9tpbSVB5uCOnX3ouVa6MnSbsDEi/db7w9q6KA/ZbiOWNjsbFcdZbrWaeBuCpxg/XtXSWcvmWqxyuOxB9D6UhRlpY7COcGPcOpprs2QxBxWLZXbW4VJySh4DelbMUoZQCSVOMUmUh4/eA+3Wq0oy/AHYVYT/WMO3QU2VFzyPaluO5mSRiK43Y+VvlNOLKknXrx/9epZlCnDdKQosgUsBSYypcKu87sbW4PtVARmGRk4KHpWlLCwJUkFfeqMiblKEncP5UFIhVPnb17Vn6jbiTJCkHFXy4RtsnysO57io5SZDgnBIzmlewW6nCX1mUnbYOe3HWs2e2ZDvTOQef8ACuy1S1UyKQ359ayHtUdWJPI61rGZDRzbQBkMkfDZ5FZ1xGVJI6VuXKm3n54U/qPeql3CGG4cg1spGTRkMOmCM4qFjg+nY1caMLwcYqu67lOevatE7mbViF9uMYNRkA8CpEOQVPUGmEd88incgByCjdO3tVbaQxVs5qxjuDn1pcqw2vjPZqaM7FCRflYHrVPGCcCtKWMpnOSDxmqMi7WPoapEtDByPerVk33we3NVR14qWyfbcY9eKpCRtOAUUg/w4/KopDwueuMVMPuYOAAeKg6qDk5qRMag4PtzTT9446A1JHw7DsajPVh61SEPPWgdeaTPApaAHCnp1qMdaepoAt9UyKrv3qdWytV5OtCGMJpuR60HNNoAd60lN7UvPrQA4U5fSmDp9Kcp600BMvTHU06mJz1qQjjimAxveq7/AMqnf3qs/ekA01GenIp/XNIaQEfrTfennnNN7UAJTgeKbSrSAXtS80Unr60AJSHFFJ/KgQZoHqaQUv4UMQD+tTxN25qCnofyqGBoRnjFPqtC3FWB0rJiHUD600Uo60iRfpR9aB6UfzpAKPwpe1NH8qUEc5oBEydeKsR45qrH3q1H096VhliP9a0bUdMGqEQyfatOzTkccVDQrmraocVqWydutU7VOOK1rSOsrEXLdtHmtKJDjmobaPgcVfiTimokXGBaXbU4XikKnFPlJKxHBph7ipnXFQPU8oEZ6UsZ5pje/SkViOvrVRVi4suocVYias8SCpopMHrWqRumaiNx1p4aq8b5XNORs960SKRZDU4H3qEGnhqoCTNJSA8UmeaCRGGRVd0zkVOaaalokqtFzxUTRe1XMUmOD61DiSZ7RdeKjZMdqvuvHSoHX8qxcRWKbLULDFWZBjNQP3qbWIsVn61HUr9aiPU0hCUw96cRSetAiM1Gc1KRTDQBGRxzRjin7fzowOwpXFYjA796UCn7e/pTgPfipCwwLj1p232p4FJjikxWGgcYxSEH8KeaYfYVNxDCOKjYcVKTUZ71DZSREwqJhwSKmYetRvUXGiqw5qBx371YbvUT9DRc0TsVm6d6hbvVhxVdhxVJmiZERxxSH170859KTscVSZSZHige3WnY6ikI96pMBv1pQPXNGKB6UCuKKUfTim9sUo680CHj3pR0pg6cU8D3pAPpwHFMWpFFSA4DI56U4DtQPqKcKkkAOtKBxz2pR7daXtVoLiAH0pO1OPSk+mK0iSJTTTjim+taxJGn603B9afTe9aIVxhXk00jjvipfrTfrVAmREHmk28GpCKTFBaZHt4pwHHTgU7FKFpodxoFPUCgCnqKpCuKo4pw6UD6Uo6VaJuKMYooFFUSNNNI/Sn0hpDTGU0jin02lYdyIim1KRTcVNihuKKMUUAeZCnLTaevWtLHVckUVNEPzqFetW7ZQSOOaB3NKxj6Zro9Oh4B71k2EXeuksE4GKCjTskwvFakCcdOar2kfHQda1IYxjoKAHwR1fhTHaook/KrcS0IRYhHFWYxUMQq1GKpEsnhFXIh7VXhFW4ulUhE8YqzGKhjFWUHpTJJEHFTLTEqVBTQiRBxUgpqjipAKaJHAcU9aRRxT1FNAOUcVKvSmqKkFNCFWnimrTqaELRRRTFYQ0w0857U0imIibvUbVKajIqkIiIqJu9StUTd6AIm71C/pUzelQt60DREaibODUzVC+cUgK7nn6VEx61I3XrUTUXGiJ/5VA/fNTN3qFs8+lSykQt3qBh1qduh71C361JaISKib3qc9Krv1pWKTI254qJvpUrGoWzzmsmi0xjd8VEaex4qMms2aJjTTTS/lTazZog/Hmge9JR9DUFpj1NSCoh7U9TU2LJl6c08VEp+tPBFIB4PHFKGzTAefajNFgH5o3UzP5UA9cdqLDuOLUwmkJ600sOlTYExSetNLcUwt70hbA4qbFAzVCx4pXb0NRFvegLjWPBqCQ+pqRm6moHNAXIpDVSRuDzU8jVWkI5oC5C596ru1PkbrzVd26800guNduCaqTN1qWRuKqSt1qkiWVZmOTVORutTzN1zVSRuuKtIlkMjdarOeDmpZDUDkVSJuQuahY9qkc9eahNNCuMamU89KacetUguNpR39KWlA9KaBAo/KnD3HFAxjFKo4/Sncdhw/PNKBxmkUfWnYPbtQNIB0pKd2zQODSGAp6+5po6HFPH50hpDhinr+FNFKPoKVwJF5p49O1MX3FSgZHJFSNCgdqlXtioxUi1LLSJE61ItRr71KtS2ND16VMtRJjHSpUrNlInT2qVelRR+lTCoZohy9KkHpTFHapF6VI0L9KcOlNFOHvSKQdqcPWm47il789qQDhxRxSCgGgBfrQelBpO3WgLCGkNKaaaYDG9qjapG6Go/50ySJh6ion6VM3fNRN3ppkkJ61Ge9SGmGrTIbGGmHoaeelMPT3rRGYykIGaeOOKb61aM2Mbp3zUZ6dc1IaiOOwrREMjY+tQtUz46VCR1wa0TMWNH50H07U4CkAJzVozaHRqK0bJcoMDoapJwvatCNvLtQM8kg0n2Q4o1dNUtKz8YQVe0wb7qbOflG4/nVXRfmjlA68Vc035LyVQeq4P59Kk1iz0DTJ92mqzHpwKqGQCzlYtyfu++Sagt5dtkqDOVFZt5c5hiGTjdipuaJHJaqu26diOSc1Qgz+8fH0rV1kqZsFeelUIlCxMRg81KHYZAuSEAG5ufoKbqPKFA33eDT4Ts3OepFVnbJwTwx600BhyjkipIV2xHPfipJBtlIIGR0pevHHPFO4h9su1GYjmrungZYnlsfpUATZbkZ+Y1bsE+U/Si40iYjnODkrWfeSFYgi9CcH3q0zcnknn8hWZdSbpMA8DihMLCKwyAcYHNbOjLmUvxjOBWGx5AH41v6QpTaAOtDdhR3OmtwT1z0re0sZVT2rn7JjnAIz3rf07cEALDPasm9DVI6KxbchVjyvSr8R2nIAzn9KxbVinzc9f5mtaIkISD0IzWd9C0jXhPDA+lUb05v1APy45FW4m+Ttk1TmG6+RieNuPxzUlG3CAEUdsVNgLGMYxniq6oQiEdAPzFWlGcZFNCZEuQxVQeCM/WuO+JLFbKQDA45967UfdkYjHNcV8SlA09mb+IYFUiVqL8MP8Ajxfr/wDrrvF6dTgVyHw5gaOwR8DDwg/jXYKRjAODVSEuwxsljg/WqeTh0Y8A8fSrrLgY9DVV1G9s8ZNKxRVMPmJNGThgAV5/WgZltcDHmKNp9iKfIGjcSAnA4/CmPuD7wp2sMEY70loG40MSsbnGVHP48Vk6tGcxlucOOhrZWNfLI7E8fjVDUIeARnIIH15pXFYwZbUIhDEBXbd+P+eauwKHjJPfhhjsKsXtqWjyMYjPf8v5UttbkE7c4ouMiSMIuY+VHT/CrkIVlDAf5NTQQfKAvpyKkitipITIHf6etCCxUkh44+tMs7XcZBtPDjNavkEd8jvmpootoYKvU5ouIzorc5AIIA9KtC1VlwVz36da0Y4QDk1ait8cgCrSIbMZbJhgxLj8MZp62LP94quO1bwgHGAOKcbUdwM07E8xzE1r5bswGcEduoq+YPv4PBAIq9dQACRSvFSNEoC/7ooQmzMeBSq5HGKytZ09ZLV2+bOOlb7x5dVPpUd2oZQgobKiec+GbRpNwZGCRzsAffNbl/pTWzzzyLmOTn6H/wDVWloVqLdbxCgx9oOOOue9dHqFtHNpkqsARtyPwotuJys7HJWNmFtCu0eW4z06A15T4isDZeIXijACSKXQe1e4NaqtoFGduPWvMfH+n+VqNjOo4BKk9c5qU9S/iOUigMjWcoPDMRx2+taujQeZZywHjDE9O9O0CxlmVnUjyUkwOnJJ/wARVmzxEtw2MbJtrHPTPFVdpBboed6nG0d265O5G/ka9Q0O822cBkY4ZR83p9a4HxRB9l1STz8FJDkEdwa6Pw64kiW2kcbCm5D7elOTurhBatHqWnXStGqEgnopz1FS3JyFYfeU1yuiu0luYixWWLgY9a2Y5WlxknI4YfSoctClFIk1G2EsLlQQxG78a4maRreR3VSs0R456ivRVxsGQSOlcv4ksB5vnIvDHBxxz70XuO1jk9eTzQmoQd8B8dvetHQytwFViNrLg1Vs8MlxZSAnOWGfQ/8A16p6NOba6a3bhkOPrQkRszsIYVNu0bHIU8806zla3kEbNmJuh9KLRgy+ZH0PDCo70YjLxEHBzUvsUmbqOVOD370M3PJzVS0m861Vhg8VKuWOG7c0gQ2bD4QDjqaYVKxqCDweDVnblcBcUMuEIJyTQNFaVQBnj/61VvKDbmwQT7VdeLeuOeetN2B04zgcflSY0zJuIiwIZQQOM1nzQSRg+U3Tt1rflgOCV/KqjwsyZAAIpWGmc1eOJEww2Sr6jH5VnLtkhbIw4PIrob21Dqd23P06VgzW8lu5YfMpP+RmhMdjG1SLg5BIPt0rH+aA4bmM8H8e9dVcxiSIupBU9f8ACsaSAfxfdPStYyM5RMS4t/m+XlD0qnPGVHHatkw7d0ZJxjj2NUbiPLYGdwGPrW0WYyVjHnXB3r1pueNwxmrk0f3h7VR2lGOehrRO6M2heucjrSY2jJGV6HinYzgEc0AkdTVohkROVI6r2/8Ar1VniBU4FXyisCVOGxzULRswx/F/ShMlmT/FnHenRfLICPUGpriPGQeveo4h69qtdyNjcP3UOOD+tQ9CQBUyEGziIB7iom65HrUoQxfvE0xwdxpw4eh/vn3FUhB2paF+7SDpQA4U4dDimj9aX8aAJomzkZpJRjNJF97tUko4oGiqabinnvim0AJSd6WimAA04U0e9KDTAmjPvUwqBOvU1NnjOaYDH6Yqs3Wp5DxmqzE1NgEPrimk+3GKU0h6UWAb296bTvXNJ70gE+tA60Y4oWkAoPFFA7iigBO9Np2KaelArB3pPWk+lLigBR7dKcopq05cd6gCxFmrSHiqkdWFPGKzYD8ml7Zpv070D8eKkiw8H9KXvTR+lH0NAC804e1NGe/SnD2oAcnWrsPPBqmnXtWhbITiiwizAvIxWzYxc1RtYSSBjpW/YQYAPNTYhuxetYuBkVr2ceOucfSqlsg4rXtI/SosQ2WII+OOlXI145pkaVYVapRIbG4pCBin44pp6HIosIryDjkVVk74q5JwDVSTHNTYaK7ehqOnvnnNRmhI0iOB7U5GOetRilHXrVo2RowSfLip43561nRPirET81oijSU08HFVo3BFShqoCXNGeKZmjPvQIdmkzTc0maQrC+1Ham5ppNSTYVsVA9PZqhY9aykhWIJelVn78VZkPWq79zWTFYrt+FRnvUrd6jNQKww0hFPxSYpCsR7aTZUgHrRilcViLbxxRtqXFNPt1oCwzA5o4pSOvrTee9K5IvtSduKPY8UUrgIffFNNKfQU3NS2Kw098Uw/rT/50w989KzbGMbGM9qhfpU571C44Oai47FZh2qMj0zUzjmojSuUiB164qFl696ssOPemMvvzTTKTKrLzTCtWWXvTCvYVSZSZXIpPw5qQj9KQjrknmrTHcjI4pCKeQe9Nx1q0wuIM9KBS+tH86AFHHSlGaQe1OHoKQDk/CpV9/zqIc/lUi/nSsIePanj1zxTB7U4H3pCY4YxjIoHpTc0Z6+lNIQ7PpRn8qbnrSZrWKIHZ5pp6UZ4NJ1rVIQUnWge9GeK0Qg7UH6dKKM9aYIbSY/Kncc+9JQikxAKXHegd8U4U0FwAwKcBxQo604VaC4g4paKWqRNwHSk7UUcVRIUnal6UHpzSHcbTTmndqQ0hjCO+eab9MU4000hpi49qKSikO55etPUGkFPQc/WtbHWTRrVy0GGGKrxLx9KvWqfMOKQzdsB09K6KxXpxWHYKOK6GwXpQNG3Zr8orThHpVG0Tjg1owrxjvQO5YiFWoh29KhjU45q1Ev50AWIl/OrMa1HEBirKLzTRLJIVq7EOOKhhX1NW4144q0SySNasoKjjWp1WmIcoqVBimqtTIKaEOQVMo4pqrxUqCmhMABUiCmgU9BVCJFHFPApoHFPFAgFO47UgpwHFNCAdKKMUtMQw009KeelMPSqQrEZ60xqkI61GaaERNUTVK1RN3zQBE1QvUx6VC/egaIW71E44OamaoWpAVW71C1TydTioW6c9qQ0RN9KhapW61C1IpEbVA2Knbv7VC+DUlIiNV36VYbvzUD5GaTKRCe+Khfoc1KahkqGi0yFjUZ+vFPbNRk9qyaNEw70nfnNJmkznpUWNEwpRTaAfrmosWmPFOHWmA9acuKixRKvSnDpTB04pwPWiwx/86Ae1Nzx1pM0WAfn0ozUeaN3FIBSfSo2NDN15qNmpWAC1MJ9zimlu9Rs3qamxVxWaoWfrQzdc1AzdaaQXHs9QO/BpGPuKidqLBcR261VlbrzT3b1qrK/UUWC4yRhzg1WdhyKWRutV3ahILiSNweaqTN15qSR+vNU5m61SQXIZm681UdqfK3WqzN1qkiLjJGqBj6U9z16VCxqkjO5G5HYVETTnNR800guHHejv2pKUdTTGgH6U4D0po4pwH4UDQopwx70g6e1OHTmmUKOnvSjpQBSigaEH6UoHoTigDg0oHFACj2604dKQe1OxSGKOtKPYUgpR9c1LAkTP4VKvSok96lXpSZSHDinp1pgp69eakpEy09eKjHT2qRakaJV6VKlRJ9amSs2WiZM1MtQr1qUCoLQ9c/hUq+lRrUgqRocPzp1NFKOnvSKQv8ASlpOaXtSABmgUlAoGL7YpPrS0nagVwPSm0tNJ4oHsI3pUZ/Snn8KY2MZpohkbck1C3T2qY9wKhbPPeqRDIj0qM1Ifc0z1znNWiZDG96YeuKcxphwc1okZ3E7mkPINL0ph71aRkxh6cdqjYmnmo29zWiIZERTKkIphrRGTFQYJz3pCME98Uo65PSl27sgGqRmOTJI9KtzcKgJqtCPnUEVZucGTAHAxQNaI2tCb5yvqBWraKBqDkn+GsnRjiZeB0xWxGSt3wBgip6m0VobFtL/AKMxJ5/pWPezFoRjorf1q/v2WxArCuZC0LYzgNn61mjUparIfN3HJJqBcCAjJzjAqXUiHRG9+eKhVe4PGKOgtxkzbYjgHsKpzFhEp7Zqe6f92FwcnmqshLhUGTjmnEGJ5azgEkBwMfWo1hMbkv0+vWpIeXxggYqX5k+VhlT39KdxWG4LJz1qxa/LGx/P6UxVO0kc8YBqRAy25HduKSLSK7kpExPpWYDuck1euyRHiqKcHJppktEtsvmTD6109pAVRcAg9qxtGhLz5x3rrra3JAPP0qJPoOK0HQIQgdTyOTW5Zv8AuVZSDj+dVLa3K9R8p61cto9pMYPBPHvWdzVI1om3RjB6kYrbh4iOCOR+dYdqCAUI9q2Yc+TyBkD+tQWjRVsIACMnApCubmMd8/lRHgFc+masRjM0ZA69alBbQ0IuY9vPAxU8PKAHqpxUcX3eKngA3nHU00IdJGCGWuG+JMYOnKBy24YH1713wj/ec9K5bxhafaAMAkKQce4NUnYSLHgOMrolsXA3BNp/Ouj2AcADPaqPhaDbpUQYY5weK2ZIxgcelVuTsUpEzn1/KofLAcg9OKulfYcVGY/3mfTFKxSKE6fI46+lRxrmM47cEVfdfmIwNtRhNoO31pAZ0HORjBB6e1I0e7dn1q28QD7lyDmmMu48d+tFh7lbyAysWGc0kcWw4HORj/69W8cYJppHPSgSEjQL/vfSpgmOc0IuASQc09fQ0J32FsAj45IqWNV3Hp0pFOOuKkBHUYo2CxNGvHerESluD0quj9QSKsB9rDmri+pDLCxKehPpT2TaOc4pnmqBw3NN89RnJzV3RnZkV0vycKNueT3xUTc7SMEAcU+a4VlIwcdOOKqNMEjAjQ4xUXKSH9WJ49KrId08pGMAAflTmlCAdASapxy8zBCDhufxouWkLZg+XcOw6ybh/LNacmWtCqtzt6etZQZo0cAjB5xU4uMoDuGRTUtCeW+osQDWgR8hhx+VYWv6VHqNs0WCWUYB+tarT7dxD4bNVP7QETlW+82MfhU3LSZ574Vt2gkubWQFgjkfrSy2Qh/tKORgq+arfTP/AOqmS3i6f4pnDlvJnfdj2PpW9cxR/wCmEjKuoYbuelLm0sVbU4nxTZG900zLGpaNc5/w/KqHhndI0AYhcoAO3H+cV3T2ccthMnB+QgVy3hm3EkC4UFol59zk5p9BW1Oi0x2Drhh5q4B9/Q4rZBbPmLgMDgiseK2O0SRnbIvP09q0rSYzLvA2uvDrUlI1rSZmVgxPHT3ov41uLaRDnOP1qCNuMgjFWA+YyD9KaYNHB6lbyQSrcxqd0Rw2O4PWs/W0EM8GoQj5XIDYPX3rub22HmSEZ2uBkY9K5G/tfJ822lY/Z5ASn+y1O+pDRp6JeB9v9xhzV6UpHKQcbHPPsa4nR7h7W4NtKSMHAP8AWusDCaIq33wOPelYI6otWTNY3Xluf3LnI9jWs3yzqQeDwKxRmaEK/wB4AEH1xV7T5/Pj8iU/vUHB9fegaNFDuPBqQIBz1waZETs2jG9Tg+/vTw7AEDGfpSCwjKSxZeo7etQAhZTngMOfr61awWGQajkhDqQTzUjWhDIODgZPaqrAscgHFXYhkFSR19KjkQqSGHHXigZmXSBl5B4PWse6hALcAr6eldDKoZSAORzmsvbvaTKj0FKxSOXuYTBIWUEo459//r1SniDYA4NdNeWyspUrg+tYkyBDslGGBwGppiZhXdvlcAfMP1qhKEdCrjbKP1PrXQ3cPZhhhyPesee3DM2cZHWtYuxlJGTLD5ikjGcYrMliwWwCfUela80bqSYz06iqTvuJI4YcMK2i7mUkZgX5T146U9V3DI6jg0+ZSp6cd8VEhKv/ALJrS+hkIyrjrg0g46t06GpbhFJBXIB70iou3lQT60J6EtWIbqNZ16BZQPzH+NZ5Xa2CCDnmr83C8g8YwaguOHBJGf71UnoQW7Vg1qoOcA4pGI3MoHfNR2BPkuMjhs0+TiUg+tPYka2fM6USfeH0pZMbx60kgPyn1qkIQfd96B1xQOB1ooAUdacKYP8A61OFAE9vjPepZeh9KigPPFTSn5f50DRSbGTTefwp0n3iKZ+dNAFJ60ewo70wAUq0nelUUATR+gNS9jmoY6lzx2oAhk6dqgbrU0nGagPFACUh6Gimn60gF5pvFB6Z70vPekAlA6daKAcmkAo4/GjtRS/jQAU00tNNADee9KKTvxQKAsKO9PX9KYO9OBqAJo+nap0PHP8AKqyH6VOp44qGhWJR05oHTimrTh0qSR1L+dNGcU78RSFYB+YqRR2FMFTwqT700BNbRbmGelbNpFjFU7WPnv1rZtYs9qBMtWcQ6EVt20YxwKoWqY4x0rXtVzjilYyky7bR8dK1rWPiqdugxWlbAUkjNssxqKkpVHFLiqsTcYePxpjcVKQaibpSsBBL0IqlLVyXvVOTvmpsUis5qMmnyHrUBY+tFjSI8H8KUGod3XrTlPFNI1RYU1MjVVU1IjVaLL8bcVYVveqMbVOje9UBaDZFG6ogw9aXIoAk3UmaYDRn3pAPzxTC3qaQmmkmpJsKTULHrTiaiY+9ZMVhjHtUTCpCeKjPIxWT0CxCwph6YqV6iNQxWGnNJxTqb2qGKwUlOopBYbTT9afTTnFK4rEZpO9KTxTfp+NFxWDNIcYo5we9NJ44pXFYU0w+lBPHWmk96lsVgJ4oPvTaTt71m2FhD3qJ6kb2ph6e9QBXcc1CR+lTuOMVCeKQIaRnmm4p/r702hMpMYRwcmoytT496jI6+lWmO5XZeuetR9O1WGXqKiK9RVpjTI+2D2ppp5FIc881aGiP8OlJ9KccU2mMUdKUe1NH1pwPXnigB46U9Txjmos0objmgCYGgH19e1RBuKXdSsSyQntzSbu1Rk0m7qKpIViXd6fSl3VED+dKDWqJsSZFFRg+9OzWiJFpaZmlHuatCF7dKWkzSfjVAL25pab9aUcUDTF/lTl9KaPpTh096EFxw6HNO7U3infQVaC4D3oHeik96pCD8aPxopaokTmjtR2IppxmgBDSZoNNqShPpR2pKKQIOaKSikUeaY9akRTSKvY1YjT9a2Z2IkhHqK0bNcuM9qqRJWlYp8w9amwG3YpkDGK6GxXp9KxrFema37JelAG1aL8taMK1Us0+XFaUKcUDuSxLVmJaYi4HPWrES89MUBcsRLVmNajhXirKL3HSqRNyaFatoPaoIh61ajFUhEsQqwgqGMVZQUyRVFTItMUVKlNASIvFSKtInNSD2poQBcinAdKUAU5RxVCBR2p4pAKcBQAAU4DigDilFNEhxSUvaimA2mHuakNRH0qkIYe9Rn9alPQ1E1NCI26GoW71M1QNQBEx44qJvrUzH0qI/TrQBEaifpipj3qFqAKziq7jrVqTvVd+9SUiu/eoTnBqd6gNIaIm6daifuCaleoXqSkQtUL1M/eoH70FIibGTUD9/WpmqF8VDLRC3eoj3zUrVE1ZtFoZnimk0hpCaixaYuaUHH0ptFTYtMeDinqfpUQz3py5FRYpMmBxTutMU5FOzx1pWKuOyKbupCeKYW4pWAfu96QtUW6mlqAJC1RFqQt1zTC3vSGgZqjLcUMRUZI7UrAIze9RMacxqKRqAGsTzmoWPBzSs4qJmp2AilbjrVSVqnlbg81TkbrRYRDIe1QMafI1VnbrTsMjkbg1UlbrzU8h9TVWQ9aEhFaU1Wc9amkPWoHNUkS2ROagkPYVKxqu5GetUkQMJ6nim0UdadgQUo4pDTwPWgaExTgO1FOHSnYpAOBThQPzpR9KRQo6UoFAFLx+lA0AFKKXFKBUjEA44p1ApfWlcaACnAelJ609f50gsOUU8dOBQOnH6Uo96VykhV78VItMWpV9hSKQ5fyqQZpiinrUMCZKlWoU+lTJUMtEy+1Sr71EnSpV/WoLRItSLUSmnrjHWpGiUcUo6UwdOtOHSkUL34pe3FJ3o6UgAUopBS0DTA02ndaT60CuJzTCT2HNOJ681HkUCEJ56UxjxTj/AFqM8ZpoTGtUTHk09jxxURz3q0Qxh9jUZOBzTz+gqN+9WiWMP9aaTnNKfemGrRkxaYx/GlNNOO1aIzY05qNulSGmHkcVaM2RHvTPp1qRh1xTPrVozDtSp6D1po5HBpye/StEQTxHL4NTSZ3jAOKjgHc9B+tWFxIOCc5o6gkaenHa6Gt5h+9QjrkfjWFpykug710Crnb6jFRI2i9Bl/N5cEhP0FYRfNs24jkitHVn+RgSMVjyt8u3HHbmsrmiJJ/mgQ8YJxUGMOQD7VYddsSqevUd6gLFSd3X2pgivOwJJ/u1Vh6O3TmrdyAEAGMmoVQKoUdO/vRsBHHy4A7dTVryjzwSO1JbIPMII+prWiiUp5mCVHH1ouNIpW1uT1H/ANep1t94OeOMCrdtEXJO046YpzLtdgRxj9aTZRzt9bNg9PvYH51ReEo5XHSte7BN0i549M1BLFuumXu2BzQpCsa/hu0LbScc/wCNdjDagMuBWXoluEjiAA6ZrpLZOhA78VlJlxQiWo2gAHA61KbQNt25BGKvRx8c/wAqmWLKYHY1FykVoICM7s59a0YVZoip6jp70iIAuCPxqeJSpOM0ikiaEllTPUj071egHIAxwaq2wDKTgir0CDHB796BovwKQvAzjnNW4I9rMe5xUdovHIq9GmT0/wAKaJkKseVz6DNZmoWomCDHJOD9K2gp2EDHSopIRiEnqDj86tIi9gtYVjt0RRgCrEi8c809VGwD8acR8uDzVpIkqOpwcc1Cy4HHX0q6y46dKhdRzSsNMqupHBHNRtHtBIxzVp1GOMVC2eciixSZVcELTCowcYqdhxz0qIjrnGKlodyuFIByeaAR1BHpTnzk4qEMVByBUjsSKeM5pd2B+NV93A570jyDGT0oWgWLYYdTTlb0qiJRsPJ9BVHUNTjtIS8jgAe/WlcOW5uG6RPvEZ+tZd/4ht7SM75V4P8AeFcXf6zd3wY22UiHG7PWsW5aC2QT3zl0yNxIziqSbHZI7GXx0gLiKNn9CD1qsPGdzJnFvIFz155rmR4h0y2B/dR7BjoOtSr420+M48ldmPTH+TRyyFzR6mxceNL5CdsJK+6kVFD48nOBLA/XHANUovHWmOBlVUf7Qp8euaZdqfJaPcD0oUGxc67Gn/wm9rJxKShHBzxitPTtetJEkaKZCWIxz/OuKure0uFctCnzHqMd6yJtEeNjJYzugH8OTTtZDTTPXBeM8bsoDccc9KjS6VgA2VP5Zryy2v8AW7EYUNKo9K0bTxntZY76IoRwTSVxqKPQGlB+ZJDkcY61TnmY4BIGDWXY6xaXS5ikB/TFWBdKWJOMdqTC1jB8UW+8JMhG6Mj8ea3Wk/cypJ1eIEflVe9WK6DJxkCorxjiJlb5dgU/TpT6AlcbpV4jWciycYBT8eRWV4TiC2G8ZyZGQn6NimzQtDFcsrHYpDEY7Yq/4VwdLG0cebu49+SaE/dBrU07dSrE85zg1Mw+z3KzAHY3DfT1pypicYyVY9atPGGiKjsO/OKEIlCqACpG1hnipBwBjGO9UbaQwjZJzGe+fu//AFquLu3gj7ooWgD5UDxKRwRWTf2cdxG8cgHPT3rZjySQwGOx96hmiOGBAOOlMDzHXLZrd2jlBEq/ck/vD0+tXNBvftKeVMxDqOPceldBr2m+fGVlAJIwOO9cERLpt6VbKkHg+vNPfQzfuu56DZAND5LE5X7p6Z+lOcZAkjysqHJ+orK026+2ohViHUHpWtAwBy2cng/41N+hdupq2U4uIwQQsy9f8+lXUO4ZK4YdRWDHmG5yhwprYtZUmHPDrRcOpMRySuAaXqNxIHFSIMnnr396VlBGQBSAryKOucNUTglTknPT2q0AGJDAe1MMeNwXp1otYZRlUbDjrj9apGI7ymBjGenetORVIK96pkBXIY9uD6+1SNMzZ4xnaRmsi+tRIrKwB9D/AI10E0eRnI68VSuIwRjuDQkBycsTCNo3ydvCv6fWqMsO5CRjPf6101xAN78bkIwfasa4tzbykHJjb36e/wBKtMVjnbqEgk45HH1rJurdWJIOD/I11N3EVyMAjHFZFxF94EDkYrWLMpIwyuCY5RkHo3pVaWHD7QeQfzq/Iv3kYH0FVmAYFZM7h91v6Vsmc7RAuGjMTcEdKSIHJU9hT2QjlhkZxmkOMcHnv/jVEFa5UhMY4xVIndFt9DxWmyYHzdCcVlzRmGUgE7W/SmiX3JdNY7nU1PLkSc+nFVLU7JPars/+tAxwVFO+pNroY3XNK2TGMdqPr0xigH92cVSZIwHil9ajB4x70/tTAcPSnD60wd6cO/NICWI81OW+U1Wj61Kx4+tAFeT7xxTac3Umk/lTGJSfzpexpKaAO9KvOabTkPNMCdBgdaGOKcANtRt60CInJ56VEfQA81I/f3qNqAG96TNL24pp96kaAnvSZ/KkPt1ooAX6UDHQ9aQU5f1pAL2paQdOlLQAU09+adSHHegBnfk0nrS0g6/SgBaB0pPoaKVgHqamjbtVcE1IlRYC2p496cKjQ8c1IPaosTYeO+DS9uegpFpe3FSBJEoOav26c4qhbferXtk+lFyWXLSPkcVtWkfFZ1oo+tbdovHakQ2WYI8DgVrWUfNVLdK1rJPaqvoZSZdhTA6cYq9br7VDEvFXIlHXvQjO5KBxilxxS9uaPbHFMm5GcYqJqlbvzUMhoKRVmOM1Tc9cVZnPBxVGU9allJEUhHNVyetSOeelRE8daRqtBueaepqLPXmlU1SNETg1IpqANUimmiyzG3vVhGqkhqwhqkBZDU4H3qFTTwaAJA1Ln86jFOB9aAHZ4ppPpSfjSHpU2EI3eojUlMIrNoCM0w08jmmnvWTQrEZqM1IaYayaCwykp2KSoYCUYpfwoFQKwmKYRnNPpCOOaAsQGmHvipW6HFRHv60CsITxTCetITTGbjHOKVwsKW4pm70pCe1NzxgmouTYdnjqaM88UzdSFvSoYrDyajJpC9MLVLJBunFQmpCfWozSATvR2NIOKOtA0xT6U0inD3oxTQyFhweOaicVYIqJulaIaZAR19KjI681Mc81EferRSIz3ptPaozjnmqGHPPpRn3phakDe9AEgalB496hB656UoJ79KAJ91G7jioQ3BpQfemSSE+9Ju96Zn1oByapICQH06UoJwfWmA04GrRI/PagH0pnNKDWiFYkz24pRUYPrThVpk2H0Ug+tL3poBfxo70etKKYgB4pwpo9KUUIB46c9aUe/wCNIPrSjoatAL2o7cUDpR9KpCD60lL2oqhCHvTT06ilNMPSkA0mmnvSmmZpFC5ozmmk0meKQ0h340U3NFIdjg0j71OiU5FqeNea2OwdDH3rRs0w2cVBClX7ZMGlcDZsV4resVHFYdkOntW/Y9vekBv2Y+UVpQrVCzxtrRiH5UATooqxEuKjTpwKnjA/GgCzCOM1aQcVXhHFWkqkSyWMVZjqugGatRj1qkInjFWEFQxirC9PeqQh6ipFqNRUqdaAJUqRaYg4qRRVJCHAU5cUg4pwpiHLTh+lIvSnDH5UwD6UuKB0ooQgxSU7iimIYelRtUx6VE1UhERFRt3qYioW+tMRE1QsKnPeoWoAhNRt0qVsUwjigCFumKiYdamb07VG3SgCtIOtVnq1J0NVnqSkQPUBqd8c1E31pMCB+h6VA1WH6Gq7UrFJkLd6rvjvVhupqB6RSIG6kVG9Stnmom6VLLRA/Q1E1TN0NQv3rNlohNMOO1PamHrmosUmLSimfWlBpWKTHg0D3pufWlBqbFpkimn5FQg8UFuuKkpMeT600n9KaW96YW9TUjuOJphNIWqMtxSHccWphbjrTS3vUZagLjiaYWphYc+1Rs/FAXHM1QO3vQz9eageSiwCs3NRM47U1n5NRM/Bp2ASRuCKpyNUsr8dapyN1yaaQrjXb0qs7flTpG61WdhTsFxHYc1WkbrSyN71Wd+tFguMkbrzVd29TTpGqu7dapIga7elQn605jUdOxIUCjFKKBoB/OnjpTR0pwosUhQB9acB6ZpBTh060DQo6U4U0dc+tPHWgpAPanCkFOFSykAHFKB+dApRikAdqUe9A96B0pDQDpT1po709RikND16U4Ug6Y4pRjt0pDQ4VIvuajHt3qRfekUSLUi/Wo1qRetSwJFqZahWplxjvWbKRKlTL04qFKmX9ag0Q8cU4dMimj3FOHA6VJSHr0pwpi0/6VJVhcjFKMU0fhQPTNAhf6Uo6Gk4pPXFADs/Sm0Z5pO9ACE+pqM5pxPXimEnmgQh6kGmMfrTj3xTDnGM1SERtUbfrUjVGRzmqRNyNsYqNuhqU1G2KtEMjNMannH4Uw/0q0ZtCe1MNOPtSdzyK0RlIafSmnGOOlKetM7YNaRM5DGHXAph6Yp7d+ajOPyq0ZMUHjilUk9cU0cmnJjOKtC3LVueGFSQ48zjr0qCHgkD6VZhIEwAHTqaW4I17AiKZC33zW7C37piSeTXNRE+ehBycjFdCuVhznrUS0NYozdQbKnPOelZmQzqOvIq9ftlDzWfFlpBg9Oayua2LMy5mVefu0xgWAyOQcUK/wDpoyT1xVox7I2J6nmncdjMCmSU4GT0qxFaM4zjmrWn2wYk4ySa6CCzQRfcGcUuYaRgwWJ3/MABWmlq/klQfkGMcVqx2oYhcDirZtdiqycDuPWp5rlWMqygxDxnr+gqtcwfvGB7j+tb0aqsJYDnP5c1nzxl5nI6dKBpHI3abLx2wflxin2dsZrxWOf71X9RgC3jgjgYJq7oMHmMZT0NF7CUTYsYggUKOcVsW6lSG61VijAIx+FaVsBjBFZtlJFyIYXPHNSx45ApsaKoyMcVIOpCjmp6FJEqAnjtU8Ywcc4qCPdkcdferaDgUDJ4k7DjtV2FOcE8DAqtbjcvJ5Bq9bKGOCaARqWiYwTn24q9EgLdcVXts7RzyKvoAeeaqKM7gB2A68c0NHtVc9jUyoAOc08rxyKtIhsiAwM03HvU4UYPtTCMdBVIVyEg81C+OfTuKtMvYVCyYGBTGiqVBGQSKrv7Z4q0/Q1ARznINS2y0iueQeOagY5HIGelWHPzHrVaXgHHQ9akEV5mx0Oahc7h1FOkOFP1qvuJBz2qdzRDgc8A8j2pm4jO4jApA3J9qrzvtXLdP507aARXt6ltE8jMNoFcLqGofa2a4vG2wD7i1f8AEV/GpxI4Cjnb6153rOpNPL8p6dF9PeiMbibsa2p67HBEzKdufuiuTutZmvWZZmO09F9qgnt5pIZLifPlqePeq2i2S3t2fOlCKBnJPpXQoGEpkUt3yULEjt7UkF2EckqHGMAGtbWrPTIVBgJOAB1zk+tL4ah0qTVrYXoxbN985xirUGzL2iMPzn3BTgZ45GKcJisTskxRl4IyeTmvQPE2meHBayGKVI3/AOWMg53+2PrXm84Xy/unf396tUrDVS6Ldnq17BJ+7uCQOfrW3Y+KbtWJaTfjseM1zGmQebeRox+UnBFdjeeEG8tZbI8EDg0nS00Gp23Nax8Sx3KgSyFJP7vbPpVsyxXkI3IhIPbvXBXmmXdpIUljZT61Xi1K5t32eY646YzUOjI0jVR2clrLFKXsC6MOqmrMXiC7gULdRtx61zFv4kkQhZC2fX1rWg1u2uk8uXHA6msfZ9zRTR0Vn4kglfEg2Hp61ri/SZAFdcdua4h7aKZRsxyfvDtSRie0AyS6dMipcbGikjt72SN7aZFIy4wSD2o8OzCKyESEHDY+uK5yx1Dh1JzkdGqza3Jjjk2cESVN9At1O934U9O1W4nGOccjmuctdQM0YBzu47da1rSdW5LcDihaisW5I87sY2nrTbCRmiMbE70PH0pPM3/cOAOPpSpGEnVlbrwaYkXN0hXCj6/Sp4v3i7cncPxpExn5Rx3p+zEgK5oQMhuoPNRkbGa4vxBo32iNlZQJB0OK7x+QcKciqV3AJDyP060hNJqx5ZpU72N15UwK4OM12sL7lVywMZxzjpnvVXXNCDZkKgKR94cYPrVHSLhrWT7JdHKngN7UO7JiuXQ6LGw7JCD/AHW9/Q1aEe7BQ7XHvUUSLJEYnIxjKn+X41Lbhvuv95TgN60ikWILks2yXKuP1q8pU9setUZI1lTnhx0PvTEkdRsbIbPX1FAGk+0L79aYMZOajEmMBvSnOcnI6U0xWIptpB3dDVExtt+VvpkVdlwwxnioTgcA/NnBqWxrQz3YsCWG0jioLj7nB69q0JFwzAgYPBzWfKnlyEAnBPApJjK00IC8HnA7VkX0JwVYfIeh9635UGOT830qhdR70YZPt7UxHKyxj7jdV6H1FZl7GSDgHPWt++hLcjIcdf8AGse5BbdnBxweKuLIkc3dLgtnFZ7kZw1at+mCetZkwxwRXRF6HPJCRnHysRt7VGSAxVh06Uxvl6UspDqHz061qncyasRtlgV3cZqvdxbo+QdwHFTN0I7/AM6FbepVuo6ULQky485J9KvzYZI2HoKrhcO4xViEbrcg84psm1kJgbRzSKPlb64pFyV56g0qD5W9c00SQjofY08dM00d6cv3fpTABTx0pop1AD4utSt0/Coo+vSpyMjNAFU5zSfTrT3GKb60xjeOcmkPt0p306U00ANNPj+9+NNNEfX6U0Ba/hqN/en5OMdqikP507kjDUZpx78004x0pDExximHp+NOOKafrSBDT7UlKetJ9KQwHWnD602lGKAHj2pR0NIOOlAoAX+VNI4p1IT2oAZ6mkpxppoAOaKKMUWuFxR3p6daYOKetSwRPHU46c/Sq8Z4wTzVhPc1mwHr75qQLnIpo9ali5PFSSS2cXze1a8CYNU7JPmzWrCvP61DZEmW7Ra2rReKy7VfXvWxajGBSTMpM0rda2LNeKy7YenSti1HFUmZNl2IflVqPFV0qdTimiLkueKQ+1NDUFuKtAI2OaryEYqRm9elVZnxmgpEE561Rlapp5OvPIqk79eagtEbtURPakd+TzTC/HFBohSf50qmoi3vTlNNGiJwaepqEGnrVIpFhDVhDVVOtTpTQydTUimoRT1NFwJQadmowacKAHdsUlKKMUhCGmkcU4UEcVLQrkRFRlanI4phFYyQXICKYRwalIpuO1ZSGQ4pKkxTcVmIZRT6TBqQGfgKQjvT8daaaVgIX7kVC3Wpn71A3elYCNsdqjNPbuKib0zU2ENNNz1zQKTsfWpsSwz6mmMT2NLzTWx0qbCuNJpufWg/pSGpsQKTTTmikosAv60nc80ZNApAOAoOaB0o7delNILjTUT1IevNRt3q0NMhbpUbd6lbpjtUTd/XpVItETVC54qV6gY81aRQ3NN/GkJ9O1Jz37elUkA7NLn1FMzRk07CHg9elAPFMBzSg800hEgPvTh1z1qMe9OWqSAkGelKPfpTB09KcP5VSQhwxjvinDpTRz0pwqkIB1pwpKcBxTTJsKP0pwzg01aeKpCsHPSlpB0oHTFUAo6Uo96QelKKaEOH4U4fWmD8qeMVSAPcfjSj68Ug70vWqQrB6g9aO1HFJ70xDT0qNvanscDiomPNFxpXEJwKaTQTTM0rjSFzxSZ4pM00nipuWkPzRUe6ikOxzSpU8Se1Cj2qeJa2OomhT2q5AuDmoYl4q3EKQGlZVu2XQVhWmK27M8igDo7I/LitOGsqy6VqwUkBbTpxU8VQp0qzF69qYFmKrSDiq8Qq0nSqRJJGKsxVXSrEfXiqQizHj0qdagjqylUhD1qROtRrUiU0BOnSpBTEp600IcKcOKaKcKoQ4e1PHSmLTxQAUopKUUIQtJ7UtFMQ32qNu9SU01SJIiODUD1ZYcVWemBGe9RGpGqM9OKoCNvpUZFSmmEcUgIW71Ew4qY9xTGpAVZehqq/X6VclHBqq1SxorP3qFqsOKrsKQyF6gerDjioGoGmQtVd+9WXqs+MmpLTIW6dahbpUze1QtUspET1C/epm/WoH71my0yF+uSajJ/KpG78A1AfrUlJi8UA4703P5UZpFIfnApc1GDxRkVLGmSZpN3FRlvekLUrFJjy/FML8dqYT1wajJ96mxVyQtTGbioy386YzVNgHswqMtTC3WmFqAHFveo2YetNLe9Rs1NIAdveoXbg80rNUDt1p2C4jNwRUTNQzVA7UBcSRuOKqu3XmnyN1qu7flVJC5iORs5xVZz71JI3HXiq7sKdhcxFI1VnapZGqq54osO4x261Wdqkc1CTzQkIaTRRSD0piHDmgcmgUDimNDh0pRSD604YpFIcKcv0pg/zzTlpFIeopwwKF6e9KM/WgaAdKUe9AHalqWMUYpR6E80lOHpSGA7+1GKUd6P5UhoUdeaevqaYKkWgaFHFOpKUHsOlSNCjj8aetMHTApy0holWpV6VCtSr0qWMlTpipl6VAvHNSr+tZspE6fWpl6VWQ81OhqGWiUU4YpoOaB3NTYpMeDTwajGMdKd+NIq4/wBaSm5opAOz1yaQHvmm55oyeaAHE9cU3dxzTc+tHY4NAATgZH0pp7ilJphP5U1YQp6cYph9qd+dNNNEsjbp71G3SpiKiYfSqTJuRkdaiNSsPWomq0yJEZpDSnNNPTirWhEhppjU+mHvxWiZkxCeoHpTCRSnFMbpWiM5CH2qPPUUp9qTvzVoykIO9OTrnNNPQkGnIDimJdiaPFTW7j5vpz71V3YBwOlSxHavHemgNeyG7aVPQjP+FdA7nyQMAY61haKu49eM1rTn9030wKzkzemtDKuDnJzxUVqmSTnnOM1JIvGKktlAR2PQCoNHsQRqfNBX72cVrXERCBMckjNUbOPcqsOpfA/OuivbYRrBg5ZhzSHFaEGlwKoYgHANaiyYXaD0qosiQrg9O/vSiQGT2PNRuXY0LZiCDjk1djY4II7VmRzBVUnAx1ok1SKLIBBYUILGksfynpgmq8wCvwV681m/22CpMak/0pItVSY4KjdilcaRR8QxldzjOSAOO+a1dAhC2UXP8Izx3qnrbCW3UDrkZ/Ot3TIttioUDCilLYEty0iDIz16Dir9umBzUMKDjJBzVpV447VBSLCxg8jPFShAD70RDIHXJqXHr16UDEUnoBzViPgc9KgGAf5VNHnGffFAbFyFvmGOn5Vo2mQ2CRj1rMQ7lGM/hWpp+S2CO1JgtjatU461oxJxyKpWinqBx2rThXuTxWkVcyloKq8c0pU447VMBigrkVqkZcxXxyc9aCBUpXv3pCtILkJT0HSoHXrire0YOe9RMnBxQUmUXXmqjKQ554rQlUHOKpygZP5VLRSKsmOgA6VVdOD83SrUnU81Ey5oSKuUJFBBznFVOATir8i9QQPaqkifLx6+lTYpOxWIIDEAkdTWZqcwhtnmk6AZFbPl7l2tnGPWuC+JOrpZ2ohQkF+1AJ3OH8QaoZJJGJyx4Az0rLs7fgM/zSuR+tUpX8yQFjkk5Ird8OxCe8UNyVI/CrS0JkzU8UacIfD6AKAu3nFefLGzAhSQor3XWLBb3QZowoJCDFeNPE0UksZUAg10KVkcu7MG5Yh9rk4HSi2I8wAZIqxeQFmyOtWNPsAp3O3Xt/WmpENM1dF0yTVpWSJWIUdTwKz9Y0ubT71orqMqegNd94FSG1WVWkxuweOKq+O/KmuWZ8MqjIPrnNNSGrnAaXbPLqcSKpzuGPzr3bS7DGmxqycgCvOPAWkm61ITkHaK9kSLy4QAO1bJkyaOb1DTPNwDGmM9TXJa74fgZG+QBh3xivRrphjJAzXO6uVYEEUSkOFzyjUtNMSMSudvfFYkg8s45Fd1rZTY6qwLdMCubntNy8Jz61k7M6UtDPhv7m2A2u239K0rLW3DAS5IqlLbuCUccVVELIxVwfas2kwTaOxgv7e5HLBW9atxTSICRz7jnNcQm9TgEg9j61o299cREB8lRWbgaKod1YXcgGBjnp7V0VhcBVAPQmvPtP1HzDxnj9K6W0v4pEXd8rCspRaNYy0O3guQq7VwcirCSKV5bByDXMW9+sa8HcelaMFxvbLHGMYpXA6W3fkg/d/nV1G6AZJ7ViW07OAwIx3rWs5A2DkA+/amnoS0WwmUORg4yKieL5QQCefrVtAGzuPNBiABC59cUWEZtxGpHzLlCMGuW1rTFQ5C/IT8ren/ANau2khLKenvWfPbjBQqWQikxpHJadeeW32e5JDDoT3rdVt6gZ7dj+tZ99pazHy8bJF+4e5qrbXUlpJ5N0CGHAPrRcVjeh3qSGORRuYsVbt0qvBOsgJDAj60s7cAr2NIFqWvMJGCMmlWQDCnNQLKPlJYZ706SRQcbsmgfkTYBc4PBqPO0t3PSmmQFcKDkd6SJt2SRzSATZvY7s5qvOgaM4HIHFWlB3NnFRtz/CKLCKa/NHgn5u9V5kypUCrciNuII/GoTjoOf8aED2MC/h+bIGKwr2Eo24HOf84rqNRUqM5HFYWpRnyzgj1prQm2hyWpIvl7wec4NYtz93nv0rob6NTGy55rBlA2sj//AKq6IbGE0UCSq88ioy23g52H+dSOMAg5PpUTHdEa2SMGh3HKseRwDSJ94Bj8w6e9RxtlcZ6dKeG3LyDlT1/rTIY2VAz5OAw4/wDr0kXytz9KlYGRcgcgfrUcvLgr04pk3HOgHIPXk00DhiOlSH5ojxkjmmD7jCmkIrngmnL93FI1KvSmAoxjk0o+tNFOFAEkVWB0OagixmploGhkwGTioPY9KnlqE980ANpp6U/1ph6H1pgNOcGlj60hpyfSgCzxioHx371Jn5e1QO1ArCHHrzTPxpfwpDQA09+aaTQT27U3I/CkMOlIKPeigBRSj3popy0AOHt0pc00U4Y70AHWj60dqPp0oAbSU6k7UAN+tGKU4pBj/IoJFpRTaUUhonSp0Peq8fT3qZM1kwLKtkVZt1zVNMA1oWg4qGxM0LRa1IE46VQthzxWrbgYrJuxm2XLZfzrWtlwKzrYc1rQDA7VKkZSL1sOla1twKyrfrWrBwtWmZMvIRUqmqyN71MGHrVpkj91NZ+DzTGcd6geQYPPNUmBK8nBqlNJweaWWTg4NU5peDzTuUkRTPycGqcj8USycnk1XZ89Kk0QM1ML9aYW7UmeOaDREgbNSJUCe9ToKaRaJkqZBUUYqZapIpEqCpkFRJU6dKaGOFOFJThQA5aeKYvpUi0IBwoHTFApaYmIKKWioZNyM9KaRUhphrGQIiIpuKkIptYsoixTdtSnpSACosBHto2+xqTFO20iSAj0qNhwatFeKhkHHSpYym/0NQt19qnkGM1Wb0pWERN09qgY9cVM9QN1NFhXE9aQmj6UnNKxNwPSmN05p3b3pD0OKXKTcjPoaTt3p5FM7cUuUVxvsaKXtSVHKK4Ac0opBTuaLBcPWkJ9KWmmiwDTUbHtTjTG7/ShIaI2PXmoXPXGambpULVaRaIXzz1qFu/tUzfpUTDr71okNMh+lN9RzTz9fakP6VaQXG5/KjoODRj9KKpILhnilX60mPelFNIQ9cVIvpmo1qRfc1SQDhThTR0pwp2EKP1pw/SkH6mnAUgFA460oFIBxTh9KaEKPU04dKaKUdKpCFHSlpuetKDTQg7UopoNL2OKaEPFKD2FMzxQDVICQHij1waZn0NLVoB31pM0lFArCMetQsetPY8VExpXGkMJpCaDTM0i0hc9aYTQTxTCam5SQ/NFR5opFGYgqxEtNRasRLXQbk8S8VZjFRRLVmNaQFu1HrWzZ9RWPbj1rXs+oqQOjsegrVhrKselasNAFyPpirMXoarRjirMWKpAW4atJ0qrF1q0lUiWiVKnjqBanjqkIsx1ZSq8dWE+tNCJF/KpEpgp6VSAsJUgqJKkFUhDhThTRSj2pgOX3p4pg4608UCFpRSClFNIQtFJmjNNE3CmGnU0mmhDD0NV5OtWGqF6YEBqM1KRTDVAQkUwipiKjIpARH3pjVI1MNICrN0NVX74q5KODVRu9SNED9Dmq796tP0qq/fNIaIHqFu9WGFQNQNED9KrSe1Wn6VVfqcUmUiE96ifpUrd6iaoZaIGqB6sN0qu/FZtFIhb2qBqmY9RUR61NhpjDSZob6U3NBSYuaM9jTc0ZFKxSY7PGM00mmbvekLdc0rDuBNMJ9TSk+9Rk+9TYpCk8dajJPrQxOKjY+9IdxCTTCaVjUTN70WC4GmMaRmqJm96aQhWP41A5680rN1qJmp2Ajc1C596ezDmoHbrRYVxjnrzVaRh61JI3BqrI3WqSJbI3brzVd296e7cVWkagVxjv1qB2pznrULUWKuRuaiPWntUdFguFFFFFgFFKKRacKCkLjinCmgetOFBSFGDTx0po/KnL0pFIetKPakHSlFIaHClpozThUsYo6Uo6UgpRSGh/tQOntRxRSGhRTx09qYKeKAHClpBS0ikKP1pRxSDpSipZSHrUydKgSpkNJgSrUi461EPapFPFZtFImWpk6VChqRT6VmykTLTwfeo1PBozSKRIDRx703NKD71Ix+fWjOO1MHI/Gj1oGP47UnOODTc0cUALn1pM88UUg70BcX8eKTrxSc85pM80CHd6TtSA9eaPXmmhCGoWqVqiamkSRNUbe1SHvUbVcUQ2M9aZjrTzTfWtEZsjNRt3HNSHqaYw561aM2yNjxjFMY+tOamMa0REhhpM+tH54pexrRGTAfpT+MYpo6c0VRA1uvFSK3AFRkdaQdeopoLnSaAOGOeK0p8+W3PQVm+H+Qw7YFaEwyWA6ZrGZ0U9ijKAvXPSpCu22Pp0ps3zbQBzmnXBzGqDtUI0JdFQyyhOwYYrqdQiIVR/drB8Ir519JxwMe1dDqT9UAwwUEUFQ2MWWRSrK3Dn8KqC+CjGSWXj1qDWpM/OMhhxmsL+0GibzAucHnnrUpF3sjolu5bjKl9gHvUkf2dR+8bOTzmuSvNWZ/nQhR0rMe/nOf3hwTVqCIU7nou+z3kRsATjv0qcPaEgADI6nP615j9pcoSJmye3rU8V4IsLLcS8jnaehpOBXOej3JUwkqQ4BB6+lbumykWyY6EYNeMJrN0uEWVmQHHJ6it/T/FU0KAOvC+lQ4MakmexwrtQMvzADB5q1C24cAda4XQPGNrclVLlWPY+td1ZyLKoZcEEAis7M0VuheiHy5qbbleeoqONGC7sCpIicHPfgcUhCcBuR9KVOpAyKDnoeopA2H4NAFiFh0yetb2loThj0Nc/EA3fk10+jx5iUknGBQO1kbNqvyg8ZHStGEcVUgXgelXoxxWsEc9Rjx6U4D1oApe9bWMLkZFIRUuKYamwJkRXio2XjNTN7VHJ057UWLTKco64qlIvBzV6TnOKozgjqeKlo0jsVWxjA555qB+vTgVY2gD8aYy9fUUkrlXK7rle2KqMmHI4xir7L1x1xULIck8elDQFG52xW7uxGAP0r51+IWrtqGuyBGPlocD06mvdvHF39i0O4dSMhDXhWj+GbvWrlpWyELZzipTuVFaGBC5zliemBXQ6BM1rdo7Kdh7+ldnYeAYUUGUFsY7VuW3hSCBQfLJHb5armBxuTWN9E0IAYEMAMZrgPGWj/Z7l7mAfI/zHHPNd/8A8I86qWRG8vP0/wAiq1zo+Mh1bb0Ctzu+ma0jL3dUZezuzxSSRdxyvTpUySjA9BXqD+GNPnUyNbqpB6Y64obw3p0cBdrZAFI/hz+FJTRHspHB6VfNFOwjzhh1p95b32rSKoR9uclsV6RY6RaA7ltokRRknYBx7VaFiJWHlBEjI44FXzpDVJ9TH8MR22iWUaTFvMPJwOa1ZvEG9ikETkDp8vWrS6SvBMiuvoRjFSRaZHHHkvyTt4HQetUqug/ZROb1LUtQkUtHCyqOpK1isLi6kAnLD17YrvZdDQw4W5kZT29aibRLYDALbu/Heocy1Tsjz2WxCkq0Az/exVWTT5DyVVR2HrXpo0KBQcZyRzUB8PxvgspwO/rS5iklbU8xfS2bBYD2qK609HAEiDpzxjNeoy+HkCEoOPeqcmhiTKSKuFHBxS5ikkzzFNLCuA5LRnocU7+zlRucso6cfpXobeHOcKv04qF/D0qnGAw/lRzsahE45bG1YZhZkc9V960bOCBVZbhX344IPWtmXw/uXldrjocYpkGnGCULOC6t8vT36iociuVENnBtIJfcvbtW1ZRy5yvzD3FSQeH+SysWUAY7VpW2i3MXMbHHbvms7gkSWZlC/MOh+lbNgytywwaz47S5XB2Mx+lXIDOuAYhx+HNJBZWN2DceDjFTiMk8NVSwd8bXU5rSijLA+v8AntVLUgYYQFIAGe/vVWWAHOQeOnFaaI3IIx70x4uDjqO9AJnO3NqHyG4xWXe2Szx4ZfmXoa6e4i2n1z14qjLEvKke/Skh3OPks5IjutyVcdV9fcUsN8clJVwwreuYQW6EHtWdPZxznlSrjocdaLh5j4pN6ZGKmQBuTjNZjW89v93JAPrU1vch/lc4YUgt1RoZwOMdfShWwx+vNRq30wKVQRuyetFxIfnng85qNuGOc+n41J0GSKYSG47igZC545+lVJcYJI9h71bb7pDc4qvOMjHahIVzNvBmFs1g3S5V1JIYD866C5HXHX61h3vMpyOMflVRJZzl4gwcnPFc3cR7SSMYzXU3g2vnPr+Nc7frtkJHQ10Q2MZmPIOT1quOCw9atyr1Gaqt161qjnZAMh8CnbyrHGeeTTX4brRyrZ/nVGbLEbBCGH3ScGmn7xI6HmmxHcjA9AKRCXXnqDQSTIeG9uaaOhH1FKmMsue1NU/MVz9KaAhcc4pFp0n3jTFpgKKcKbSjmmCJU61OCaroR2qUHikMVuQaiNSHpTDQAw0w080xqYDetOX6frTacKAFZj0qM+tOPpTPakAetMNOPQ000AMP1ptONN9aAE7UdqQ0CgB3NKM4ptOH50AOHsaXNIOlAxQAv0NKMUgpaAE9qQ0tJQAlGR0opM0CCgfSgUvtUsCSP2NTp/OqyHFTRtWbQFqMc8Vp2yYHvVC1GW6VqxLxWchXLlt1Fatv0rLtxzWnDnFYTZlI07XGa1rfoOKxrY81rQMMVCZkzRgIHetGBuKyYmq3FJgVakkRY01b8qf5nvVFZeMZoM1WpCsTyTdeartL71DLL71VebrzVphYsSzcHk1TkmzmopJT61Xd+vNUUkK79ec1GWzmoy3vSbqC0h2aUEVHnrTlNNGiROvT3qaMVCnSpkpotIsJ0qRaiWpUFUUTJVhOlQR1YTpQgHAcUooFKBQA5RxTxTU9aeOlMQo6UtIKWlcTCkNHeipZAnFNPencU01jIpMYaaaeaaayaGMopaSpsAq4p1NFPFTYBpqCToanNQydDU2EUpe/NVmHXmrMlV2HU0gK8nQ1A3XrU8neoD7U0IZ9aKX1pB70WIuGKT1FOpOlKxNxhFJjrT8fSkIp2JI8YpuOKkIpKmwrjRS44oxRipsCYdqjNSGmNU2KTI+1MIqQ+9NpDRGwqJlqYgfjTWHaqRRVZeuKhce1WmWoXGK1iFysR60mOKlK03b+VaJBcixRipMcUm30q0hDAPSlx/OnhTjtShetVYVxiipVXmhU4qZUp2HcYBTgPUU8LijFFgTGgetO70Yo6dDUjF4oHtSd6QcUIB9GaQfnSZGKpAO/GkzzRxj3pM0xWHA8UZ4yKaDSg00wsOzRmmg0ZqkFhwNLuqPJoz71SYrEm6kzxUYNLup3CwE0xjSk1Ex9am40hCaaTQTTCam5aQE0wn3oJ70wtzSuUkP3UVFmikVYFUVYiWowtTRiui5tYsxr7VYRahiHFW4xQKxNAK07TqKpQLWhbrUhY3bFvlFasDVjWZrWgPFAjRiPFWo6qQ9Ktx00Bch6VZTpxVWLpVtBxVoB6/WrMdV0qxEKpElmOp0qCMcVYSmhEi1ItRrUqimhEqdKkXGOKjQcVItWhDhThSClFMQ8UD60gpRQgHUZpuaTNUiSTNJmmZpM0xDyaYTSbqbmmiRSajalJppNADDTDTjTDQA00w96efao26UDRG1QnpUzVC3egCGTpVV+Ksv0NVnpDRXfOKgarD45qBqkaIGFQOKsNUEnQ0DRWeqzirL96rPSZSIW71A31qZ+9QuKlloib61Xk9asNVeSosO5XbvUJqZ6hbPNTYYw+9MJpW6UzNKxSFzxSE8U09KM8UrFAaaTQTUbHsKLAmKWphamMxppapKTFLUxmpCfeoyxxSsVcGbrzUTN6UjN1xUbNxQkFxWb3qJnFIze9QO1NCuOZ+DzULv6GkZqgZuvPFMVxWeoXb3oZqhdqBXEkbrzVZzT3JqFz1qkTcjc8GqrnrUzkc1Wc8nFMVyNqiY08nioXPWpGmMY9aZmlJptA0wp1MFOFAxRTxTBThQUmPFApBS0ikx604UwU8dKCkxwpRTRTh9akaY4dKUU2lFKxSHjp70oxTRThSGhw6Uo6U0dKcKVhoUU5aYPanikA4U6kFLikykKKBRRUsaHLUqGohUi0mMlU1IvSoU+tSrms2NEyY/KpVNQIeamXGCahlolB5o6/SmDilzSGmSZ46ilB+lRA5pyk1NiiUH06UZ4xnmmqeTQMdaAFBpfoTSUg6c0gQv480UUcY+tFgEOcHFJ2x3pc460n0oAUflSZPY0maQ9M00K4jEZpjEU5uM+9RMRj3qkQxjfSmH6041GfQ1aIY0+1IemQOaccdxTT09qtEDDUTZqY9KibpxVozkRN156Coz3qRqjPQ+tWtjO4yjNL7Gm5q0QKTSZpCeeaQnjFXoQOzzQnWmfzqSPntTQrHR6BnHHQjFXpuJMZ6mqeiAgYHYZqxMxMoArGWpvAj6MpPY1BM21WOR1qd8gj+7mqN0wyF/OlbQtbnV+BYSTcPzjA7fWtTUxvuGQYyVxmjwJDjSJpSOpwPwqvqEuJJXjyT0NRc2j2OR1YvE7qwLqT+Fc/cMkTsYyMHtmtPWJ2DMCxNc7cZLZJNNA1oRP+8Y4XAq1Z2D3DHPCKP8AOKWxjDdfwrrLC0DWLMo7Zq0tTN6HB3SbZXVcgA4pgiyOtXLuEm5kXB60yWMotaJEPuJZWytIBK+xc9a9j0fwvoUfh2K6M8MzSqAysw3A+vqK8aQEnk9K09J8+eUQRSPlzgDJNOyIbZa13S4tO1BvsUhMTH5eemK7D4eeI5I5DbXbFoweGNc/qeiXVhCPPU7nGRn3rb+GGmfbL2RWXKfdNRJJxNYSsrnsNo4kjDIQUPSpihzwBWVa2zaJceQzs9s5ABP8J/wreCZUHsf1rl5TdSuVGUkEc00rweKsleTSGNu4osVsR2/oTXYaPH+4XPYVykEf7wYA612ulrtiXp2pWE3oacQ9R2q3GOKrxCrK47VvBHLNjxR9aKK1MgI4php1NyDUjQw96ifvzUr1C3Slc0iV35B9Kpzr3H41eOMEVXlUevepa0LTKTICOOlM28HGeassnGB0ppX5celJaDuVCmDyKiK8e1W5E4JFVW4BGead0F9DmfGGmtqNssCjIkYA/hT9M0eCwtI4VCqABnFasrbpOB04qhKPmbBb0qNi12JWntlLKuAgP5n2qNr+MkoGGAOKzZldSW2j1qnIJF+ZV4qXJmiibZuN+0CUBcdKgnRJipd8lf0zWRvcpuBPH6fWka6ZRhgQetF3axXIiwdLiaRmLt16ZpHsUjVkPOCCO9QJeDBBY5B496m+1bgQTxjjNTewcostsvllARuPT/GrEdvGqKG6kc+9UTMN3LHgY+tOFwCPlB6YqubQOS5pxRW6gYUZzk0+Ty8EYGPas6KbrkGnrOTnCZ7UKYvZltAsf+rbCmo1dMkkjdTUYsoB2gjsalRATk7T9KOZj5UICpYls4PtUrFFGBnOKEjLNxkgVYS3A5bPFFybIj2ggY6mpRZo/VAw9cVJ5HAIzirscIA7gnrVJk7FVNLhwD5Y/lS/2VCefLH5mtKJCoB5qZVPdSB9OtWmibmOukQFT+6XFYl/psMEhwoB3AjP1rtCpJ+UD86xdZh3bcjngfrSkhpsy/JTzMgDP8xV6GLK/Kx/z2qb7KGxjGeKsxWjK2Yz+BqUuo7i28K4/nVyK1Q8FAfwpYMDKkbW9CKvQAY4NVYm7II7dVOAuPwqbyUYAhcEVZVR3o2c8UWsFymYHz0BFRtDgkmtLbjGDUUsQABXvwamwXMe4iBGQeev0qlOmAdw+nvWzLFnd8oxWfcIuwk//qqbDTMWeIsp+nFUJYD1B4x+tb0iZX2xVCePbnk478UrFJmQ6naQ4Bx0I9KqT28bDJUg54NaUgEbAE/KeKimQBcY/TtQBnqTFxJ93oG9KtRsCCQRTWjGGU5we1RxoYsgHKj9KVgsWRnGSRih8E02NwRgkYpRy38qBEZyVOSfyqswOG5HFWnyCeeO1V5AcEg9aaQGfNjOO9Y17xIRjmt2dRj3rE1IEMHBOen4U0I5y9B8skDkdfeuc1DEikjt/OuovhtDEdO9czfLtckdGraDMZoxCRkj+dV5QBnNW7iPY7c8YFVZuh4rdHMyucMMnqKbv4peAefwprn0xVozZLkLBx1NNiP8QPPekkbbGuehFRRttcgEYPFMktjrkdP60OejD8aQcH1GKQ524/CkAS81F2/GpT80dRdqaABSg0negUAiRDUw6ZqulTjnrQMWmGn47U0jigBlRv6VKenNROKYDBUoHFRjrUoHy80ARn0ptONJSAbTTT6QjrQBCaTtT2plADRS80dqMUAKKUd6QUooAUc0o/WkpRigBR05pRSClFABTad60hoAYaKU0ykIdSCkFFK4IeDUkRqHNSRHmpBmpaHBrWhxtrGtfWti36CsZksv245rSh6cVnW+M1oxdOK5ZsiRet6vxNis2E1cjasrmdjShkq2j8dazIm59qtI/FUmRYubzjrTWk461Du96YzcVSYCySHJquze9Dt1qu7+hrWLAcz+9RM3Xmms3vUZatEykhxb86bn1phb0puaopImBqSOoFNTx1SNEWU4qZOtRIKmSmUiZamSokFTxiqGTRip0HFRxiplFAhQKUUoFOAoQXBRTxSCnAUxXCilFJSFcKSlpDUsm4hpKU0lZNBcaabT6TFZtBcjxSU8rQFqLBcRRS0uKKQXGmoZBwamNRP0NTYLlGUdfaq7CrUvU1Wb3pWC5WlFQNVmTvVcikK42kAzS4pQKCLjcflS44pcUU0TcZjikNPx6U3FBNxhFIRTselAFBNxmPajFPxzRipsFxhFRkc1Nj3qMioaLTIjTakIppz+FSWmMNMIqTtTfrTQyFhUTDirBHB4qIitYhcg20m31qYik21tFE3IdlAjFTbaAK0SE2RiMUbOKmCilAqkguRqlPAFOApe2KAuNxSHpTqaaVhpjDTTTj3xTSfepsWgzSZpPXmkqdirDvxozTQaXPFNMLBn3pN1NJ4ppaquOxLnigNUIbsacGoTCxLu9KMmo80m7rVJhYfu96TdUZbim7jTuFiXdS7qr7jShqLi5SQt700mk3Uwmi40rCk1GTSk1GTSuNIQtTCaDTCe9ItDs0U3NFAy8oqaNaagqeNa6DUliWrcQqGNatRrilYCzAKvwVShFXYaBWNO1Nalu1ZNtxWhC3vSEbMDVdjNZUD471ehfPemhGnBVpelUrc8VbU1aBkyVPFVdD6VYj9zVIktR1YSq0Z4qdD60xE69KlWoFNTIaaESp0qQVEpp4b3qkIkFLmo9w9aN1MRMDRnioQ1LuqkK4/dzSbqj3CjdVIm4/dRnvTMk9aM0CHZpM03NJn3pokcTTCaM00mgBCaYTQT71GT+dA7ilvSo2PWlJqMmgEIx4qJiacxqJj1oGRyHg1WY+9TSHiq70hoic1C3rT3PWoWNSxoRulQSHipGOBUEh64pFED96rP3qZzUL9KBogb2qF6mbGDzULdOetSNET1Wkqw1V5KkpFdh1qJu9Sv3NQtSsUiJ6jzUjVEx5pWKQZppb+dNLUzd19qLDHM1RM3FIW9ajLUhik1GT70MajLe9TYaHMevrUTNQzHuajZj2NKw7iM3HWoWbr6UrHrULHrRYLis3+c1CzUM3amE+vSiwrjWNQM3XGKc7CoXYc4oQrjWaoWanMe5qFm680xXEdqru3Wnu3bNV3J55poka7e9QMacxqJjVWC4xjUL9+akY9ahapBMaTSUGkoKTFpRSClHvSGmOFKKaKeKCkKtOHSmDvTxikNDhSimj9acOnNBSY8dKUZpo9qcKRSY4U4Zpo9KVenakyrjhThSDpSjp1qWUhe1KKQUtIaHCnLTB0p46UgHilHSkGPWlHTrU3KQo4opPrRSKQ+nLTFp6mpYEqDmpV4qFenSpF6VDGiZalXpgmol6Zp61JaHj2p31pgp3fmpYXFXHSnD2pgNOGO1KxSZIKUdKatOFIYc+1L+PFJ/jSdvpSBDu1IaSlP1FACZ65JpuaX60n160CAUhzRSH+dNC2Ebg1C3U+tSN3zzURxmmiLjT7mm/WlPuKb649atCbE9aaT1px6GmE+9aIzEbp7VEw9DUjH34qJjmtEjJkbDk56VGaeeM5pprREMbTD0NP/AAppHX0q0ZtkRpM8UrCkA7U0SmKM1LF6jtUZUgVLB9w896YjpdFz5GT3FSHmXNO0hR9lB5GBT1TMrHnGaxudMVZEbjr7CsS5kHnSZ6dq3ZvuMRXM3JzM2TxREZ7H4MiC+F85GDk/n/8AqrndT8yKbcnIP8q6vwYgbwqhAHKfma5XVpGBBUD5W59/asWtTWBw+uS5uGOAM1hXDbjtXrW/4hVJpTLERjAytc83UYq4uwpPUuWpEajNd94ZVZ7MgdxivO1boCa7/wADSgrsya0jqxVF7tzmtesTa6jIrLwTwfas2a3DDjvXqfiXRFvrcuoAkHI4xXndxC1tIYZlIIOOatxaZnGSaMmG2/ejcfl+ldZ4TFpp+rQzSDdGGBPt71gEbSdoya09O068mTeIyAeB/jQvMfLc63x9r1lqTQRWTB2AwWHbmuo+GenJYWXmPjzZcH0xXD6b4WlEglnPzDGFP866yJNShj2xSKOMVFuxSg0rHYaxNEwYvKox+lL4Y1u31DfbJIGaI7c4x+NcHHomo3UrF7h23HJ610Xhjw7Jpt6s4lJ/vD1qGlYuKtodx5QBOOlN8obSOfWpwQ0eQTTO+BnNZIvUbaRnzV4zzXXWSEIAMVz9jFmZQATjrXT2y4HTHahK7Jk9C0nQVMPu1GoqVcYroSsjmkA6UpopppkoRmpCeKax/KmlvSpuWkKx4x3qJu4xzSlhjgmo2bnmlcpIQnFROM1JwcgUw+x5FO+g0QlOOKQLyQRzVhVOeegpdnfApWFcpyRfKQewrOlRjwcCtto+P5VSngJOeaTRcWjDliKdATzVVk3NjnNbc0JOR2qq8I5BHQVBaM02/tnIxTfsnAYL/wDXrUjhC8A5qQRjnIoSTLvYw205GYkKAfyqCTT+DlARntXRtGrdfpSCFRnjjNFkNSZyp0pSxJAWozo5JyGORXYCBDnIFAgTkAAVPKh87OQGkD+JyT7Uv9mcYGa637Oo4AGKYYF5+lLlHznMLYMgDZJxwRUqWbhm2xmuhNsoX5e/Wl8gYyRT5bBzGALJmPIAAq1b2PAbH1raWEEY25H0p6QKD0ppE8xQit8DhRxU6w5OCBirojx0XinLGd2QBgcU7E3KoiG3B6VKkY7fSrKR9cgYxUqRj+EU7CuV1jGDzz9KcsX1/nVpY+M5FPWMYOTTJKTIVzk8Vj6wPkQAHhutdIYwOCM5rL1i3At2dRyOlJgmV0iXYp/2QfrVlV4BB5ot4y1sjEdVFWYY/kyRzQmNhGokXJAz34qVIlxxwafCgAOMDmngFSQelMkaAQOTShctwfeg+pPWkJB5BwRQUP285zQ6+tKOVzkZpGPy4J+lNWZJVnDAcLxms65hGCw+prUkzszk1VcDaTgYPFQ0UmZMygjK9BiqMqgtha051KBtqms4hime4qblGZcxkk8D8arjLrt5yvH1q/OODnGTVUgI7A98UnuCINuRgnkUxUBY5/Wp3HzZBpGwCCOvegZAbcEHB5qIrJGcYyPpVwg5yOhpjdCAOlOwisOSeDkVC+BuBHOM1bdQxz6VC65OAOKSQGfOpxg1k6gmEK561tXI5+7/APrrJ1FTjIwaYjmb3uBgjFc5qEe6NwM5FdLdffbGMDrWFOu6WRSeWFawVjKZzdwp+6TnHNUpTtAWtW5Uoz5I446VluNynk5FdETlkiq4y3NMxkn2pznnnPFNPAIHfmrRncSVtye2KjQ8Y9ORTieCKiU4ODVEXL8ZyBz1FL1T9Kjt+oz0qTGCwqdhjR9w47GmEU9M5YGmnAyBTAZQKUUlAD0/rU656VAlTpQO4uPak/DinYpCPWgLjCKicDnmpj3qN+lAXIR1yetSBsimEehpR0oC4fypCOKWk7GgAppFL2pO1AXGN696jNSNUZ60BcSgd6KKAuKKWk+lLQFwHTrSikpaAuOFL24pq0v0ouFxaQ0cUmfSi4XENM/zmnHkdOlMPpmkIKX1FIKPU1IC1LFUQqWLrSA0bUVrW3Ssq0rVt84+lYTYmaMB/Or8TcVnRdeKuRtXJJkNF+JqsxtjvVGNuODVhG4z2rIixoQtxVlHx3rNjk9DU6y00yWi+JBio5JRjrVYzcdahkl681aYWJZJuTz0qAy+9VZJT26VHvPrW0R8pbMlNL+9Vw3vzTgfzq0O1iXdxSiowfSnKe1WhpEy9O9TxVAn1qeLr/KrRSLSVPHUEf6VYjFUiyxGKsxrUEQq3GtOwrkiCplHFNRamUUxXEA4pwFOAp2KBXGYpadtpdvFIQzFHanYpMe1ArjaQ06kqBXG96SnEUlQ0SJSdqdRUWAbijHFPxR2qLDI8UhqTtTGpWC5GaiepGNRN3qbBcrSdPaqz96sS+1QN9KmwXK7jioSM1YYcGoiO1STchx2oxUmMdaT2oJuNAHOaOMUtFNE3GY9aTnrT/6UnaqJuNxSAc0+kpEjKCKd+dHakCI6YwqU9Kjb8KhloiI7dqYRUhFMOKmxaY3HGaae9OPfmmmhIq401GRUnY00itYoRHigDFOxS4raKuTcaBRinY9hRgdK0SFcbij2p2KX8KtILjQKBilxS0wGHuDTDUh61Gw96mxSGHpzTPX2pxph71FjRCE00mlOO4qPPvUmiQ7PFIW45phNJntk0rlJCluDTCw75pCeoqMn3plJEgalDVED69qN1NMLE26k3+9R7qTdVJisPLdqTdUeaM0BYeD70bj61GCaXPegLEoakz71GDRn3oEOJph+tBPvTSfSlcaVhpNNNKetNpAGR60UnNFAzYWrEQqutWYutdZqWYhxVqMVXi9Ktx470gLEQq1HwagiFWEoAuQE9M1eias+DrVyM8UCZowSdjV2F+ayomxVyF/ehIk27WT8qvI/HFYUEuO9Xop/U1aEaqN71Yjb1NZkcwqxFJngGmI1I296nRqz4396sI/HWmhF5W44NSK3HWqav71Ij8VSEXFb0NODVWV6fuqkJk+7ijd71AG96N3vTEywG4o3fWolb3p26mkTceWpM+ppmaTNUiSUGjNRhvejcKYEgPWk3DHWmbqbketBJIT6Uwmk3UwnigBWNRk0pPWmE0AgJ60wmgmmFqCkIT6VEx605iKiY0AROetQOeDUrnrVdzwaQyGQ89Kru3WpZT1qu5pDQjMahkahmqJmpFIYx7VA5p7t1qB2pAmIx/OoW75NOLe9RMeOKVikxrnjiq0hHPNTO3pVV2GTzU2GmRueuahY9akcjBqs55qSkxHNQsetOY1CzdaRaEY1GT15oLdajLcUBccWqNmpC3vUZb3pDFJphPFISKaW/KpHcRj71EzdaV296gZh2NAxXPWoGPvQze/WoyetBIMaidvehj71C7dRnmnYQjN+VRM3FIzdajZuDz+NACM3X0qFm646UM1RE9aYhCc5qJ6cW/Oo3ajYRGxqFv1p7HrUTGmIjao2pzGo2oGmFJSUlIaHCnCmClHrSKQ8U4UzvThSKTHjp0pRTBTh70ikPFKKaKcOlA0OGcU8dOKYPrSjpSGh46Uo/SkBoHvSKTHqaeKjBFPH1pFpjhilpopQeKkdxw6cilFNHt0pwqRokBpaaOnWlHvikWhwoptKPrSYxy09TTB6U9evakwJFqVahWpU96gaJl6U8VEKep4qCkSDNLTRTh05qRoXI6U9e9Rj9acvXrQNMkHanD8aavHU06pY0A4oHcGge1HH50guHHNNzQaTt60BcUnimjNB9u1Mz700hD89aQ9OtNB4OetJ+NNIlsQ9CKY1OJ96YSMd6aQhp6Uz14pWxjimmrSJYjHimMeKcaYTVozYxiaYxpxphNaozYxuuc03+VKfrzTeTVozD1pDzRxyM0w960Rm0BXPSnxQlnH60xck1agRm4GaNhJakbRncQas2lsdwx09au29kz8lePerkPlx/IFHHf1pX0LUTQsF224GMDoKMYV8cZqeFQLbk8dRTHX5W9KjY3SKNx8sTZ61zM43SNj1ror98RkCsBwSxweM0kx7HsPw2m8zw7JCScpj8jXN+J5XWSWKNDgNnNO+G195BuY2c4ZRj2xT/EzJJcSKmcn9axlua01pc4C/yXO0cgc+9UPsrOST0HJroLu352RA57k9qfZ6TLdFUAITPJqkKUbs56O2Z8hRnBrb0F7jTpw6cj3HSup0/wANgOERRt9cda2IdCjjlUlFYD6frVqVhqGmpRj1m4mi27T06+lUZ9NF7L+9JY5z0roRYeY5ES42nrj+VXrfTGjOYyMnk8dabmxKCOfsNAtlbBiyBjBIroLXTo4IywQBQOAOa0YLaNRhsFz3qyEwuN3H0qVLuXymdHGrDJT5h36VajQKu4DJp5KhcKoLdOBU9vExJLA8/pS5raD5SS3k8r7qjJ5NWEd5AQpwMZNRraswwM8cZq9bwbRtA4o33Fy2L1q37hVJ7VZRM9BUNsmI8DHHFX7eI/h2qBIu6VDlia3oRxzVGwhwvIrSjWnBamU2SRipAOeKRBxT66EtDnbENRvjFPNQt70r2HFDGPBqNjTm75qJyc9qzuapAWx15FNDce9NYmkFF76DsPHcilVOv50R1IF4znNCJuCr6A5qQJxzSqBjrT1XA5OatWJbIjHkcdRUDxbsirgHUU0rxzRYEzNkjwMDGT3qhJEd5JIx06VtvFnpjFU5YSG5AI61EkawaMsREOck4/lTgvOPercsYHIxntmo9nGSeagu5CV4waUxjHfipuwzmkCjnk07BqRbPyoxgYAqUJx14pAOuRRYpMYFODkflThH9KlwBSheCcGkgIREOc09Yxg5FShM9uKcqEHoMEUCI1UYwKds6AYqZUGevFSCPB46U0hXK3lnBAqVIwMgDrVgIOPWnLHg980JE3IljGefSnJGF6VOq8UoX2p2J5iNYwOuKAgH481MFo2j05p2J5iHGc5FUNVTdDtA5JArUwOlVJk3zDOPl5pWKiyvHCI40XngYp/klSCDwT0qR05GKk25XBPIoLuRxoFLZND5C5HanAckHrTX6HFISREx456VWlkwvU4qaRhg1RnYgEYGDSbLSG207iQjPy9s1eWQsD0J6/WsnmN1JHFWlcjkGpiwaLbSAggelQs/y4xzTPM6479aazfLxVJisQTAnOazJTkMCO/pWk5IBBNUJscgdetTYaKE43rwOKqTqCvzdRV2cgrt59qrOgMZyDmkxorDDLjI4FIBwASKYMo2McGnqvBxyDQAjZH0zQ3SnAE5B6dKTuc07iI3XjHrUePl5HNTEc9etRtx1Jz2ppAUbpcVjaiAq8jrwK37kbxx0FYWqKdmRjiiwrnL3PWUDqCM1h3wPmAjqMZx6Vv3SnzHIHBH8qwrrPnOB028VpAiS0MXUVG7eCMGseTCMcdTWvdjKHpWLMcjnsa6Iq5yyK033uelRHhsnvUrtwVOMdqgY+lapGDGM3zZ/CkON2RQ/tQOR9KBFqDHyselWJMBsiq0HKY96tH7hHcVLGthhwST6daY3enj7xz0IprDGaAIuhpOafTaYXHpVhKrpViP/wCtQCH4php+OKYe4oAbnioZD6VKe/pUElMBmacPxpmeelOHtmgBfX1FBoHf1o7UAJTeaU004x70ANPem049KZSC4cYooo+tAXAe3ajpjNAo60XC4ooH5UUDvmkFw7dqXPrSdqWgAooFFACH+dMPXrTz0phoC4n060go70D2pMLj1qWOoR71JGcVIjTtT09K1oOmCawrZ8HrW1bsNornqIRoxYxz2q1GaownIxVuM1yyRJcjNTqcZFVI24qZWqLEllW609X96rhqXd+dFgsTmQ4qJ3qMvx3qNm49qqKCwO3PNID6Hmoi3r0pA3Uit0gLAOKcpqFelSrVpBYmU1IuaiQVMvSqQEqfSrMQP41XjFW4RVopEyD2q3CtQRCrkK1SKJolq3EvFQxLVuJeKaEPUDFPUCnKvHSnqtOwrgopwWnBaeB60EkYHtSYqTFIRSFcZimkVJ2puKQhmKbipCKTFSIjpuM1LjikxUEjMUYp2OaXGe1SFxoFGOKkA4o20rBciI4qJqnZetROKmwJldu9RN9anYGoGHYdqVgIJO9V29asSDj3qBh1qLBchbpUb4qU9Peom+tKxNyM9xTace9NOaVhXEz6UUfjSDpxQkIO3aj60tJ60xMOxzSfXtS0YpXENo7U7p6UmPekCQ01C/epTUT9+akpIiNIfalPWmH1xSLQ2k7cUU3tTQ7i000tJ3q4gIaUUUVtEkPxoo96K0Qg/CgUClHerQgxTexp1J7UxoacVG9SHpUbd/SpZSI2qNqkbpioWPFQzRDWNRE9c9KcxqPNZs2QtITxRmm5pGiQh6daYe/enE+nSozTQ0g/lRn3pOnSkyfWmKw7PNJuppJxSetUmA/PXmkzTR+FJRcVhwNLmm0UXEOzSZ96SikIM0mfSjNJRcYdaSl9qMUgEop2KKANZetWIqrLVqGuw2LcVW4qqRVcjFICzDVlO9V4ulWE9qBE8PWrqcCqcP61bTpQhMnQ1aiP0zVNDzVmM1SRJcRvpVmNj61SQ1YjNUkIvRPV2B+eazoauRE+vWmkI04m96nRqpQtVlGpoRaVqlVveqqmpFPvTQFtG96lDcdarI1Sg+9WiSQGjdTM8daM+tMkkVqk3cVXB75pwPvVIklzRuqMNRmgRKG/CjNRg0uaBDt3vSE03JpCaaAXPvxQTTc0maBWFJNRk9aCaaT1FAwJqMnrSk1GWoGhCajY9acTwaiY0DRG5qBzUjmoHNJgQSHrVZzU8hqq5pDGO3Wq7mpHNVnNIBGbrUDn1NOc1CxNBQjGoyfegnqajY9eaQIbIcA4qs7VLITzVZ+tSykxjmoXPpUj8Zqu54qSkMduuKgZvepHPWqzntk0rFJiM1MLe9ITwaYc+1A7gWppNITnoKYelIdxSwpjEdM0hPUUxyMVNhiM3HXioXalY1ET1osMQmmMaCRzio2IxQSNduagZuuac7dcVAx60IVxjHniombr1pzHNRNTFcazVEW60rH1qJmoARm96iZu+aGaoWY0CAtgGo2b0prN70wtTQATTSaM00mgBaQUnaiiwxwpR+lMHvThxSKTHj2pRTR04pw/OlYpMcP1pR0yOlMGacOlSUh4p4pi+5pRRYaY8U4UxacPrSGh9ApAfWgfWkUh4+lPHSoweKcKRSH5paYD70oqSh6/55pw6dqjBpwPvUlIkHSlpq4xSj3pFIdS0g6UDpQND1qRajX6GpFqWMkX86kWo16VIM5rNjRKOlOUUxfrzT196koeODTh0pg6e9OWpHsO/ClHHpSYpRQCHr09qf8AjTBThj0qSg7fWkzxye9L1HbJppyAelAB60047UA5700nj6U0hC5FMPtQSPzpp74NFhDs847CkzwfSkzxn1pM8U0ICaYTTieKafamhDD1phPHNOJ45FMNUiGITUZNOPrTTVohjSeDUZ705s01ulaLQzdhhppNBPvTAeKtO5AueMU09KP50hrRMyZYs4/MYLnrW7AlvbD5iS1Ydk+1icjjpUk0xJOD1oeoJaGvNfmTKxDCDrUVoS0meetUAxVMDqetaOlqTyc8GlayLjqzoB/qFHfAqOdtseMVHHKGk2ntSXL/ADEA9qi+pujNvmyMZ7VlMMPjtWjdHc/4VQf/AFoA7nFCY7aHV+CmWLU4QSMEgdPWu71/Ro2lVlGAwznGK850N2ivLYjHDg/rXvhtPt2nxFlGcCsXG+xrTdkeTReHXvbzEYPl5xnGM12NtoEVpahVTJUc11VrpiW5+RRn6Uy+AQBSepzRG6WpbZzJtfLi27fnqIQBAQQffPete64OSOKoyKCB+ZpcxSWhFbxLGjY9akGAcAgD6UIuQ+M4GKctu8wIjBC+tF2UooZuXHyk8d/enwI8wOMhRxV2108KoyM/hxWlDZ4+7gKP1oTE0kZcFoVxhauJb7SSec8nitARgAjgCmlABwaaZNyBUAPGenWpANzYFSCMbeT+nWpooiSuOnQ1YiW1t9oGD1raggyFwB2qGxts9jgVrQxDP6VPkQ3YmtkwtXEHFRxLgcCp1XjNaQics5XBR60p9qUdKaa06GY1uBUTdDUpqFz6VLLiQseOKiJ4Oae3cVG/TArM1GMTjnvQvTI/Gmmnx9PpQDJox6GpV6YNRp71KnNUkQyRBzxTwB3po9aegzVpEXAUN0pwHJoxTSVhXInXjiqzoepNXGB9aiI9aloqLKLw7gR3qs0Z5BBrU2g5IFRGMd6lrsaKRnYzkAjj1FIV+bjnirxiGThRTCmOOcVJfMU8H3yKcB9atiL6Uoj68ClYfMVVXHXOaeqljgg4qdUwTmnrH75FCQcxAsZ5wOBUqp09akwB604L7c0WFzDAgxx2p4XA5xmnBPSpAlWloQ5Ee3jApQp71KE4pQPWhInmGKOOlPUetOUUoHpTSIuMxjJpp69KkNMNA0xp6HNQBeCT3qV27YppJIx2pdS0Rhc9e1OHvQcUhOAaRQh69arydTg8VK54yKrSN27+tSy0QzHgkVSkY7DmrMhwD7CqLvkkjpUNlJELPkDOcipd4K8daqOTvYjpUwYFeOopIbRMrcYJ6UpbsO9QqflOTQGAHvTQrDmPbNU5WwSBU7kDOKrS9CaYIpznLHGearv8oxntVqQg9RjiqsgJPXipKuV5BgAjGKYgwTyTUkgyODwKi+6vBNCEKCMUucDIx6UMQVwuKjPHFFwHduvWmMMjk0uSc47dPeoi/BB6ZpoViGQnBGRxWLqJ5ZQeorXmI5zj86xNQf8AeHGcng96q6Elqc5duFmIPQ+lYV7mO45zgjArev1XeA38Xf3rC1BWUDJzjpVQJmjEuyctjOCKw7jOT9a3NQJ25Xt1rFucHcPxrogzmqIpvjHsKhJ54qU9CKgrVM52hDilQdqb9acnWnfUkntuGwTxV0YBYZPTNUk+9WgQd24DqKTGiA43ZHQikbGac+OPpTTjikBF680znNSHvioz1piHpn1qzF0qunTirMRpoaJMcdajbpUwHBqNxxzQBCaglqdqhkoAhz604exptKKAHCjtQOmKX6UANxSGl6009aAGHGKbj3p56Y9aZ0FJiE9aPqaPxpM0gHDGKPrSUvsaAFo/Ggc9KXtwaAD6UDPc0CigBfrSf40o6Yo70AI3f1qI+pqRveoj+ooATvS+1IPbFHagBw4/lT19+gqIHHrUidamwFiFuevFa9pJ8oHpWPFWhbH64rOa0Ebdu/FWkbFZdu571fjYda5ZRJsXEcetTK4qmrVIrd81HKSXA/PFLv4PNVVfil3fnSsBKXphYd6iL03d700gHFvelU1FknvT0PH8q1QFlOnWpkANV096njNWhlhBUqioUPpU6imgRLHVuL3qtHVmI1SY0W4quwiqUVX4KtDRbhWrsS+tVYsVajPrVICYCnqB0pi9Kev50yRwp3akFLmkSJimmndqQ0hDKTHpTsUUgG4oxT8fjS49qkki20m3ipttG32qBEQWgL7VLtpQo9KVhEYXigr7GpQtLtpCuVyvFROnbFWyvFQstFguUmWomXrV1l9qgdRg1NguUXU88dOaqyDrir8oqpIOtS0Fys3Xmom/SppOlQnHapsTciOKaeMkg4p5ph61ICdPpQKPU55oHv1oEHPfpRilHtSCpYB2oHTpSj1oFFwsN+lFOxxSYFTcCNgahYVO/T2qB6kaIj3qM5xT2xTDQi0xhptKTz2pDVpDD9aXtzSUCrihBRzijHWgYrWImH1ooFFaIkPpS80DpRVIApD04o9aOxpgNNRt3FP+gpjd6ktETVA3fmpn9qgbrUM0RGxNR5p571Gak2iBNB4pCeaQnipNUIfamEntTjmo/rSRSQtJRR2xTuAme1ApfXmkxTTFYKTvS0UyQoopPei4go+tFAoEApKX60vGKQDaKXFH1ouAZFFGBRRcDUWrMVVV/SrMX6V2mxdiNXY+tUIj71biNIC7FVlTVWI+9WEoAsxfWraHiqUZ5q1GwxTJLC/pU8Z4qspqWM00SXYzU8f1qrGasxmrQi5CauRmqMR4q1G1MReiPvVpDVOE8VYRqaQiypqRTVdW96eG96aAuI1SBsjrVNXHrUgf0poks7qN1QBwaXd71VyWTg804Gq4b3p6t2zVIkmBpQaiDe9OBoESg8UuajBp2aAFzTc0maQt700AuaTPXpTC3vUbN1oAeWphaoy9RluCKAHlvemlhioy1N3evSgB5ao2PWmluDzUTN70DQrNzUDtwaGaoJG680mAyQ9arSNxT5G681Wd+TSGhrt1qu5p7t71XdutIBGPvULGnM3vUTN+VAxGPvUbHqaGaomYc0hoRz71Xc8H0FPdqgZutSykNk6Zqu5p7MKgdqkpDHPWq7nk1I7DFV2brSKTGlqaTTS3Woy3vRcB5NMJppamluDzSGhWIqFm7UM3eoXbrSGmKzfnUTNSM3vTC3WgLilvTFRO1DNULtQTca7dfWoXY9qczVCzdfWgVxrHrTGJ9OKRmHNRM3U5oFcR2HNV3anueeagc9c0Bca7c9ahZuuKHaoSfegaF3U0mm5pM00A7P4UZpuaTPrQAuaBSA0CgaHCnDNMGPWnDNADhwKcDTRjHWlGcc0irjgcU5elMHSlFBSZKPelHTimg/lSj271JSY8GlB96YPSnA0rDTHilB496YKXPvxUspDwcUoNRg8U8Ui0OzTgfemA8elKPrSKQ6nDpTO9KOtQNEqNwakFQrUqmkWmOHSnD9KaP0py0h3Hr6VItRrUq1LY0PUcVItMFPWoY0PWn0wZ6U7jrUjHCnj60xakFTcrcdSgU0frTh04PWlcEh2KUUD0NIaRQU0nn2NONMNAhKbk84xSnp+NNPtTQhPWik9aKBBxSE0fjThjFMQz69BTT1PvTj1NMPvTSJGHvScYoPSk96tEsaaYafwM560xvwq0QMPf1qJ+nFSnvUTDrVohkZ96b39qcfrTPXNWjMQ9Kb7UuPWmmrRBJEcNTixyajTg1IeuapE+RZhJk4JrbsAFiJOKxLM81sRNiHA9OamRpDUswv8AvWbPSh3+Y81BAck0pPzHFZvc2RAxBlPbNQCMmccfjSyHLZzgj0qa0BLktk8YoZSNHTgTfRKOzD+dfTOgQk6VAWH8Ir5t0CLz9YgRcnLAV9S6XD5elQKB0UUQ3K2Rn3MRTLDGKwrxlLsx69PoK6W/j+Q56Vzd1GZHOPpWM3ZmsNTHmYsCFB25xk1Eto8mQorajswThsYqykAXoo9qlI05raGVBp4UAOTjuKvRQKvAGFq4qDuKXyzRYV9SDyyfu4wPapVUDrUijAx+dIq8ndnHahMbI2G76CkVc5+tSAHPA5P6VYjiweBnNWiWRJDluMdO9XbS1LHLYxUkFuW5I61qQ2+1ce1HQiTQQRhVwOlW4V9etNVeMDpU8S1UFqYSloTxJxmpQPbihB8tOrpSVjlbGdiKb6089aYelS1YaIzxmoJe4HWp36VXbOcioZrAjOe5GaiP8qmYe1QuMDA5NQarUj6mnIOTTMEHk1Knv2oBolQDGKljHNRLntU8Q45qkZvYlAp+KavpT/wzWiMgFJil6igelNAJ0BqPjn2qU9aaQKTBMhU5J4NNK5zUxUYNNI496mxaZDtpCvtU2OKTbSsVci29cUbfSptoA9qTaKLAmRgAjFO288VIopQtFhcxFt708LxTwuOtPCjFJInmI0WpMcc0oFKBVE3EUDFAXJ6dKcMUoPXimkTcbtppp+etROaNilqNLc1Gzc9acTURPNZt6GqQOelNY+9Nc56Uxmzwam5aQ9mwKjLcHI60M2Dyajc+lK5SQO3BORVZ2yDTpDzUDt1xU3LSuRyHPTFVXwGwMYqRmyagdhyTSGiCZCWyD9aReIyM5NDt8pxUUR4OTmlfUdiVDjOTwaBjJ61Ccq3qM04tx1ppiHSNgcfSq8hO2ns3BxUErHqc46UCInbK445qu2O1St3x06iodx7jnvQMa5461XbAzmppPu5B5quzZHI4/nRcSE3DdknjGKR25yaQt8nBGRUJbc+c8ZpXGkSb8LiopWGMU1z2zx1qKY5IPNNMLEcpByo7VjX23ec4HHNakuOeTntisTUDlwvbFNMEY2pDKk85GKyr7DQq2e9a15yki46isibBtuOoOKuJMloYd+nyNjkVhT8E56Zro9Q5jIFc7N8xb2roiclRFIgZ68GonXBIqxKBnioXHOa1SMH2Ie1PhX5iT0FB56dakRdsZLU0SkOiGWPp2rRhG6PPpVCBsFiB2rQt22ooI4NFyrEMo6n8qjPTPvU82NxFVz0/GkhWGd/eoz7085z2ph6nNNCsOTFWIveoE+tTRnmmguWl6ZHakccU9Pu9KR+hoAqSd6gfpmrElVpOlAEVKKTvQPbpQA8f1pe30pozTu3NADfWmnp1pxppoENPTmm0402kwGcc0UUdKQC0o/lTePWnD8qAAfjmlH1oFL9aACgUlLQAc49aUUnFKKAEaoT1qVqib2oAT1z/ACo/CjrRQAD9PrTlNM9qcvtUgWYzVuA4PU1RjP8A+qrMbYqJAatu9aETcVjQP2BrThcYxWEkTYvqePanhsd6ro3oaeG9qzaFYlDY/GjdUW76Ugb3osIlzRn0qMHvmlB9KEgHg09KiBFSKatDsTp71Oh9arIe1TJ05qkBaRqsxNVND71YiPFMC3GasIeaqIanjNNMEaEJq/AcVmQtV+3aqTGjSj6VYQ1ViPFWEqkxllD61MtV0NTqaaJaHj9KX1pB04pKYrAabTv502kTYMU4frSAZp6igkQCnYpQKcBUiG7eKMVIBS7eKkRFtpwWn45pyrSJYwLSheKlC0u0Y6UWJuVinHNRMtXGWoWWlYCoVqKRODVwrUTrwaVgMyZcZqlIvXFac65zVJ09KmwbmfIMdahOOavSIMe9VXSs2gK5zUeKlYY71GahhYZzj6UtJ7Zo71IWFFL9KaKevIpXAXFJ39qfxTTRcBtNPTpTuO9MbpU3AYfpULVKaibrzU3GiE96YfWnHvimn69KaGhh/Ck/nQe+aSrQxc0opv40orRAL9aT+VL3oxWqJCjtRR2q0IB0NH1oFJTuAU0/pmneuaYfamNAepqNunWnEjnBqJjzUlIY9Qt9ealJqJqlmiI2qI1K3eom9KhmsRp6U0nrSn9KZ2qTZAenNJxRmkpFIO3Aoo7UnXpQMWjilHAo6CncliUnHTtTj7UlMkBSdqX1xSGgkKKKP507gAz60tJ2zSjpQACj1zRQKLAJiinYoosBoL3qxFVdTViOu01RZjPvVuJqpJViM+lAzRibjvVlD+VUYm9zVlGoEW0NWI24qojVPGcUCZZVqmjaqqGpkNNCL8TetWo2qhE1WI2NUhGjEwxVmNqoRNx1qzG3vVEmjE3FTo9UYm4qdWpoRbVqkD/SqitTw3FUBaV/Wnh+MZqqGxTw1NElkP704P71WDcU4N6mqRJZDc04N2qsGxT1amiS0rcVIGqorHHWnhvrQItBhS7vWq4fil3e9MCYtTC3Y1EWphegB7N6Uxm96YW681GW96AHlqYWphamE0APLU0t60wtTC1ADy3FRs3BppNMLUDQjt1qvI3Bpzt1qtI3XmkwGSv1qq79TmnSN15qu7daQ0DN1qBm680M3XmoWakArNULNSM1RM3WgaHM3WoWakZqiZuuO9SNCO1Qs3FDnsDUTNUlIR29+agdqV2HfrVaRqkpCu2O9V3bjjFKzVA5GOaBoGb8qiLdfakZqYWpAOLU0t71GWpC3r2oGKzcdaidqC3vURPakUBYZxnimFvWhjUbHjrTFcGYVE7UM3FRM1BIx2HY9Khc0rt71AzGkIGamM3WmsfzqNm460AI7ce9QO3WnO3XmoHPU5oC4xmqPNKT71GSKAFz+dJmm7qTd7UDHZoz60zNKKYDhSim5pR9aAHCnD6U0U4elIaHD6Uv500dMCnUDQ4fhSimU5fbFA0PU9acDTBmlHvSZaH/AFpwpgpwqSkOopBR70ikO6U5TTeOtKtSUh/5UoxTR+dKKRSHUopB7Uo+tQUiRaeOneo16U8UikSLTx71EKkX60mNEi1KtRLUie/SoY0Sr709aYtPAqWUiQdMmlHSkFOHU+lSMVaeOnNMX3zThUlIeM44py9KYOtPFIBw6e9HY0g9OKX8aQCe1M604/Wm8YIoAaf5UjA4p31pD9eKaC400lB9qT2NNEgKPWl+tJ29qBCHp14qM5xUp/Oo2qkIYaaenNOP6009KpEsb9aY3enH2qMnrmrRA01G34U8n8qjYg1ojNkZph708009KtEMaelNzS02rRA5c45qRDkGolqRB81UiUi3acHkVrRf6kk9Kyo+mB1rWQfugvas5mtNEltnBNIMfMadCvYUADDVHU1iuhQkyScdjVm0+WPcf/11WcHJAqzbfMhWhjR1vw/tjP4itRgffH5V9NRgJbxoM8ACvA/g9YmfXDJ1CAfnXvz8dewxREproZmpckj0rFWMvITjvW7dx5ByeO9VPK29BWM9Xc3hoimkO3knmneWfarnldCaXyzzkcUgv1KflgD+dBQYyKs7PTmlEfrijcZUVOuaTy2PrV3YOMgY+lIIzkgdKLAncrRQ/MavW0O7sfrUlvbl+T16HitO3t1RcAVUUZzmiOKAAD2/WrG0dsU/bgUYwOauxhzXG/TrVmBD1qCJSWq6gwKqKM5y6Dh6UvajvmkrZPQwEbrUZp2femHrUstIjfiomqRupqMmodjWIxh61DJ7VOcd6jYcE9qm1i0yDqMd6cvXvRgc+lOTr9KRTZMgGB61Mox0qOP5qmToapIybHrx1py85pgpexqzOw78aAePekHTmlFCYAefrRjI6U4CgA9qoQwKcn0o28U/BxSgcYpWC5Ft/OjbxUm30pQvvSsHMVznOO1PC8U/ZjrUqqMUJA5EKoaesfGalCgUoAHQVViOYYE4o2Cnr3Bo75p2FdjCnHFR7cGpj04qPFQ0NMTpSdqCOKYWxRctAT6VGW5pzHioifSpbLSEY1GelKTxzURPpWbdzVIM9ajJyeccUrH86iLHoak0Q5j1z0qFmxwDSs3vUTkfnQNIZIcnrULtz7dKezDHvUL4xUlLQjfGMVWcDHSpnPGKgZuooGQsfmxgfWojxnjipGHU+lRNyDk5pBcUtxx0ppPGO9DMNuB3703sc0CFPXnp3qGQ8HBOP5VIW+XioJSecZp9BEDNkc/SoXYc5PSnSMQcDOKgf5cknmlcaEZ+D1xULNjIHIoDfeBJ5qFz3HpRuAOwGMHtTCTs59aa7c8/Somfn9KQ1oO3EKQT3z9ajkOcjnpSliD2yelQF8MxamnYGMnJCnnFY922B/8AXrRnfcrEHp2rIumwMA57UXErmdenuQOetZkqBY3A7Hj2rSvDlAD1zVBxksDnnpWkRMxL0YVu/HNc5J99sV094mA2K5q4AWZga3gzmmio3IxmouxGM1M2OeKjOR071umczVhgAyMHNObLcHtQijr3p6oT17Urgoj7VcsSc4qyhyE5ptmnJPYCl2kopHbNK47WHXHTNViPQVYbLR5qI9KpEtELD5qjJqZxULdaaFYcn4VPH7iq6fjViPrTQi5H0pJOneli6UMOKAKknfrVeTuatyDsaqSigCH+dA70h/WlHtQA4U7tj0po6U7+lADT+NNPtTj+NMNACH9abSmmmkIbSd+KU0n4UgFH4UowaQd/WnCgAGMUo6c9KByKPxoAMUUlKKAFpeKQfWlHvQAh6dahPpUx71CetACUUUcetACevNKP1pPpSikwJkPFTI3FVkPHvUiHtUNAaEBzWhC3HFZkBxV2JuOOlZSQGjG/HWpA3vVRGOOtSq3Xms7CsT5GeKM8+9RA04H3OaVhWHg9qcD71HmnKaEFiVTT1I6Coh609TTQWJ0OBUyHFVlOBUqNVAWkNWozxVNDxVmNsdKYi0hqeM+pqqhqdDxQgRdharsD4I96zYj+dXImqikbEDjFWY2zWdA3FWon96aYF5DVhD71TRqnRqpMLFkGgmow1KDVE2HUUgJ9aVTSJHKKkWmCnrQIevSngUi9KcKRPQUD86djilA4pQKViRoHNPVeKVV5qVV4oSJuRhcUu3ipQoo28UWIuQMOKhYVaYcVCy4zSsIrbajdetWCKjk6VNgM+RetVXXOTV6X6VWcdamwyjKuBVWRevFaEoHPNU5BxWckNGfIMZ4qAjk1bmHWq5HpWMilsRUYp2MdKTvUXBAPWlXjqeaT2p30ouFhaTJozxSHpgVLYhD/AJzTDnFPPWmtSuFiJsc1E+cdqlboahbvQIhPoKYf0qQ9/WmGmhkZ6mk/lS4PrSVoh3EHFOFIPelHFXEQtHbiij61ohC9uaT+eKKD0Jq0Aho/Hml7e9Nx6UwA9PemfSnHpTDmgaGt168fSojUjd81E3ekWhh9qYfrx3p3emnvSKQxuhqAj1NTNjtmom61JtEjPSmmnHNNNQaob9aTv2oNFKxYUUmaXvTAcPalHTmm0ooJFHTpSAUtH480Eje3einf0pMUIQ3t70ClxSjviqQCDpSgetJS0AAzR9KXFAxQAlFLRQBeXFTwmqyn3qWNuetdhqXE96mjPFVkPFToaALcTGrUbCqMZFWY27UwLsbVYQ1Rjb3qzG3vQBbU1MhqqjcVMrUITLaN78VYjaqSH3qdGq0Tc0InqyjH1rOif1NXI2qkSzQibip1b3qjGw7VYRxVIRaVuKerVXVqkVhjNNCLAbinBqgVqeGpoknB96eDUCmnqapCJwacDUSmnA1RJKD704NUQOKUGgRKGp26ogaMn14oAeW4phakLVGzdaAHlvfimFqjLcdaaW96AHlqYTTC1MLUAPLUwtTC3vUZfjrQBIWpjNwaYW96jZ/egaCR+DVWR+DzTpH61WkfrSYDJGHNVnfrzSyP1qtI59aQ0DvUbN71Gz+hNRs/HWkMczVCze9Nd+KhZ/ekMeW45NRswz1qNn9KjZ6QIc7VE7YBprNULt1qGUgdqgdsZ5pXbrmqzMOeaVykKzc81A7deaVm469KhZutIaBmqMt701m61GW96AHluD6UwtTCw5phagB7NTC3BppbNRluTQMczelRO3vSMx5qNm65oARm6iombrzQze9QseDQIRmHPNQs1K7e9QM1IQFqYW600tTGb3oEIze/FQMe/anM3FQs1ACMefeo2NBNNz70AGetJk9zSUUwFBpwNM70ooGmPFKKaDSigY9enWnA8VGKcKQDxSjFNBpRQNDxilXFMFLQUmPFOHvTRS9s0ikx4IxThTBxSikUmSDil6CmDp70o69elSUhwpy/WmilHtSZaHilA44pBQPapKHA04UwU4VBSJB0604Zpi08dOtIpDxT1qMelPWkNEy1InFRLUi9KhjRMKevTmoxUi9KllIkFOHvTVp4qWMVemaB160nTgGgdKkpEg9KcOlMXPfpUi0gHdRQPSkFLzikA0+/Smn26Zp31prdM0AJ6imnp/8AXpfypDiqQhhoPelpKCQ/DIpRSDvS0AIaYfQ4p56dKYf51RIw1Ge+KkPeoz3xTQiNvr1qNzUjdMVE1aIljD3ph/lTz35qM8CrRnIQ0w45pT04pprRMhoYTSc0p9hSVSIsKOtSxnD1EoParECBjk9BVIktQJuOa1hgRLj0Gayo3+bgjArRtnDcE5qWro0i7FmP5WGc07GFbApMcD2qQJ8h5qLW3NUzNfO4nv3qxAMRntxUcqESkc1ZVN3lxgdcCky0e3fA6wxZTXJA5IA469a9VcZNcp8LbEWfhiAgYLgGusHINCdkHUqTJk/jmowg6GrbLxTNnWsbGiehXK8HIpDHuHANWQnsMGnCMY47U+UOYpiPAxik8vJq2E55605YM9MikkHMVBHuJA7VYhtsnnFWo4QPwqdF56VajcylU7DI4QvTpUuPanqMUoHrWiVkYOVyPbSAZOKlNLEnJJpWDmsLEmBUo4oHSjFapWRk3fUGPpSHpS03tQCQw8ZqNjT26VCzetRc0ihGPvTM0jMKaG4yelQ2apaCk+ppjeh6UvrmoznmlfQpIae4ApVxj3pD7GkU84pbBYtQ9OanSq8VTqBj3q0Zsf8AWncU0HjFA96ogdRz3oFHWmIcOlOWmrTxwKpO5LFoAwaBTs4pkiD0pcUoHHFKBTFcQKOhpQOwpQOORSikK4nelHIpabQIOmaM8c0UE8YoQxOtMPenUw0hpDD0NRHOealNRNgZrNmsRr9KhbjvUjd81C54NRfQ1ihjN78UwsCppjPuOB0pG9qi5slZCMeM0xj29aGztznmoyf5UrjsIT1FREqBx17U5j6d/WoScZApXGtBGbuaiznOSKVznr1zULkbiM9qVxjX6VC5/WnM/UEjmoXOAc4p3Aa3BYZzUTe2aeWz0PNQs2AQeppAI/Tr0ppP0x1oZto56VGxwuc8ZpbAhWJx0FROee+KVvm5A4qOQ+ufamBBITjBNVpfunnrViXqeTgdarvgMcUgRCeMetQuysCQeRT5GO0kH2+lVSTyOOaL9CkGeCDjI61GzfkTTWcrn34pjOMcmkgt1EkYqgI6VA77l5olkIyPyquzZ9aAtoNlcD8sGsyc7if6VamfAwc/l1qjNgCqQirN82eh6EcVTm4cknmrch4OCeOtU7g/LkVpElmbfrkFh1I/OuZv0Pm5xXT3GMEE8GsS7XD4bv09q0i2YzV0YsinPSmY9qtSpgnrUYXnOK1UtDBxIkQZqaMc4HpTkTPSpEADYCnOOaLgkOgXajA4zTVU42+9SxcuQBwKRgQ59+DVJ3E1YaBwwz0qBumD1FWcYfH4VC469KtGdiB6hbrU7jioG64poQqdanj+lQJ1qeOmhFyL7tPI4NMg6VMRwelAipIvrVOfgVoSDrVK4HHuKAKdA6mg96B9aAHiikWndqAE9aY3cU84pjUAMPvTPWnH+VNpMQUnHXk0v1xSduDxSAUU4en5UgwKd9aAAUdKOnTijtQAlGaPpQaAFHNO7800dKcKAEPeomqU+3eo27k0AMo/Gj1oH8qADtSCl7UUAA/nUydOfWoQPzqVPapsBcibjHtVuJsD2qgntVmJqzsBoI3vUqn86qRt61MrVm0BZVuKeDxVdW7GpFbj1qbASg+tOHSogfWnp6ZpWAlWpF6VEvt0NPHWmhEq9KkQ1EvcCpF+lMTLMZHpViE1VT/61WIqBFpD+VWIzx71VQ/pU8bUAi3GferUR96pIR0FWYz3p3KNCF8CrUTj1rORuKsxNTTBGpG3FTo3vVGJ+OtWY296pMZaVvel3cc1Cp4pwNUmKxMGp6moBUidaZNiwvSpU6VElTKKCbDhnFPWkUelPUUiSRacBQo4p4FOxAqjipFBPbrSKKlVTmmkQxoWkK1NjimEU7EkRHFROOtTtUT1NhFZhUL9DVhqhk6VFgKEveq7d6tTDrVVu9TYZXk71Uk6Grch61UlxzjNZtAUpqrnHPHerEveoGrCRSI8Un9Kee4702syhB1oHej8KO9QAfSk7UUUgEpjcU/nFNbpQIib61E3TNSNUTe1MRGe/WmHpTz1phqkIb64ptO9fWkxVoBAPanfrQMUCrTGJzRil59KDVphYT8aSlpKtMQUn8qM0n0NUAMajJpWPvTGPWgpDWNRE8HFOY8VETSKQZ689OtNJpCaaW65oLQjH8qjY+9KxqMn6dKhmsRpPvTefWl7U3saRqhD+tJ/Oik5pFh+NKOlNo4pWEPBpwxTB+lPFAh1GKPpSjpQSJ24oI46UtFAhp5HNFO/lSYpoBO1FLRTASj60UD+tABzRS5HpRQBMrf/AF6lRh2NVQefepEb8q7EWXkbjrU6P781RRqlR/egDRjarCN71nxufwqyj+9Mdy9G3vVmNves+NqsI4x1oC5fRx61Mj1QVxUqScUIVzRR/epVf3rPSSpUk96tIk0Ukx3qzFJ71lpIKsRyGqQjXjk6EGrCScVlxSfWrMcnvVIRoLIalR8jrWesnvUqyU0I0BJT1f1rPWSpFk96aJL6vTw/aqSyH1p4k4q0SXVfHepVfiqKvipFf3poRcDjHWnBvfiqobjrSh+tAi1uo3cVW8zijzPfpQBOW61Eze9Rl6iZ+OtAEpemF6iL+9MLe9AExao2eoy3vTC1ADy/oeaaX96jLetMJoAkMnUVE8lNLcVC7deaBoJJKqyP15p0jYBqrIxwaTAbI/Xmqzv70SNyearu3uaQ0Kz1EX96azGo2btSKB3NQu/vSsaiY0gQFz60xm44phNRsaljFZuTzUTvwaGNRM3WpGgduDk1WZ+tOkbg1XY9akpAzVCzdeetKzds1XZqBocze9RFvekLZPWmE0AOJ96aT700mmk8UAKW4phamk0wt70AKWFRMfegt1qNm9aABjjPWombrSs1QsetADHaoWbrTmNQsaQhCeeajJ9DSsaiY0CGu1QsTUjelQseTzQAmfejNNz2pM+tAC+tHTpSZ70fjTAUe+KdUYpRQA8cUopgNKOlAyQEYpQc/hUYNKGNKwXJAacKjBp4NA0PGacOnvTB0pw6c0FIeKUdKaKcKkpDgfwpwpnelz60FIeD6Uv4801e9KOmaRaHA8U4U0U78agtDwaUGmA8HmnA+tSUKKcKYKetJlIkXNPFRrTweO1SUh6/rT1pgwakTpSGiRetSCmL0p4qGNEi1KnSoR0qVallEi9KeOKYvvTh0qWMcBSgUgyO1OHFSAq/UVItNWnCkUhwo/GgcCikAnFMqT1OaYepx2oQDexFM9hT+/FJ2piY0ikOacRx+NIecimIb06Uv40YpR05oAaelNOO1OPTimHp/KqRLGNzUbd+fpT2PHNMbpVIlkRz/SozUp9KjYVaIIz6mmHvTyD0ppHBzVohkfrTSKkI9KYRVIhkRpAKeRSD2q0QOVeamL4GFGKgzxQjc4NUnoTbUtQNgnFXLSXD4PWs+NgG5qWJwJQccZ/OgpM6KNg4AJFWNvybQcnPFUrRgzDpVtm/ekKegqHqbRKtwpEvI9K0dJtzcanaxgE5I/nVZ23Nlh0611XwysRqPiSJs/Khz09DUM0R9E6FbC00mCEDG1RVztmlUBY0X0AFBGBQ1oSmM7UBeOlOHXmnhalIdyMLTgvpUiqKeEPaqSJciIJ61II89KkVKkAwKajqQ5kargY709RTsUoFUkZtgKXsaMUjU9RDQMmplwBgUyMcZqQYxzSRLYo6UgxQSOxpv41YkO9qYaUtjiomk680MaTEcjnNVnPXrUrPxzVaRuuDWUu5vBDGOfpTA/OBTBnnPU0vHQdKzu7m6RNk49zTDnPNKvJwBSlee1MnqRE0sYFKyEn2p6DB4FCGSx9OvNTKMiokxnAqYcCqRlIcOlA+uaBSZ/KqTIH0uc1GG9adng07isPH4U9TUQPvTgfWqVkTYlXr1pwx3qNT+VPHSqTIsOoyc9KQd6cOlFyRR0pRwKQUopoQUCijigA4pPxo6UlAxPamHpxTjxmoyfSpKSGMeDUbHinMetRsazbNYojY1E44qYkY4qBzWbehtEiK7frUeealY+n41CQOcE1BqhD0xmmMe/tTuc4wKjbgkZoCxCQM9TioWPr1zUzniq8h6njFSUkRux54NQt06c1MenJNV3YAEigqxG1ROT0FSMeD74qI9M980C9SM8dPxpjck4p/XNMbA4FCEMODkA1GeFJ7CnN97jvUZz175oYxrNu6flio2bjnvTmI7YqBm65JwaLgRStjkfjUEhIOamY56ZwOKrSt+dIEivK3JJ71UlJyGB71LcDPXOagbpxU3LSSGlgVwc+tQO2XIFOLEE8H/CoiOcgjmmAyRuarSSc49OtTSN8xxj2qu5GOc0CILluQOeapysSMY6VLKeDySc1DJ93vzVIRXlPBziqknQ4z0qxIcggZqq/3TVpkMzpwcHOKy7tcqc9eua1phkHvWbKM7iR7VaM5GTICy9elRBTnmrToVJzSxjHWtE9DJq5WCnsTUkS4B/M1Z2ZHHFSrF8mD3OKOYaiQWkZLMw/GkkUiUg9DWrZWwPAJ6VDqMHlsCelOL1FKOhlt97HvUTdcVNNjfxUL8H61qjBohk6ZHaqrDmrT9KrP1q0QxU4/Cp4/wqBKmj9KaEXYunNT9qrw8Cpx0oERydDVG46cir0h4qlcdKAM9uvtQPpRJjNMUmgCYUv4/pTVPvTh6jrQAH34qNvrTz71GxoAae9NpTSdqTEH9aKQfhRSAev1pQO35Ug96UUAKPekP60vvTSeuKAE49aXmminCgBwpwpo/OnAUAIQahapiOKhfrQA2ik60v0oATjFKKB+lKKAAdakT3PFRj0p6/hUgTof8mp4yO+arr05qVDUjLsZ/wDrVKhqvF0461OoqGInXpUgPuagX1zUq9KiwEoPpT1NRDrTlNIROvt1qRTUCnsKlU+lMGTLnBqZPSoF/lUyUhE6cVNGagWpU9jSEWUqaM9hVdScVKhoGW0bjirMbVTjNWIjTuCLqGp4zVRDx1qeM/WhDRdjY1ZjeqCNViNuatDNJGyKkWqsTcYqwhqkBMtSoKYgqeNaaESwj86sKtNjTHarCgYpktCBacopQOKcBRYhjlFSKtNQVMo4qkiGCr7VKo4pFFSDpVJGbGnpTD1qU9KjaggiNQvUzd6gc1DAiaq8nIqZz1qBzx1qRlWbvVV+MmrUh61Uc9ahgVpehx0qpL04qzM3XiqcrcGsZMZWl79KrnHTqamkPU1Ce/pWEmUkN70lL2pKzYwpPrR2o7VICUc0cdqO1IBKY3Wn0xqAIm71E1StmojTRJGfemGpCOPemGrQhnej1pfUUVSAQUo9KTvR65qkMWig03tVIANN9eaCabn1q0wFzxTTRn8qYTVXHYRjUbGnMeKiY8UwsNY1EzelKx9aiJoLSFJ9+aaTSE00njikWhCaYTwfSg00njFI0iBPvTSaPr2ppqTVBmkzxxSE02kyx2aUGo80oNAEgNPXmolJp6GkSTigdKaOlOGOaCRRzSjp04pBx9KUegzQhCUetLz1pecUwG0n4U7HtSYp3Ab9KB3p22kxQA38KKft96KAIgwqVGGOaqhvWnBuD0rsKLYapFcVS8z3pRJ6mgDTjkqdJOOtZkUo6Z4qyko6ZpjuaUcnNWEkHXNZSS4PWrCS8cGhBc00k9DUySVmJKPWpkl9TVJCNJX9alR/es9JfepUkqkibmiknvVmOT3rLjkqzHJ78UxGrE/oasRye9ZUc1WY5h61SEaSScdakWT3rPSX3qVJM1Qrl9XqZX46jFUEcY61MknHWiwmXlapFb3qisnrUiye9USXFf3qRXqmsg9akWQUxFsSetOEnvVMP70u+gRbEnvxSeZ7iqofjrR5g6U7gWTJ15phk96rl+vNNL8UJgT7/ejd71X30oagCbdxTC3vTN+O9MaQc5oAkLUwt71E0nFRtIPWgCRm685qF3GDUbSjmq8s3vQNCySdarSScGmSSdearvJSAV361XdvSkaTjrULP1HNIY5mpjN6VGz+hOaYz0ikOZqiZuuKYX6880wv70hoczds0wt78VGz9feo2kHapYJDmbOeahdqa8nWoGkHOc1JaHM3vmoWPWmlqjZqkaEkbqKgJ5x3pZH61EWFACk9qaSB1pu+kLUAKSKYfr0ppYUwv9KAFY4qJmGKHaombvQApao2b3ppbv1ppPHWgAJ61Gx9aUng81Ezc0ANY+9Qs2M09jxULtxj1oJGM3FRk8H0oY03PaiwCHvUTY9aeTxTGosBGe5ooPt0pD1pAHaikooAUUo4pOKQe9MBwpwpg4pwPFAC5pwptLQA9fanCmL0p60DQ8fWnA0wUopFIeDTqZSikykP/GnA0zNLxSLQ8H24p4+tRCnjpSLQ4U4cUwUoqCkPFPHWox6DrTxUlIcPenCmjoactSWiQdactMHQ09eme9IpD1/CpU96iWpU+tIaJk6cU8D0pi0/61JQ5akWo16VIvSoYIkXpUn41Gv14p6+1Syh46c04U0ZxzTxUgAqQdOlMHtmnL0+lIpDvwo+lA6UdqQhKQ+1KcY96SnYBuB3oxgcU7+VJ2PNADDSEelO9qSmhDcdqB6UH9KQ+1AdAPTrTGzT/rTDVImxEfUmoz04qU/rTMVSJZF/SmEcVIf0pvtVoixEfXFNOOlSHGKjPerRDGkfrTG6808/jTT1OfSqRDIyMGm8D605vammqRIwng0inmnN6U0ZNWtibkyfjUsfLVBHjkVMhwR196WwzasJMZHcdKtl8SbsdgKybJv3owePrWgzZcYqbG0HoXroYhBHU816R8CbTfe3Ep6KBjj3rzWfLW6e4r2n4G2pTTJZiOrYz9KhmiPVyeRS01cEn2p/agnYQCpFWkQVMgoSuRJiKtSKtCinjpxWiRm2CincUAZFLjjiqSIuJgUYxS0Hp7UWENpOppT0oTgk1DYyThV5qF5MdDSSv15qqW65NTexUIdycPmjzO1VQ+BTTNS5jX2ZYeXioDKfaoZJeOarvcc8dKTkXGBbeXjrUEkvXmqr3Iz7VC046570ubQ0UC4XBwTTlb0PFURMD0PAqeOQHuMVNxuLLqHA4qQetVo2yOtWIzmqRFh+3PbgVIq+opUUHpUu2qS0MnIjVcHIqUUzHcU5M+lCJY5hUeDjrUxHFNPqaolMhye9APrQQdxz0qMEh8Hp2pXNNydT/OnjmolIycE09feqRDJk9qkB55qFDipF96pMzaJQaO/FIPUUopkAcinKeKQdOelKOnBoTJDpQeRSZ4xS9qdxiDAFITwcUHH40wnrmi40hpOBTGPBzSM/p2prHIqGzRICeKiJ604nio2rM1SGscCoWPFSNjFQueKlmiQwgHoaYfennnoajJ4xz1qDQa3U0w9M4pxPvTTjB5pAQtj8qgbnIxU7jg49arvx1HWkNMgfO/ion984qdjjOOagkxzntQUmRH1NREYyR0p8h96jYkL1NAxmckg5qNuTUpx2pjKO5ODQSRMTj3xUDE98Y96nI756VC3rgUhkbcE1Xl54A+vvU56kmoHYAng5oBEEhwOvP0qtLjHU5Aqw554HaqshwvB60DK8oHIPpVV8r05Hep5M4OSc1Xc9c5xU2GiFiOfeo24Q+vapGPBIFRMePXimkFyu3J5qrJkHg59atSnPB7VXP8QHNCC5VlGemKgkPAAIz61NIcA1AQMnOORVJCKsucYHXGarS8JyevFW5R8xFU5Rk+2atEMoyDCGqVwCEwB1q9MPmYDPFUJTluM4HFWjNlORcoQaijH8JqyvDHIzn1pjQ4OU6HkVXkRYfEhb5VFWhHl0U9Af1qOzJAPHNXUjbAPcmpKSLmn25y/HAqrrcf7hs9RzWxZqQhUgbgMmqGrJ+5fPSmtxSRx8p4BzTJOxH41NOuPoelQ4+THpXTE5mRuKqyjmrnb61Vn4PFWjNkaZzzVhKrp9anSmSXYfepxjHWq0FWgOKAInxz61TuOhq4/f1qncdDQBmy8GmD3Jp8nJqMZ9eKAJUqQdKiXpUq/pQA1iMGoSamk6cdDVc9P/AK1AB6+lJR+NJ1pMQv5UtN/CikBIvpTx0qNMVIOlADW6cUw5qRqjoAUdTnrThj9KYKcPegCRaeOlMX26U8UAI3eq796sHp0qBqAI6cKTtSrQAUfSlHBo70ALjr+lKvWgdM0LSAmWnrnvjiok9qkX+VQMtwkZ6ira4qhE3ParqHIqJASr3wRTh+tMXrTxUAPU08fpUYp49eaLCJVqRKhU+tSqelAmTL9etToe1V0NTIe1IEWVPFPWoUx0qVen0pCsTofSpUPrUC/oalX9KALKH3qxGapoasxGgC2hqxG1VENTI1NDRcjPvxVmJvpVJGqxE3vVIZoRtVmI1QiarsJq0wL0fSrcQqpCeKtR1Qi3HjpU6Cq8Z4qwlMljgKco5pB3py0JEMegqVRxUaVMKtIzY5elOHSkFApkMCeDUbU89KjY+tJkETnrVV2qeU1UkPWs2wGO3Wq7t1qR249qrO3WobGkRytwaqyNwcGpJG61Ukbg1m2UkRStVSU9RU0jcHpVWQ9aykx2IZCcnmoj35pznnpURNYt3GKelFNzx2pM46moYDs0ntSZ/GjIpAOpPzpv9KMilYBc0wmlJ9Kae9Owhh9+nrUZ4NPPvTDTSEM6Uw1IaYcVSQDDTfw4p5ptNCEPrR2pDR2qkNAfrTfelppPBqkNIax9KYT70E00n8atDSFzxTSfemlqYWpjsKW9qiZutIX61E7H1poaQO3rURPvTWbmmE0XKSH5pPzpueOKM+9IpIM00+9LmkoNIoaf0pv1p/FMbA45qTVDDTaccU3mgpB60vHWm0ox0pAOU9cE1ItRD3p4+tITJl9jTx9eajXpT1oRI8e9L2/wpgpRTJHD0pR0oGaeBxQA0UoHXil+lGKAExSY4pxo/KgBlFOwKKAMzd15pQ3FQhutG6u4uxLupd3vUG6jd70hFpXNTJN2/Ws8P705ZaYGrHNzyfpUyTe9ZKy+9TJKPWhAaqze/wCtSpP71mJJkdakVyO9WgNVJ6njmrJSQ+pqVZT60yWbKTe9WI5uOtYsc3ueKsRze9MRspNUyTd6x0mOOtTpL71SEbKTe9WYpsnk1ipJ7mrEctUI2Um461Ks3vWSkvvUqzcdaYjVWb3p6ze9ZYl96esw6g00TY1Vm96kWY+tZazepqVJeOtMRpCb3pwm4rOWT34p4k96AL3mj1o80VQ8w0eZ6GgLF0zD2phm96qGTjrTd/vQIuCb3pwmPrVEP70u/imBcMvvTGk461VMlMaT3oAsNJioWl681XeXmoml680DJ3m96rSTe9QyS+hqu8lFwJnl96rvL71C8nB61Az+9SNEzSmo2k96gZ/eoy9AE5kqNpPfioS/vTC1IpEpfrzUZk+lRl6jZueTSGh7SHnmonk54qNn7g1CzVI0PeT3qFpOvPNMd+KgLc4zUlImMhxUbSVEW96jZuTUjHM59ajLd8/rTC3/ANemFvegCTdTS3vUW73phai4Ehb3ppaoy3vSZ69aEA9m4qJm4oJpjGgBCfcc00nrk0hPH0phagBS3WomahmFRseOaBA7e9V3Panu1RE+9Ahp6U3+VBNIaAEPTIHFMNKTUfNAAaSl7UmOtAB2pKKX3pAAHFIaWj2oAKd2ptOHemgFFFA4pR15oGhRn1p496j708fWgEPHFKDzTBSigpEgpRTB0pwx2qSkOFOpo6Uo9qktD1/SnCminD0pFIUAU8CmCnDFSWhw6U8e1NHWnDPWpKQo9aePxpopVz9aktEi09c0xaev86RSHr0xUiUxfanrSGidaeOnNRKecGpFpFD1qRfT1qNakXuagESKOKev0pi1ItQykPH608e9NH0pwx261IxRSjrxSDNOqQQooPf0oGKX1xQNDe1FOxTKYhPajtS8fWkoATt1pDnNO/nR24poQz69qb2p4HFGO1AW0GH9aYw65qTHFMbpmqTJuQnHOaYemKkI4ph6dKpEtEbCmH61IRxUZ71aIGH60xqlPvUbD0NUiWhp9aYfcVJ26800+/WrRDRERTcd6eepzmmn2rREEZGc01e9PNNpokValU4qIU9Dx2osNaF61fYCccngVpIR8pPpWMG2kAEetadu+6Pk/N2pNGkWaKndCuTgDivoD4NJs8PY2nls18+xfPAu31r6J+Eo2+Ho8d//AK1ZPY1T0O7TqalHvUUYy1SipQmSJUyio0FSitYrQxkxy9Kdxg0gHFOFVsZiAcU4DApOaUD1qk0IO1IelAOaXFK4EdNdsDFSd6q3D4f8KiT0LirsZI+ByaqtKOcEVHczkMRxiq5k4OKxbZ0xjoTmTrk1C8/oagaQ5J61A8nXJ4qLmqjoSyTcGqrzYzzTHkwOSKrFzzk0rmiSRI8xIODTBJ8pBqFiNuOaaWA9eKNR9NCwsmBwTVu3mOeo6etZofPQdKfHJtai4mrm/BL7jOKtRSDGKw4Jccg1dim9apSMnFm3FJxgmpg471kpce44qylwPXitFNGDgy9mgH0quswI61IJB601JWJ5WWk5FBWmQuOc09jxx0rS2hlsyGToTVY5zkVZfkGq0nynjHNQzWI5Gxzke9SqRVNeOv61PE2epFJSG4lpKlVqgTmpFNWmZNEy9PalBqPdxjtTlPoatMzsPH1oHU5NMz/Olz6UIVh+QaTpTc00n0oBIc3HfNRsetBOeKaaluxaViPGCSaRqG96YTmouaJATUZpT6+lRlvWpuaJCN371Exzn0p5IxmmH2qS1oRt0OKZ/DyaeSc9jURNSUtRMdBnpTG74PSnc96jbuM0WGMbpweTUD9COalYjPB71C7cHk0mCImwBx+NQuNxqR+ByeKjPzDj6Ui/MhKk59BUZAxzUr5AOKjcjH4UARY5JPSmknHXinsBwB3FRODjBPTpQIiPOcdKibAGMGp/xqGTOKLAQuOw69qrv79qnc9earydCM80ikQO2WwenY1UZsZA9asvjbg5OKpTEgcdKVxpEUvOcEVXc5GT/KpmwwI4z3qE/higCFvQdPWo3+UYxUrA81E/OcdMUAV5PaqzA/Mfyqy/TGKhm+4KEBSbLEg9BUMgq0w64HBqvKPlINUiWVZCGBIAqlKTtOetW24JHaqswBUnsDVIllGTIDHIrPY53k1fuB8jYqmV+U5xk8VaZnYroPnqcKdrAdhxUcaZlAq4E9KYkMtU3qMjkVs20JVPlxkcVRt0B6DkEZrobO3DKCOKTKWxHBGNxJxnArL1x1SFxuHtWxessMTE8YHNcPqV8Lq62Lkopx1qoasmZSmHyc9qrryDVqbofSqyDhvrXStEcrGEdc1UuOpq6RyRVO4HPBq0ZyIV61OnvUC9amTrTJLcNW1PGKpw1aXpQA1+nFUrnoavN06VRuOhHOaEBmydTmox1p8vWoxQBIvSpk6GolqVKACT7vtVYjFWm6cVCR+VAEH4UU8gd6bxzSCwg9qPpRzigelAhyVKMY5qJakHSkANTKefSm0AIKcPxzQB60oFADlqQdOvNMXp1p46UAI1V2qyelV5MZ96AI/pSrSetKtADqBSDFL/ACoAPUUo470lJ64qQJFNTKeODVcH/IqVCOlSMmQ+lW4GqmlWYT71DAuIfTrUi9PWoVbing/WkBIKctMHTk9KcPakIkU8dakWolqRKLATqalQ+lQLUinikBZRqnT0FVU/Wp1PFSBZWnrUCmpUNArFlPepozUCGpFPpQKxbQ1Mhqohqwh700UkWUPvU8ZOarIe1WY6aKSLcTVfgbjrWant1q3A1UmKxqwt71cjPFZ0DcVdiNWiS9FVlKqxHJqyh44qkSyQU9aYpp600jORIlPFRKaeD61ZmSgjHWlyMVGGxRu4ouQxxPFQuwwaV24NVpX681LZI2V+tVJHp0knWqrv71nJjQrvx1qq7HmnO3Wq0h69DWTY0MkY1Vkbg1JI3XvVWRjWUmUiN26nNV3PHtT2PWoHPXHas2xkTnmo88HmnN1pnr71ABntRmm0nr61NgHZoz3ppPBppNFgH596M8VGTSZoSESE8cmkJ5poPrSE0WEHrgnFN/CnfSmmmkFxuKb+VP4pMcEcU0gIyOKaakIqM00CQ36d6ae9OP8Ak1Gc446VQ0gPcio2PqaGPWoXbr6U0WkKzdc0xm96YzVHuqkxpDi3XBpjNTSaYW65pplWFZjjrUTNxilJ4qJj6U7hYCf/ANdMyaD3zTc0ikh2eMUZpn1oHTvQUkPBzR/KkX60v15FK5okBpr9CBT8e1NPI4pXLRCevNN/nTyO+KZge9MoO3XNAoHoKO2KQhwpwplOWiwiVPenrmmLUi+9NIkcPbr707tTRTgOKZI9fenD2NMX3p469KAHdvrSU7uaTtSsFxPYUn4U6k57UguJiilooC5z+RRuNRZo3V3GhJupC3HfNR5pN1AEu6gNiod3vRu+tBJYD470olI4zVbdRu4oQF2O5x1PFW47kMOorGDdTThIRzzzVoRtrOPWpFnFYYlOOSaljmPcmqQrm7HL71YSb3rFinBHXmrCzcdaBG0k3vU8c3vWGs59asR3PbNUhG7HN71Zjl96wo7irUVx71RJsrL3zUqzVlJP71Kkw7miwGoJfenCas4TD1pROMdapAaize9TRz1jrPUizcdaYjaW4GKeJxWOJvenpN70Csa/mik8wc4NZ6yinCX3oCxe8z1NHmCqXm+9J5ue9FwsXvMo8ziqPnD1pDMKdxF1pOOtRNJxVQz+9QtcdeaBpFtpOtQtJ71VafqM1A0/Xmi4WLTye9QPJVV5j61E01Tcdiy0lQs/HFVmmphm96LgWWb3qJnqu0wweajMvbNICwX680wye9VzL71GZfegaLW/1NRlu+eKr+aexpDL70ikSO3HXmoWb1NRyS9agMnfNSMlducVCW96a0nFQNJzUsCZnqIt71EX9zTSx/GpGSFvyphamFu/ambuvNILjiaTNM3ds0m6gZJn0phNJng00mgBS1RlqRj71GWphcUtgdaYWppPXNMJ9+lArik1GzUpNRt0oENJ60w0rUz8aACmk8UvrTDQA0/Wk7UtJj0oAKSlpaAG0cUtH1pAJRS/Sj3oASnCk+tKKaAXtxS/hQM0D6UDQetKtGKUUDQo/SlFIMUooGOSnDimrTxUlIcOvJGKcOaaPenL35qS0OX2p46U0U6kWhQKcvekA96UVJSHClHegUo6VBSFHXnFPWm0q/1pFolX605f8mmJ1qRelIaHj9aetMFPXvwKRZItSpiolFSrSAev6VKvao1qRc1AyRaeBxTFxUg9qgpD1+lOGKaOlPHpUsY4fSlUY60g6c04VI0Hr60Hp1p2KAKAGdqQ0727Un14oAb1pRyTQOpp30pgNNJjuKfjtxSY9KCRmOtJin4GKO1CERketRt6Z49alP8AKmN3xVJCIWHPXio+OalbNRsParRLIyO9Nb61IR+VMPfFWiWRkGozUu044zio2xVIgbUb9Kk7UzjbVp2JaGdqYaf65qM45NWmRYaaTtRn86D70xDR3p6HmmjrQPbtTAk3fMTmtKwfdGQeo5rKz7Vas3wxAokhxfQ3LNiMLuHJr6S+FYx4etznqPzr5kt3/eDb6ivpr4UEt4YtycZHFZM2id1EfmNSr1qKMc81KOtSJkqdalWo06VKo71pHYxkOHTFKOlIKUVaIF5pOlOFNHBxQhIUUE4GaSkY9aLgNJ5qpdcE1aY96qXmNuc1nLY1gtTGu3O8moC3HHFM1CdY2JJ6Vht4isom2zS7M9N3Fc7aOtJtaG4zHFROc9PSoLa8iuBmJw6+xp7nuBSaZaI2PvUTfWpCBzioZOASaS0KIZGxnkVm3ur2liha4mRB9ayvGWry6bp8jwZ8wjC+1eJ3dze6jcPJdSuxJ/yKuC5jRR0uevXvxD0y3DeWskhHGRWLP8UrVHGYHA/3hXnX2Y+SykHJ7+lZ93YkgtjtitlCPUHfoe06H8TdLupAk0ghzx8xzzXe2GtWt5EGt50kX1Br4+nheEnGRg544q1o/iTUtHlD21w4APIJJz+FS6Sexm5dz7GjuN3QjFXIpmA61438PPiJBqu23vGCXGAOT96vVreZXQEY6cVg04sVk1obEc+B14qwk/HWshJOMZqZJT2xTTYuVG3DNxyasiXKcGsSKfnk1aS4rWM9DGVI0Nw61E/Paoo5cnk1MMntxTvdGfLYrvk8gcA1JHxyBUmzOcU3bwakLpksbHHNTA1XTocmpVbjirTIaJVNKWx0FRg0oyRzVXIsSg+tKD6dKYMY5NGcDjmqTJsP3egNJ+NMDZoJz1o5h2HZ4phPrQaaTSuUkIe+aY1ONRsagtIa57VE3FObrzTePxqHqaLQjIOeaa3pk05u5NRnpk0XLSuNbpyOKj71IWyO/SozwCTU3HYjI5IB4phbk9KkZsA461CeCcY6UXAjbo3PWom4696kYjdjPNQtkk96Q0iJm9SSKYxGcDPNObpj0/WoyQWx6UDE+uajYA9O1SHr1NROc/1oAjPTHtULZxUrcdc1G/PU0gRE5Cqc8nNRu3TPQ09+SeenSoZCB0wRT6BYhc5OO+aryHGSTnip3IJIOM1WOeQTUjWhA5yvOOaqykhBjse9WmUDr0qrOOo7UhrUqgHcc9KYcAkirJXCEH+VROvQE9aCiE/d6VCygLx1zVhugxUMg9OaCSsy55PWo5Fyntj0qzIBtxUbZCkcYoSFcpOp5IPFZ85wSMmtKXocGs+4BXqKrYRTfgY75qrKoXrk1Zc5OT1HtVeT5nJOapEtlCcYXAqqy5HSrs/MhBqs+eMD2q0S2RRrhgeM1ZGQOetQDlhxVkkYGR0oJRNZL+857810luQqYB5xXPWHMpJHArbVx7YxUspGF4vvvs9oyg8tXC6ZKXlb3Na/ja4Z7kR7uKxNL4l49a6KStG5hUleVjYuBhO9VkAAPrVy5X90CO9VtvDfStUzJkTdCfaqc9Xj0z2xVGbuKtGciAdamSoR1qZP/wBVMktQ1ZXpVWGrSfjxQAP93FUbnPPpV9hwao3PegDLl6mol61LN1OaiXrQBOlSJ79ajTpUgz2oBCtUbdcU89KYehx2oAjbpUdSnpTD60gsN9qBS0CgQqjuacOnNIKdSASij8TR/kUAL7ilHT3pB/KgfWgB4p4qMY6+lSCgA7E1BJ3qzjg1DIvFAFf1pyjikP1pV96AD60vHvSfWjFAB0pp707tSdjzRYBAQe9SxkZqEfWnoPQj86gZbSp4jVePNTxn3FTYC0p9elSr7YquhqVTx15qbATL+tOHeoQeOtPVuMYpBYmU1Ip/Wogc09TSETr7YqRM1Cp4zUqfrSAsIeKmQ8VXQ1Kh9c0gJ1OamQ1Ah7VMv60gJ0b6VOh/Gqin9anjNAFlTU8Zqsh5qdKBosxmrUZ4qnGRViM8U0UWlbmrETVSU1NE3NNMDXtn4q/E1ZUDVehbirTJsasDVaVuOtZsDVcVhjrVJkWLQanBh61VV6cH4qkyJItBqduqtv8AelDj1qkzKxZBz3o3cdarh6XeMUXJsSO3BqpLJ1p7ycGqU0nXFTJkDJJOtV3k680kj9aru/WspMY53461A7dfTFIz9c1C7Z4zWTYJDZG61WdutSMevNQtg9c1m2UiJvxqF6naoX6GoYyE45zTf50896YRzUsBuBzTTTzTT0NIBhxTM049KZ69MUgFzSZ9aToM9TRn600SOHoaAeppoPPNLQAv40e9FA6U7BYSg9+KX2NBHXFMCM46UxunFSke3NRsPfmmkNIiPQ8daibpUp61C/pVWLSIWPr+VQO1SvzmoG+tOxaQwnrUZb8qc1RtQOwhb1ppYc0hPUVET15oHYczc0wtSc/hSVSY7Cmm9qXt1pPpQUkJ9aXvQBxSgUmNIVacKQCpAKktDcCm4/OpMYzSY4zQi0QsPSoyKsEcUxlNUgIKAOCaeRSAH0oAB+VKv6UmKcB+NCEPWpV96jTpUi+3WmiR496Ud6AOKeq8d6aRILnvUi5NIoxz2p4GKBXEFLRilAz60WENxRinAe1AFTYY3FFLj3opAcln3o3cUzPU0hPFd1jQfupN1MzSZ5osFx+7ik3cGmZxRnnrxTsIeGpd3BNRZ/KjP5UJCuSg8UBj61HnjNJnjrVJCJg3NKH981Bu55oB4xVIRaSbFWEuO2azgeKcGoA1Vn96lSb3rHWSpEnx3qkwNuOc9jVmK4rDiuOOtWEn96YrG8lxx1qwlx71gJPUyXBp3JsbwuOOtKJ/esYXHHWnC4p3A2Vn685qRbj3NY6z8VIs3HWi4GuLj3qRLnrzWOJ+Kes3v1oHY21ueKeLn3rGWfjrTvPouI1vtR9aT7VxwayDP70ef700FjXFzx1pDce9ZQnx3pPtHvQI02uPfpUTXHXBrOa44zmomuOuDQNI0TP6mmGb3rO8/wB6YZ6LgX2l681E0lUjce9NM45yam47FppOvNR+Z71X80UzzKALDSUwyd81A0gx1qMv+tAFgy+lNMnXmq5cY70wuPWgZZ8ykL1UL0eZ70ATu/WoC4phfg81GzdeakZKzcdahZvSm7qYW9DUsB5b0NNLdaZn3ppP5VICluKTd60wmkJ9aQD9xo3VHnjNJmgdyQtTC3Wmk0hpgBJphNKaYelACGmmg009zQAnbimnp70ppjelAhpz6ime1OPFNPegBDTTSmm+1AB7UmKO9FA7ABxR9aP50vtQAnajFL7UoHrQA3FKBS4oqQG4pRTh0pR60wsIB1pQKXp60tA0hoGKcMUtAGKQ0hO9KKWgUDsKKcPekFOHvQ2NIUc9KeOnFNFPHTipuaJDh70vekHApRSKQo9acKbTh3qSkOX9acKavSnj1qC0L/OnCkFOX9aRSHL9akXpTVp49qQ0OX0p6+lNHPSpFqSxyj0qVaYtPXNAWJFz3qRelRrUi1DGiRelPX2pi8CpF/WoKRIOOtOHPamjpTxUsaHLTh3xTVp6j1pDFoA4pR0NKBQAzHFN7nNSEdhTTSAbjmj8aXHcUCmgA9fak47GnDp1pOMU0SJjjApD6Uv40nbvmgLDT05pjexp/wBajYdapEkRHXNRe4NStnuKjPfFUiRje9NPQjtTm59KYfSrRI08ZAPFRNzUhx3HNI3oKpEEXY5phqQ0w1aJuMPvTCOKkP601hxxVLQlkJ96Q9xTzTPemhLUSl4pKKpCDualgOHzUR680+PrmmNGnbv+8BHtX098IX3eG4vY18tRNtcY6cV9Q/Btg3h1OO9ZTWhrFnokec1JjmkjXrTx1qBNj46lHtUa08VaMmOFOHsaatGTVpkWFz2OaQe1IzYpoOaLjSH55pDTc4ppPc0rjSFc1TvstCcVYZs1C/zIwOKiRpFW1OQ1UEo+Twf1ry/xpZu9q5QHK85r1jU0O91PUGuS1mzEisCMiuSSaZ6NFnkuj+Jr/Q7lSsjNECAUbpXrvhvxRa61bq0bgSY+ZCcH/wDVXm2u+H0JcoMd65ASXui3fmWsjoVOeD19qcZ30ZtOkmro+lNwYVFKeDXG+AfFJ1q0KToUmjxnA69a7HOQcZxVM52raHP6/Yi8iKOoNca/hnbITsFelTKCMmqbxKTkgU4uw1J2seet4e+Xlf0qrL4e+U4WvSPs69CoprWakH5Rj6VopJj5jxPW/DzqjFFJ/CuNvdMlRiNjH8K+jLzSkkBwBj6Vh3XhqJ2PyDJHpRzNBdSR4PZ297bXSSW6Sq6kEEA+tfRXw1164utNijvwyzL8uSOp4rKg8MxoeYxx7Ct7TdOFuybMrhgfwqJy5iVFRR3MchIyfrTvP2jrWYs3HU5xTJJuOTzUdBR1NcXYHTFSJfqvVgO1c81yqryeaZAZbqdVXOM8VPMy+VHcWEvmnANbMSjGM9qy9HtDGi564FbMa10U1ocFaWugKvHPFNZOSfWrAHqaRxkYFa8uhgpFIqAMc0qnHAxTpVxk5NRKfWs9jVaolB44p6twc1AG5PvUgbimhWJA1KD70wUvsaaYrCilJ4ptITQFhee/Smk0pbjtUZYYpNlJCk00nijPFM+lK5SQjGozinU09ehqS1oMYcUxsYIp/PSmnH40mikyH7o560jEYwKe3TFRkYyeKnYrcjYHBNRseCAPapSOMEmomz0A6UMLldgAeM5pjHjjHWpJBnmoXBFIZE/y+9MGeTUrZ7ioyPlIoAYSccmonbgg9e1PPAzjmoyeM8cUAhjkd84qF/r0p5bLHB71G/c560DGMAGIz/8AWqrOQAcA1OTzk55qtKMknJpAiJunNQvnHHepfXP4UznBJ6UIdyJ+R71XZRg5xVh+Tzj2qFgBnHXFAIrMCfWonAU55J6VYfPQ9OtQluT04qeoEDEHqOnSmYAJzUrc8nFRsCCcnjtTEQHBzx9KgcAcZqwy85OPWoG+9nnkYpoRWfDKc46/nWfdcjANXn4DEnOKoud278qYupUfJXPHSqkoPWrTcFgTkAVXl5UheOKpE3M+Xkk55qswyQMdKsyLtGD36GqrAqTznirRI1T83v0qdshDjrxVVCGJ9c1OSQp5PamI0bPK4J6kVoyOEiI4rLgztU55wKfeykIFBJJqSrWRzmv6dLcymaPkdaxYLdopAe4Nel6ZbpLZlio3dOa5bX7LyZTJGPqK1hK2hjOHUqTcxqCRg4qt0JH4VMHDQqe461EeW49K3RixjfcNZ81aLjA46Vmz9TVxM5EIqaOoB1NTRmmQWoatp/SqkVWk6UDQrdDVK571dbpVSccGkBkzdaiHB7VYnHPHFQAc0wJV6dKkHSmLTxQAdqYc+9SdqY/Q0ARt7Uw45pW6YNNOaQXClWmU9fwosId2pf50CgcdqLAFIaD79KWkAUoxzzTR0pRQA4VIvSo19ulSrn/9dADh0pjjr708H86Qjg56mgCo3XnkU1eM4p8g5Ipo4oAXtSfTNKPyo60AJTDjBp5+lMP6UAIPWnp/M1H3pyn9KljRbQ96nQ1XiPGanTgfWpHYsIakU8Z5qurc1Kp44pBYmBp6n3qEHtT1NSFiZT/nFSp9ahU+tPXipEToeKmT1qstTRn3pCLKkVKrelV0PFTKaQFhDzU689KqoanQ+9IEiYVKh96rhvWpUNAy1H9asoeKqRH3qyh4oGizHU6HiqqH1qdTxQVYnWpoziqympkahMLGhC3oavwNkYJrIifnrV+Fu+apMVjVhOKtI3FZkUnoatxycdatMmxcDU4NVbfSb6aZm1cthvegNVYSUnmGquZtFoPx1pDLwfSqxk/OoZJsd6LkNFiSbg5NVJJveoJJuTzVd5PeocibErydeagZ/U1G8nHvUW+s2wsSl6jLcU0tTc/nUBYXNMPQ4p1N7VAyMj0qJhwTVjBNRleKmwFU4zTcdanZR2qIipsBGelMNSEfSmHpz1pWAifpxUR/nUz96hPBNKwCfQ0gOenWkJ60mTiiwDwaUHtTAaBTQrEg6kUo/SminDpVILDhxSfTpS9qABj6U0gsNOec0xhx71JjrTSKpIaRXYYqFx6VZcdahdepqki0VHHJqBh1qy4weneoGHXNFi0QMOKhb9KssB2qBwcGiwFdv0ph61I3tTCPyqSxh74+lH1paKaATHXFJTu9H0pjQgFKKB0p4HFJjTBRinj3oUU8D1qbFpjcdu1GPzp4pcDNNIZHimFeOamxSbaLAVytM2469atbfWkKdaYXK22hVyasBKcFx2oSFciVcZqVR7U5VqRFqkibjVTjFSqlPVKkC1RNyML7UoXripQvrRtNBLZEF4pQvFPC8kUoGKVguM28EU3FTYppHoKloLkWKKk20UrBc4bNNJphb3ppau82H54xRuqLPvRuoFckzxzSZ46803P0pM07CH5pM8U3PvSA+tAXH5ozTM+tGeetNCJAfegHNMB9elAPfNNASZ/OjNMB75oz70APzRmmZoz700BIrkd6espFQA07NO4FyO4I4JqwlyPWs0GnK1FxGqtwKeJx2JrMVsdDThJxTA1UuPU1KtyPUVjCTtk1IsvHWgDZW5HrUguR61iiU4o84+tAG4LkeopftQ655rEEx9acJvfNO4Gx9qGOtN+1DPWsgzds00y+9FwsbP2r1NM+1CsnzuOv60nne9Fwsapuc96b5/vWZ53vQJvei4WNXzv1ppk96zxN70vne9AWLZk560hkqr5uaTzKALPmUhk96reZyab5nvQBa8w+tIH9TVYOMdaXzBjrSAsb+vNNMnfNVjLwfSmGSlcCwZBSF6rb/ek3cnnpTAs78+lNLcH2qANxwaXdSAl3U0kVHu468UmevNSCHZ96TOKTNJnNSMQn1o/lTc0UgFzxRmm0lMBc0lHv3pPUk0DQd6Ye+ad2ph6UAIelM9c9acevFNJ+tADT3xTW6U498/Wo2oEN9aQ0Uh96AG96SlPtSdOOaAENH86KXPFA0IB6U7mjvQO/Wgdg/CilFH8qBgPelxQKWpCwCgUClFA7AP0pR+lApe3XIpDsJSj9KUUYz9KAsAx+dGKMdqAKBgKetIKcPegaQ4U8U1fwpw6cCpuWkOHvQOnNA6fSlA4+lIqwv0oFApw96ljQq1IvT2FRrUq561JaFHSnD8aSlHWkUh4qRelRr+NSLikND1x6HipFpq9frTx9akpD1/nTx7UxRx71IuO3agoUVKtRj1qRelQwJBUi9ajWpV9ahlIeop4+lNXvmpFyB7VLKQq1IPSmr0p6j6UgFAoFKOnanUgYz1qPtUp4FNIoEMxxQOtLil7Yp2GN/lSA9c9KU0h7570XEJ60hz7/AFpwpvemgsNNMbHSpCPT86jbvmqQiJuM1EfccVMe4qJunvVIhkZ9qYeKeaae+apEDPrTeeoxTumabVpEMY3Gajp7Uw1aJG9vemmnnNNx1zVIkjboaj7VIaYetNCEFJS98d6QDvVINhDmnp1pnenCmgRZhOcD0NfUHwRYNoCrk5AFfL8LbSCD0r6J+A+qCayeFnGVA4qJrQpO2x7NH3zS45pqmnr9c1mA9eDTuc0gxil/WqRA6k7Uo6U3tTTEJ9aM8YoOaTOSaV0NIDUbH8qcfrUbHNK+haQ1qjB5OaeTxikAqb3NEZWqwbhvA56GubvYuDkCu3liDoQe9c3qloVYgrx1FZ1I9Ua0Zq9jir6yWTO4DngVy174d+0SkAcZ9K754TuII71JDbKW6DrWKWp2KfKjO8KaBDp1p+7QCR8E8elbgh2cZq6kWyIAAdOtRSDjk1tyqxyuTkzPlTrg5FVH68A1dlxzg1CyjnPSpZaehCikHkdamVcjHPShenTIqRcZB5FNE3KxiHJ4/wAKRYATkirYTrtpPYDrVpiuVPIABPHHShsKOSOatMvH0qGSMyY44pSemgIqTXIRQFyaqNcyP0U1o/Yi5ORVu1sF3jgZxWdrmikkjKt7KWdhuB5rtNB0nyNpZeak0jTQWDkcduK6e2gCCrp0u5z1a9lYW3hCjkdKsBR6UqrxxTsCulRsjhcriYHpQRzS4o+vWmRcqzLjNU2ArRkA5qhIvzHis5I6Kb0GA98/nUgbnpxUGeSM09Txyc1KZpYnX2NODeoqFW9KcG65pomw8njik+lMyfwo3ZNFx2FYjGM0w+oNKfSmH1FSNICaTNNzmkJ460JlCk8Gmk0hbk0mfXrSKsGeOTTWNISelIe9FxrQaehziojnJ9alJGCKjPr2FR1GM9d2KjZuCBTzyDxxUTe1NARNioHOAc1O4J+tQsOx7VOxSI+2eaYx69c1ITyeahbGDg80B1I5WOcdqhf5fSpWP1qCQnGR06UDGMMZxUTnK4Jp7MSMVE2c9OtAEbNuPToKgZvzNTNwCMioccHB6UgIu2DUbenPJ4qQnrkVGQcHJoAjfpxUMijrx0qZunJqFsAYpMdyA5II9OnvUW3Genqank4HAqB845+lAbleTrwe/NMk+vapJPlBPGajZgYz60BYhbpx1FQSZ2nmrDfd7ZqvJnGKZJTddqnJyaplfvAde1XZyMYPT6VTb5XJ7imthdSo/wDEKqSAFDjqKtOBuJHQ1WlAwfWqS0JZRmY9ulUpjgYq5IpAyD3qrN8xz3q0iSBRg8Gp05IB78VX/jxUsbfvAPTiqsSbCKPkx2AqO/TY4zyeKvQQFog6qS2BimX9u3DMDkYH0rJas0a0JdEJkjZT65rM8SxFELEHmtXTAbaMyk8E1V8VMGsiwzVxepElZHGoBtam47ilhBIYnuKF6nuK6o7HLIjc8Vnzjk1oP3qjOOScVojKRVFSR8Gmf409P0pklqHrVpKqxdhVpOmRQA49KrSjI96stUEmO9AzLuF5PFVh1q7cjr61TA5oESrTh9aatPHf1oGKPwpsnANSDpTJRxSEVm9ab60402gBtPXpTR6U5aAHigd6B370Dv8A40AHak4pT65GKb3NACj3pR+lIKcP85pWAcvNSLwMZqNeealX6UDQopTR+NHY5zigCvOp6gfWoO/WrcgyuT+FVcYzijoADpS9v50gpfUZ4HWgQh9O1MNPPTNMPegBlAozSj07VI0WITxx1qyp/OqsXSrC+vFSUiUepqVDxxUI9zUin8qQ7EymnqffpUSntT0NSFiZT+VSKahU8deKep44qRWLCnjjtT1NQKalU80rEllW/KpkPvVVD61MjUCLSdKlQ1XU1KhqRosKeKlSq6n3qVDQBcjJxU6Hjtmq0ZqRWoGi2h96lQ1VRqlVqCkW1b3qRWqqjVIGoGi7G351aikwKzEarEcnvzQmOxrRScVail9KyEkNWY5apMmxrLJkdqXdVCOSp1k4qkyGiyG96Xd71AHpC/vTuZtErPxVaSQ0jyVXdx60rmdhXaoWfqaY7+9RFu1TcgVmzSZpmeKM1Ih+eOaM0wdOtAqRXHg0UgpR+lIYvakI9KVR15pcUrAV2HJphHX1qyV6+lRlamwFcrUbL1q2V/Oo2TjmlYCi44NQvnHUYq1Ig56+9V3FKwyDP5U38acabSsIUfzpR700dKcOnvQgHDNPWmLTlqkA8fnTvypF/OnVaQCEU0jrT/yFJ2xVJDREV9ahdeDVoionXqadikUnXrUDL16VeZeuetV3XrgUykVGXjNQuvXirbL3FQsvXFSNMpstRFevJq4y8VEV4OOlIpFXbikwasFKbsoGRAcUY46VKF9qUJQFyJVp6rUm32pyrjtQNMYBx0p4FPC47U4Ciw0yMDrRipMe1LtosO5Fil2/rUm3nigL7U7Bcj20bR+dShaXaKAuQ7fQUoWpQnWnLH607EtkSpmpkj46VKkf51MietNInmIlTinhKmCU5V9aaRNyHZxRs+tWNtGzvTsTzFYx0hWrBT2zTSvHIosK5XK+lIV55qVlppHrUtFJkeKKlwKKVh3PMc0ZpnrS12Gw7NLmmZpc9aaC47NGe2abnFIDQIdmjJzmm0ufWgBc0me1IKP6U7gOzRnjmm5pM0ASZ96M8VHn60uffii4D8+9Ln35qLPvRnmmBLnilB9s1ED+dLuouBIDxTw1Q7uKA1FwJwx7UobjrUAagNRcCwGPbNOV8VV3Uoftn8adwLXmcUnm/lVfdxSbjmgC0JqPNqtu96A3BouBZM3vTfNz3qvuoz70XAn8zjrSeae3NQ7hijNFwJ/M456UCU+tV91G735p3AtrIMdaf5tUQ3vShzii4F3zOOTR5nUZqnvPc0bzRcC2ZOOopvme9Vg9KG96LgWBIfWl8z1qAGlB96QEoY/hS5NRZHaloQD89aM800HrSg/lTuA4H1oyehpue9APFAD8/nSbv8KbmkzUgPzQT1pmaTPpUjQ7PHHWkz6dqbmgdD0oAX8aTIpM+tGe9AC560mRSUntQOwZ96aTSn6009KAsJ9aTNBppNAWAng0w9SKU0wmgkT15pPpR25o/CgBPxpOKX2o9aBoaPSgUduaUUDQfT86cB9aFFLzQNIT6UAcU7HpSYpFB0opQKMUgsIKcPSkFOFA0g/GlxxQPalpXHYO30pcUAelOFA0huOMilA4560o+tL60BYaBTwKQe1OGMe9K40hR6U4dM00DPanD0xUXLSF4pwpuKd60XKAdD7U4dOlNHtTgOM0h2HDFSD+VRj+lPXpUjWg4fzp646U0Yp60hj16Zp60xelPWpZSJFqRf0qNfqakX0pFIlUfWnKOKjXrUq0mUKBUg9Kav0p46VLAelSrUa4xUidKhjRIv61IBTFp46YqWUh6j1p47cUxc1IOlIY7Ht0o7fSgdOKOaQDabj3qXHHPWmY45p3DYZjtSgcU4YpQPei4DAOxpuOeKfgd6TFAEeMcCk7e9SEUhHPSi4vIiPU1Gc1Ow44qJh+lNE2ImFRt0qQg89Kjb61aJaIjTD+NSEelRN3q0TYaetNPSlOeaafrVohjW9qYf508iozVIjyGn0pfpSUvarRNiNhTCBgnvUvPamH3qhWI8d6TH504560h6U0Ib35pQe5pp9qAeKYE8Z+QnAz2r0n4Ka0bPxAtuzACXAGfWvMk9K1vDV4bDXLSdSfkkXPbPNKSuhpn27bN5kSsfTNTisnw9eC90qCZMYZQa1lrFeY7jxSjpSClFMQZ4o7UUHpTTENJ7mkJoP6U1qTKSGE8Goy1ONR9eKk0SH9eM05Vz06mkRRmpkHNOKJk7CbcCoLm1WaMqw57VdC0bau11ZmfNZ3ONu9KkjkOFLKaWz03BJYYrq5EyDnB/CqrxbckDrWXs7HQqzasZDw4T7vAqnPH8pIrbkTg1RniG0k0NDizn5kw2SOtRBSelX5168dKjjj57ZrKxrfQgWLg4A9qk8rLAdvWrqxcY4/Kn+USOOlUkxXKBTDfL9KCnPGferbx44z39KBEMnBNFrCuUzBk+tOaLAGAKumIEcd6EtzIQoB9BRawrlLyz/CPritjStPY/M/f2qew04q26Qcda2oYgB0GB0qlEidSy0HW0QRQB2q2g/IVFGMVOlbxSOWTuKPalGKKX6irMmIBjvS4H50D2pKAQjLxVS4TNXDUciAryKhxuXCVjJZSrHNIMhvarM6e3FQYx+FYWsdSd0KGAzTt2Rx1qNW9MY70ufQ1QD88HmkDcHFMz6Gm7sdTQNIeTkUmaZuBHGabn0pFWJMjtUZbjFBpMjnNTewIXNN+p60hzjikzx1pFAfekPfNAPB5pCfU9aYDWzzjtTG9qXPByeKaTgZyakBpph6GnduTUbe3OKaAjbOCPSoTndmpn6EVDwO1SxkTc5z1qJs85NTMO9QtwKQ7kJ4U5+lRHPIPrxT5M468dajJweDxTGQk881HJwcgmpHwQcHv6d6jONvJOR1pdQZExyCAKhPTK4zn1qVsfrURULn3oDoMbBHTjrmo37genFSkcEYqMjGaAIm6dsioH6e44qduhqBuhxQCRFJjp3qBssOKmbuW61ETg9eKQ9ivJ83B7VFtH6VO/fAOM1A33eTSAjPzA9zUDjg+1Sk8VBKdo+vNNC2KkxyDkDiqUh65PFWpmHIFVJiOg6gVSIKr/e4qtN94n35qzJ0ByPaq8rADB6mtEQ2U35JA71ScHcQw6cVekxhgOuRzVeQ5HzY+tNIVym6/Nx2p9orSXCovUkUOOCRVzw5Fv1KFSMkt+dX0BHfW1j5NouFGAMnNZoAcyRtgrnI4rtjYBdPCkfMQBXPTaUVdjHnIrBaMtST0OXaUWwmiz8hP6etYvie4X7GAr5ya67WtPaGDzJoflIxuFcP4mgMZj2kMpXP41tCPvEzfu6GJAT69qVepGaZCPmwTjinJ98getdKON7Ct90juKpzDg+tXJB1AqpN3q0ZyKJ6mnJ701vvGlj60yS3FVyMcYqpF1zzVyPGM+lACnpmoJTwasH+dQy9CAKAM+eqeOeelXJxwaqnrigYL9akXpTF/UU4Z7dKAHj6U1+nrSj0z3pGxgjFICsw5OKjPQjFSP1z+FRnvQIVf1p4HHfio161IOlAC0D6UdaPWgA+lN+lO/nTfrQAv86UYHWminDvQA9fapRUa4NSr93kc0WGLRQOnNHtSAYw4I4qqw5q23Q/SoCD+FAEeOD6UuKXFFAhp96Yc98VIRxTGHU0ARGnUEUgxzipGiWH6cVZSqsZwasRt+tSUidevanrUa+1PU9+1IokWpVqFCMZNSKTz1qbASrT1PeosmnA8fSlYlkwPFSKfyqup/WpFbHFIksKamQ+/tVZSOlToaLCLKGpkNVkPrUyGpGiwpqVDVdfUmpVNA7FtG44qVWqqhqZDSAsq1SK3vUCntT1NBSLCsMcVKjVWU09WpDRbU/nUqNVVGqVDSKLiNUySY71TVqkU00I0Y5fU1Osgx1rLVzUySe9UmQ0aIkGOtBk4NU1k96XzOKq5nJE7P78VA79eaYX96YScUrmTAt3puaKKRmH0opO/FLSJDpSgUgpRjvSsIUD608CkC8VIBzRYAUU4LkU5V4pwWgaItvtSFeuan2+tJtqbDK5So2XjrVnb1ppXilYaRQkTrVWVMA1puntVOdcA5NTYaVzNdcZOKYR+tWJBVc1I+Ub/SnCk/CgUBYcucc04d8CmjntzTl6daaFYkU09enPb2qJakXOKtCsP7UlLilFWgGY9KRhTwKCOKZRWZQKhdOtWnHHrUJFAym64qFlq66+1QsvPalYaZTK/lUZX8qtsvoBURXqc0WHcrbRSbanK0m38qLDIQtLsFS7fbml29qLARBaAtShaUDihIVxgWlC+1PApwGOlMdyPbRt+tSYxS4pWC5HtoCjtUgHtRjmmFxoWlC9hTwKeq07CuRqlSKlSInFSqoppCuMRPyqVUqREqVU46U0ieYhC04JU4j46CnBKdibkASjZxmrIT9KXYB0p2FcqbKjKdeKvbBjjFMZKAuUGTj3qMqfSrbrUZWpaHcr7KKsbBRU2C55Dn86M1Fu5NLu+ldKOskBozUYbNOzVIQ/P5UZHrTM0ZoAfRmmZ9aM+9ADwaUn1qPPvRmgB2aM0wH3ozRcB+aM0we3SlBoAdR9abmjPoaaYDs0Z9KZS54oAdmnZqPPalzQA/NApoozQA7P60fSm5oB9KAH0ZpmaCeOvNAD80ZpmTijJxTAfmlzxzUYPqaM0APzxRmmZ/KjNIB+ePeimZpc0wFzS59Kjz6UuaAHZpQaZmlFADs08H1NRA04GgCQHFOBqMGnA8cUASA/rQOlRjofWnA9qAJM9qB+lNB96AfeqAeD6UU3P1o7UAL+NJnnrSE8YpM1IDsnvRmm5469KTJ7VI0LnApc+3NMBHrR9aAHc0Z/Wm5oB4oGKKTNITSE+9ACk0wnrQTTSfyoAXNNJ4pM9v60maBBmmE0p9aSgQfzopPrR60AH40hpfek9etA0J1pR/Kl/wA8UCgaHL0pe1IOnJpec0FJBS4FA/WjtSKDpSgUYpeKQxB6U5cdOtJThQCACl4pQKXtSKQg65FKKAPSlxQAmO1OoFL245pDsJ2pRSige9IpIUZ7UoHrSgccUoGev8qkpAB7Uo9zRjril96RQg/SnD9aSlHTnrQAop4pg708VIDxT19qYtSDNIY4etPH4U0U4VJSJF6YqRf5UxRxUg6VJSHrUi5xUa461KvsaBj1H1p69OtMFPX3qWMetSLTFPPSnLUjRMlSLUS9OKlXOKkpDx7U9elMXtUiZ6Uhjh3x0oH0pV+vNL3qShvtSU8UmKBDMCl5HalxRjrQA3ApKfjjNGOM8UCGY4NNIB6VIfSmnpTAjI9aiccHFTGo3HWmiSAjtUbg9OOamYcZqJqtEsgbio2BqZ+TUeOSatEERHYdaQj1zUhHBPtTDVoljMdRUZ9MVI31pCPWqRFiLHtRTsU3jvVEiY6+lRseMelSN3qI9DVJiY36mmGneozTDVIkaSaQdKU0AcU0K45eB71LExR1bvkVEKlAyOOlNFJn1Z8FNYW/8MwRlvmiXaeeetelJXzf+z7qvk6hPaOx2soK89819HxkYrme47aXJRSjkUzPoKWqELxmk9aWkoBCE8VGTxTzUZ6UikNamClOTTlXPBqS72Hxr+dWEHFMQVKAK1itDGTuKBS4oFLVWIGFaikXINTmonHGKQ4soyJ2rPu0+UgZrUkWqNwuQSCazaOlMxZ05+WiFMAnFWJE+Y9eKIlxxzWaRpccqcdKXacYAq1HFnt2qZYMg4FVbQi6Mt4uQOaekORgVqC0GBnqKsRW6jPA/Kkog5JGXHZM44rRt7RIyO571cEfHanolWomMpsasYAyakUAU4Lxg0oA6VSVjO9xR0pR0po6Gl/lVLQkdkdqUU0cUbqaYrDxjFGKTIxzRuHbrTELxjGaY/Q0pbrTCcihPQaRBKMqQKpN1INXZGFVJfWsZI6IEXAB96OOfWkOOophPoOnvUXNbXHZ6+tID6kUzkH2pC3oBj3pXKsrDiw96Qn3pu4d6Nw6ZouOw8n3ppbim545pM9qGxJCg0Dn60zPPel96RQvGDTT057UvryKYT9KfQQHHJ9qaT09KCcng1GScdqlgBIwfSmMfQ9RTmzn6VG56/4UXAYT9aiJ5wafnqM1HnNK4xrZxznj9ahkJ5xT3P1qF8Hpmi+gIhPU5qKQfLxxUrdTnOKiIHJNIpERyEK55NRjOCCTn6U9yVxg/Sm4OKYMiI7Go5FyM96nI4NRMQM5PH0pCTIyMVE3XJNSEcE5qJvXtQhkLYycfhUBzg5PepZO4GagduDQNETHIOajJyM5GM05jnP+NROeMdhz+NIBr9Gwarnrn0HFTbsDI+lQORziiwiN8be9VZCNvXpxU7tgEnPWqsvOSD700gKcg+Zs1TlY7uOlWpCMkHNVp8buKaJZWl9Pf1qtOwYZ7CpnIOR1I/CqkrDB9M1a2M2iN269MCqpfLEEipXbg457VWYgEk9atakiS4IODxV3wpMF1yAkj5XzWXLLsDZIqvpF0Y9RjYHow/nVW0Bbn0JFcCZI92TgcYqO4jaZ5GxhB2xVHw5dLcW6ZIyABWxMwRpVbGCKyWpbjysnvrSGbQJI3jDApgV4F4sUQXYiU8DjHpXvN7eqmlbFBLba8D14m71eV2+6DxW+kmmZO6izIVcPnH0qFeHb1zVxVBDk+vFVcfe/OtorQwkwfOD71VmGCc96uNytU5verRmyg/3jnNLH1pJM5NLHTILkPSradKqQ9asqeOaoCXtUEvQ9KlBGKik+vSgCjN0NVT1q3N3FVCKQAM04U0ZNOH8qQx1NPQ9OKcO9IenvQBXfqaiNTP6VHSEIvWn9qYKd2oAX2NAzz7UUdqAAUmeKKXtz2oAB6/hTscGkpRQA9fWpV6e3eoVqZfrQNDh7UUo9qXHX0pARt09sVCRj6VYOMZPSoyOMigCH8O9GOtOI7UnrnvQA2mMOtTfQVG3Q0CIDSdPWnsKZ6/SgaHL61LG3HWoR3xT0NQykW1PHHWnj2NQRnipR9M0iiRWqVWqEZ705DSAnB96cD/kVGDTgfT9akQ9TnnNSIfTNQA09TSIZZRu3ep42qojcVMjY9KQi4hwOKmQ1URuKnRv84pFItKfpUiGq6tUqNikBZQ1MhqqjVMhoAtKaepqFWp4brSGiZTxTwaiU08HmkUidGqZGqqpqZCcUiiyp5qVTVdDUsZoAnU+9PVuaiU8Zp49zTRLJQ3HXrTt3XmoQaX8apGUiTNGaYKAeaZjJDvxpabThmkZgOtOA4pB70tBLFUVIq+tJGM9ulSKvFBHUFXj3p6rTlWnqtIYKvrTwopVFPAoKSG7RTCvtU2ODTT05pWLSICPemGpW74qNsUrFJETe1UbgdcVebjJqjcetS1oUkUJByagarD98CoW9M1nYvlIsc96KcR702gOUUc04UgxThTRPKKtSgdeKYoqVenrVom1hQKXHFAp47irRI3FGOKd27UuOKYEDgYNQkVaYetQMOoxTBEDL2PSomWrJHrUbL1pDKrLUZUY6VYI496YV4OaAuVytJt9qm28YpNtAXIcUbfapNtG386EFyPFJipdtNwKYDaKXHNFAAOnSlHSlA55pQPWgQgFAFOA46U4DsaaQXExT0FAHpT1ppCuPQVMi98UxBU8YFUkK45F46cVMoGKRaeo7UJE3ACgDjNOwBSj+VMm40DilApwooC43HtTWHWn80hHpQBWdfaotvtVphxURHtSsCZDj2oqTb7UUh3PEKBSetFbnaOyaUGm0UAOz70u6o8/nSk0AP3fpRng0wHikHf3oAkzQCe1MHNKO9AC5oyaSgetIB2aXPHWmUA+hoAdkYpe1MzRmmmA6l59aYPrSimmA7NGaQGj1zRcB2aM0zP0pc0XAdnmjNNzxSUXAfnijPFMz70bhTAfnilz71HuFG4UASZpM0zdRmgB+aM0zOO9H5UAPB64oz+lNB7UA0APz6UA0zNAP0oAkpAfypuetGeOKYEgNKDxUYNKDwaAJQf1pQeMDrUYOBmlBoAkBzzTgeKjHTg04dOaAHj3xSjOCDj2pgxRk9qAHg0Z96bmkzRcBxPJwTikz6U3NHalcB2fzpM980mfzo59aQC5NJmgUnrQO4ueOetHbBpOKPWgAz6Dim9qOMUnFAB2ptLRQAnOOKafSlOaaaAuJR2pPypfWgQDvSUUUAFFFFFxpB2p1Npc0rlJCj3pR7Ugp31oKQo68UDkUDrxTh70FWAdKXFA6UCkMUU4UgpV6VNx2FHSj1pRSigaAClFAFKKBpABmjFKPagUAFOApAPTNKKQ0LxmngetNFOHSky0FA5pe3vQKkpCcd6d9M0nHSl9aAAe9OX9KQe9PX9akQ4e1PH0pgqRevFIY4U9c44pg6d+tSL9KVikPX2qRPamL7Zpy1JSJF96kQ8daYtPTp0pMZIvSpBTF709elSxj1pwx+NNHvTh9akESpUq+1RJwKmWpLWo9akXpTEqVaka0FGOaX+VKKXFIY327UmBTqQYoEJj1FHfpS/XpR24oGJ9aaRzTsc0nT/GgQh/kabzzTj04ppFNBYY1RN0NSnNMOKaJsQn2JqI1ORx71G3fJ4q0TYgbqaYe9SkUw459apE2ISOvrTD0qbsc8mmYGOapMhkRpCKcwxSHkdBVpkEbD0phxjipG68UxveqTJI2GehpnqKkOexqM1aFsRn6dKb7U8+tMIqkTcbj6UDHNLikNMQtSp93H51D9KkjOOKfQZ1nw81hdK8QWzsSoLBc/jivsHTJRPaRyAghlHNfDdnJ5d3G46qw/nX2N8Nb77f4Us5S2TtAz9KxqK2pUXodUKUdKavelqUwsLRSZ6iinuFhDUZ7080w1NykRgnJJqWP9ai6nip4utCHLYmUVKBUYNPU8YrZGDHUGikyKBBTWFBNITTGiF1zmqs0eQcVdP0qNlGDUNGsZWMOWMhzkcHpSRr83Tn6VqTRhjyKIoF9sg1FuhfMJCnyjINTqvt1qRFCj6UpdR6VpayIchip+VSqAOlMWZORuFSqV7GpViW2KB+VOGKYCDS7hmqViCTHBpAMUgbNLTJClFHsaM0g1ENFBOKYW9KFsNIeTSLjvTCeOtNLYzSuxpXJCRUbv6Gms/FQu470rlxj3HM3Gc5qFz75qOST0ppkPSpuaJWEfHY81GTjOaHfgnP6dajL561OhaQuc9qTkUnXp2pB681NiwNB/Sms2PpTcnmltoCY8MaTPp3pu6k4HPH4UIY8NxzTdxHGeKM/L2ppbg5pALv64pf4cjnNMz1xnpRzjGf1oTAGpN3UmjORz2ppbjjsaTEMLdajJPJ4p55z6U0+tADDn1GaiY84GPf2qRs55xURpFIjPoDwKicjJ7VKe4/GoW9aYELZ5zUbDPrjFPbIz6U0ncTz+lSMhc80jHnA6U/+EgjmmMCBk0wGvwO1RP0IzzUjE9x9ajf2ouIgbGODyKhbIB6471O555AqtISAc96BpEUhyMCq8mM454p+48gdqikPPJ6Uh2InJ5zUTHHU9qc5O45PFQsPm5PFO4DS3HFQOeecdakkGT7GqrPyQD0PFAWB2BJAPGarSNgHNSMcZqtK3H4U0iSu5xziqjtnIPQVYkII4Iqq/IJzTSEylK20kjNU2IG4k9atTnPBIrOmOCwz7VaM2DMNpAqlJJ6nt1qR2GcZqnM2ARzVpENlW9mwuM9aitOzA8+tV7pi0u0dKt2Sbkx6VfQlO7O68KeIWhxFKfQZrv01BpYRITuTHWvFYCyPwenSup0fxFJawmKX5k6VjazN07o7nV9USDS5ZAedvHP4V5NettEkhJyelb2s6ul4irExCZzg1y+oT+dKMdBiqpbmdR6CqB9mzzkjNV8YUkdamY/uj1AAA/OoH4UkE5NdiORjc5B+lVpehxU4PBqF/uk00SzOk+8aSPr0ok+8aRDzimQXofarC1XgqcVQDweCKjfoc06kPI6UAU5h1qoe/HSrsw68VVI5NIaGCnAUClxSAB0pGpw96RulAED9ajIPtUzVGevFILDMUo6UcdjQKBCjntSf5NH50dqAF/lSetFAoAUdKUdKQdTg04UAOXHvUy9OPSoU64qdKAHgD39qWlXpS4OODQMj7Y/Go26c1K1RkfpQIjPvTfx4p5+lJjrQOw3qM+lMfvTz0NMakFiAj0pvrTzTaLAApV6800elOB9MVLQ0TKfyqZMe9V1+vapo/rUlIlXOKetMX608dOvNSxjx6U7mmr/OndqQrDqcuQKYOQfWnDNIlkin8qlQ9wagU1IDxx1oEWkP8qnRqqI1TIeKmw0WlapkaqqGpVagC0rVKjVVVqmRqALat71IrVWVqkDUhoso1Sqaqq2KmRuKmxSZOpqVG/Kq4NPDUrDLSv71NG2e/SqSmpozQBeVqeDVeNuKlWmhNEopR0x3popRVIzaHUDpSCl9aZk0KPSn0ijninque3NBk9AFOUUoSpkWhIhiRrxUyr+lOVaeBRYgaq09VxTgPyp4HtSsUkIBTgKUdKWixaQzFNboalP51G3Q0WLSIW6cVE3epG6GomPXFKxaRFIcA1RnOQatStxj1qnL3qZGiRUf0qIipX61GRyfesi7EZFJ/KnkUw8daVhWFFKv1pvHrTlpomxIlSr0qNKmWtEiGhRzS/XrQBxSjpTJsKPb86XtSCl7VQhrDioSKsGoT3oJIWHrUbCp2H5VGQOaBXICtRlRnFWCKiNAXIdtJtHpUpFJjigLke3r60m2pcUmOKEK5Ht9aaVqbFIVphcg20m2pttG2gLkW3vTguak20BaEFxgXinAcU8DFAFUIRVp6gelKF4p6rTQrioKnjFMTHepVqkTckWpB9KYtPHFAri/WlGMYoooEAHrSikFA9KAF9aaelL65pD+lMVxhAxTCDTzTSKVhpjNoop3FFAHhNA/Sk70VqegL2o7UnbjrSigApO1FHagA+lA/WgdfWgdfegBR7Uoxk0g9qBSAXml7Ug9qUUAFJ2pfrSGgApM0GkoAXNKDTe1HbmgB2felzTM0UAOzQD+lNooAdmjPpTaPrTAdntTc0ho+lCYC59aM0lJ3ppgOzRntTfpR9KYDgaUGmZpRQA8H1oBplLmgB+fSjNMozQA/NAOKYD70UASA0qn86jzSr7UAShqcGqMU5T6UASAmnZHIxTF/OnD2NADwaXim0dqYC0nrmkz9KM0gHfWj+VNHv1pe1ABmijtS/1pAIKO1FH6UAHFJ/Sj/OaO1ACGkNKabQAmaKKSgBD04NNNONNNACUfSjvSeuKAF9aKKKAClFJ2x3oGKkpDqQdTR9aB0oKQ4Uo6Ug6Uo+tK5SFHtSikAxTl6UXKQ4UtNFOoHYBSik7Uo+tIBw6c9RSigfWnD8BQMB0pQKTHFO/CgaDApRQPoKUYwaB2AUooFOHvUjSBaXtQO9HSkUgo7daWgUFIB3JzQP1oGKUfnUgAp46Uwdacv6UhIePapFqMegqRfWkUh6inrjvTRUiigaHDpT19DTF6etPXHepKQ8cU9fSmD9aeppDJUPapV+tRL7VKvsakY4U8Dimr0p64qbASJ71KvT6VEtSr6VJaZKvNSLUa9MDr3qVemKkY5eKd9BTVpwqQEx1pO30p1J2IoGhOOR7UYFGPpRj8qB7gO+TTccU/2pmKBCetMP60+kwc8dKAIyOKjYcVIwFMNUiWRt1qN+h9KlYUw9KpEsrt3IphqUjg561EatEXIznGaZg81OVqNh1xVIlohPekI6nFSkDHeozjpzzVJksjP60xulSEcZAqM1aZAw9KYetSHnioz39qtEsaemD0ph+vFP8AWmMapEjD3xTe9KaSmSA6809KZT0qhrcnTkgjqDX09+z9qPneHDbMwzG5/LivmKLGGyOa9a+AOuNba61o5O116Z+lZ1FoXa60Ppg0Cg/MAQeDR2rFaoEGOKKT60ZppjA1Ge9PyM0w+3Sk7WKQ0Dmpo8ZqMdOKkj70kEtiZTxTlpi9OaeOlaoxaHCmnpQTTc0xJBmkLYHNMkkEaksa53VNcSPIiIJB9anmSVzanSlPRHRh165FIWGOtcKPEMivlm46Vcs/Eiuzo4GMDFSqlzZ4WaOtwGGDTHdIgckAdetYc2uRxpn26VyuueI5ZgVRiozj8KJTSV0VSwlSozp9T8QxQEqhBI7isKTxDK5IVsDHFcdc3jNIcEHNSQyyMu4gBRwTnvWEqjZ6UMJCKszqE1yX7wk59u9aFv4gkUDJJ9ea4stsU/MD9KDcugG1u1NNg8NF6Hpdpr8UuFZsE1pQ3iSYww5ryNLx15JOT6elaNprc0WAHJAq1UOaeAX2T1eOUMOCDipt3HWuC0nxMCdsvHvnrXS2mqRTLlWB/GtIzTRwVcNKBsbs8UZ9KqpOCMjpThJ71ehhy2J91ML4JGahMnoahebBOTUlKJO0gJ4NMMnqaovPjJBFRtcDHLe1LmNFAvPN2HTvVeSQH61Ve4ODzwKhacEcE9KTkNRLbSjBycYqMycE1UMgPJJyKVZBjv8AjUXLtoWQ2RzTN4zg1CJCSfShiDyOtK5SVicueg6UBh2qBW+XrS7sfU0kwsTE5HXmmE/mKbnvnjvSZ7Z5obuCVhwxgg5peg56VGCR1o68e9IZJn0FBxjFMB59qTP1ovoIdmgZzxSZHrR+PSlYYh6Hrmm84IHrS5xwTxScDoc5o3AQnjmo3PBHansML15qPHByaLiQ3qB3qCZscAd6kJwD6VE3I4PepKGH3qJid3TipG7+1RMRkkZ5pgMaoyB1FPOT2H+NNwMUkBEwOM4pp6HHXtT36cHimNkdDTGMJznPWo2Hc8ipDgEjPJqJuM5NAEL9/bpVaY85qeQgDiqsv6UhohfABx9agc7lPSpZM/NxULnsO4oGROflPSoC4wQT0p7MegIqCTAHtQGhFI5xUAHJ9TUjsCfpULNhiQelMCKTIzwarO3J6c1YZsqcnnNU5ecUIgglOBx1qmzEbvTpViZiCeD6VTnbauKpCsVZ279qzrg4csvcYNXp8iMn1rOl+43TJFaIzZXkfgnNU5pAqEmpHfAIOKzrp9xIB4FWjNshzuYnPU1rWKcYFZEA3SY610FqoEfHcYokyYLUkVRnpTzgcADB4oQfMQe9OVeTntxUWubJlS6Hl4wf/wBVUJXI4XGSQP1q7fuCcDoKzn5kXHrWkNDKozQnc7QmR2J96hm6fhRKf3gGegFKzZTIxxxXQtTnt0K8Z4Oaa+NrelOTgUyXIU4NWiGZsn3jikTrRJ940idaCS/b9KnHeoIOn0qeqAO2BRRS/hQBBKvy1Rcc81oS/dNUH6kUhoaKXFA/SnD37UgAcfSkP3T3pwpG4FAEDdetM7H2qRscmoz3xSAbj3FH40tJQITt60du/pRj86XnvQAn0x1opaTtQAopR0+lNpwPrQA8etTRmq49qmiPNAFoDijHHtTk5Wg9KAIj147VGQamI9KjNA0MxjtSYPOfzp3qKTFAEbDjiom7kVOe+ajIoQFds8io+lSsOPeo/wAKAE/lSjg0n1pRUsZKvpUqVCv8qljPPtUFImFPHNRqew7U9fapKJF6U4Y7U1acP1qRDh3oH1zTaUfSgljxUme9RLT1+tBJKhFTo361WWpVakCLSH161KjVVVu+amVuKBllWqZG461VRqlRhSAtI3FSq3FVkapVPekNE6mpkaqqnipFPvSGi0rU9WqurVIre9SUWFPep4z61VVqnjPPNNAW0NWE6c1Vj6VZjoQmSinimL05qRapEMUCnBaVR6inqvtxTsZNhGnPNToopI1FTKOKZjIaq1Ki4oUcVIooM2KBSgU4DvSiglIBwKUfzpKdSLSFHSgUg96M0I0SA/WoXPB5p7N1NQO3PWhmiQ1j1qFzSs3HWq8j9c1NzRIjkbk1Wc9akduuTVd24PeobLSIn61H9KVmHNNzWZQHnimnrTs8YpDQIb3pV9KQDqPWnKKaJZNGD0qUelNjBxUqjitEQxAOKcKAKUU0QAoxS8+tFMkQ1G2KkPSozQSRkcHFRN3xUzY9aibrx1oJIz361GfapT05qM0CGfWkxTvXmkxQISjGad/KjFCEJjt1NIF9qeAKkC8UwIdtG3tU20UbaB3IdtG2pSvNNxQguM296AKfg5pQKaEIBTsdqB1+lLVIBV96kU1GOtOU+9UhEqmpA1QqfWnBuPegklBpQfWo91KDQBJmlFMBpc00IdnjjpSGkBoz+VMANJjijNFIEJRRRQM8EzSikoqz0BR+VJmgd6KADNL+NHGKT1oAX3pB9aO1FAC96F6/hSdKWgBRTh04po70opAHek7U4U00AJRRmjtTAQUUUUAHagUUUAL+NFJRSsAe9FH86KYB1opOaB680IBaT+dLR25p3APrSdqWk7fWncBaKKKLgFFFFCAO1FFFMA96KOlH8qACnDim0o/SgCQHg+tKDxjvUYpcjrQBIGpwYdKhz70o9qAJww9+KcDnvUC96eD60ASdjQKbnikz1xQA/v1pR+FR5pcn1oAfniimA0oPakA6ikBooAKPxpDRQAetIaKKAENIf5Uvak9/WgBO31pppT0ooAbR37UUUAH1oo7mj+tAB6ijtRiikykKKUUg/WlApWKQq04ZxSD3pwFIpBinDvTcfnThjtQUhRS0g6U4UhiDpSjFFKD70DQ4dOMU5fbNNHvinj+lACfSnD1pBTh9aRSFBpR0xikpfWlcaQCnDp70gHFOHsKVykgA60opP50oouMO1J3pe3FJSGLS0g4NL+FAB9acvv1po/lThj1pAPX3p68UwU5fYUmBKtSL0JyKiWpRyOKTKQ8VIvXnkVGP/rVIvTFIocBT170wU8cVI0PTpg5qVaiX0qVelKwyVaetRLT1+tTYCdD1qZKrr7VYSpKRIvc08elRjr+FSL0qGUiReO9OXpTF6U8dxSGHY4oxx7U6j+VIENApMU7HoaUDigdxpGR+tM7VKenFNI6+1AiP60h9qkxTce9AERHHAqNh1qZufSo26e9UmIiIqMr3qU+5qNunFWmTYhccc9KixxntVjjGMda1/CWgT+INUS3gQsmfmOPerir6GcnYx7Kxub6QRWsTyMTjgV2el/CzV72LfIRHkDjaTXvHg/wJp2iWyfuUabHJx3rr1hSNcKoAFbxo9WYOt0Pl6++EurQxlo5FkOOm0j+lcTrGgajpUpW8tnXBxnHWvtN4d/UDFY+r6BZahGyXECMDx0qJU2tUVGalufF2MZBB/lTNo5xX0F4u+E9tNvl00CNsZwB3+lePa74X1DR5XSeFtoONwGc1KlbcOV9DmmHHA6VEcCrcsRRfnBA+lVHXqe1aJmbViM9eaY1P9qjPWrTJGGigggmm1aJYop61GKev1pguxOuQvXqK6P4eXxsPFFrKGwC4B/MVzY6cVJZzNDdxyISCrA/rUyV0aJn3VYyCazicH7yg1Y7Vyfw41Qal4btpNxJCgV1Y6VilYqwUUneg0gQh6U0Hg0GkpFJCGnR5HBpooBwaEOxZU08etQK3vTg3HWrTMnEkJpjuFU5xxQDxmsPX9QFvEUU/ORxSlKxVOnzuyKXiDVCcxRNj1NcjLIXLDdTrq4cucnOetZ91NhDtIDd6xTb1Z69OlyKyKt1M6ll3cZqSxuSblQx+Uj9az72TeFbgdjRDM8csbKw4IweuKTaOuNJuJv6hMSoVN3A+nSsC7kMqFkySODWleXZODvDEe2MVktIU3BScdTxQ0aUYtIQqNoZs9qeLx/LeM8KOnrVYSE5UluD+lM3HLEjAHNSbcpbSY7WGDx/nNOWVpACcYA/OqqSZPAOCKQMy8HOM1XMS4lndkjLcZ9aXeUOAQR1qqrluBjg9advIJyR04+lK6MnEtxXWGwDg1ftdVlhcFZDxWE2Dk96ZuZRnJxSWmxLinuehaZ4nbCiVj15rorbXIZV4YZryGK62njPtVqK/dMYc5HvVxm0c08HGeqPZEvFZcqRg1DLKGHFee6d4hKrsYngdc1vW2sxzKMNz061op33OCphZQZtyS4HJ7VAZuCCee1UvtasfwzUbT5+lBCi1oXluCQRkcc1H5mehqg0pUkA0nnjBywGKTCxeWbGQ2amifPTNZYlyeWGMVYil44PSkKxoBhnqM0objBHSq+4EDPWpUYYJPpQFyZD6+lNznI/rTUPU56etL7ipQJioxyQakDDPNQZO7n/9dSD9KEMfnIOKYM880vQcU1m+hpbAOLYoDflUZbqe3SlDdqQ7Env2oz+VMz9aU98ntTEKTxikzjJHX+VIx7D8Kb25oAUscc1ESex9qcelR9Rx2pAhrMMYJxg+lRnoee/FPbrjjFMPBNCQyNulQvlemKlY8kA1H65NIaY0noQDx+tR8nJJ4pxz74ph6HJGKEFhrEjr0qMkc55zUj8qeKhbAHAFFxIbn/61QseDmpGaq7kk8UXKsRuRjB61Wk4FWHbryPWqjkknBzii4JETk++MVC3KnHWpHfuenSq7E9jQMhbg1DKalY5zntUErDtRbQRA/U4qu565IqV2659KgkzgkAUIOhG5AHHXNVpDwc1K7YPWq8zeo4qkJladuPeqUvfJ5NWZm649apyk53A1SJZUnbAwe1Z02SDjFW7lssRWdKxJINaIyZUuX2g561nMflOfWrF22TgVVbODVIzZY0+PL5I4roYY/wB3kdMVk6Wvy8+lb8CfueegpSHFDUTauSPxpCoWMk9TxT3yxAGcUyTDA5bpUpl3sYt5/rsZ4qNABcJxk5p8vzTtg8DrTI23XDH+6K1iZSHu26ZietKrDaRxTI/nlkPfNKnet4o52yE+3rSTH5D0ok6nHrTZvunPSrRJQkHzE9qavXpTn6mmr1oJL0PSp6gg6VYHT1qgCjFL9aKAIpfunpVF+vPWr8v3TVF+CRmkNDPxpRSGgUgHDFI2MHpSj6UEcUAQN0plPbqeajPtQAfWm0402kACj+dAH40UBYSjt0paTjrxQIKUdKTilA4NADl5zipYutRjNPj68GgC/EMrxQwwKWAfLSvj8aBohNNYU/8APNN+tAEfrim9qkbp2qP19aAsH+eKYw9elP8AX1pp6Z7mgZA47f0qFsA9PrU7+3NREc84oAZwKQDjmnEGm85NJjHLUintmo1PBpyY7VmUiwp7/wCTT19zUKn9KlWpsMmX60o70xenanilYBw/zmnD2pi9KeOn86RNhR7GlHNNGAOtPGKBDlPFSKfWolp46+tIEidDUqGoFqZaAJlNSoagU/zqRKkCyh/KpVPFV1ODUoPFA7EwNSK3aoA1PVqQywrVKhqsrVMh4oGWUPvxU8Rqqp96libmgDRj6ZFWY6qQsCKtRn0oETrUqCoUqeMcU0ZyZIq9qlVeKRBn61Mq8VSMZMVB6VKo4pEWpVXigyYirUirSqvtTx7UE2GheKXFO7cU0/pQJIT8eKTOOKCfpTCe3FBokP3Yzmo3kHamFuKru+M0GiRK8nFVnk54NRySjByetVjKCcZ4qbmiRNJKADVaSbg4NMmlHNUpZwM5PNQ2aJFl5e1V2lzVV7jkkH3qLzhnrUNlaFrdShs96p+d70olNSItgjPHenAZ9agiYmp1+tAriqO5zUkajNIo9hUyD26VSRNx6jjFSAUiipFHHNaJEXG9qXHFOxxSeopkiUmKWkPFBIh6daiNSN3AqNu+MUEjD3ph6H19acelMaglkbUwj1p5/lTDyaCbietJ3peKAKYgApwoFKKBCjpTgKSnDpQAYpPWnUlADTj1puB0p5pvvQMbQPrS0tCATH8qUdMUo6UlWgsL7UZ9DSUnTpTEPDcUoYVFn0pcntTuBKGpytUG6lDe9FwLIPenA1Are9ODZoFYlzxSZpmaM8UCH5oBqPNBPvQBJk+lFR596KAPCeKX+VJ60taHoBRR0ooAKKKKACiiigAHtQM0vpijFAC+9LSDgUtIApuetL70lACetHvS98UlMAoHSj3pB0xQAo6UUUnegBc0UdqPagAoo+lFABRzjmkFLQAv5UlFFABSUd+aX60IA/lR3NFA/rTAPXNHtRRTuAUnrS0mPSi4BS0h6UCmAd6d2pBRQAooz60lKKAFGaUU2nCgB4pwpopR0oAcKP5Un0pe9AAOlKPbrSUo/GgA5pw600dKUetIBaO9FFAB7Un40GigAo9aM0lAC0ho5x0NJ9KAG/hSGnfU0nagBuOKX1o+tJ+VABRRRQNBRRS+tA0HSnCmgYpwqSkKOlOHfimjpTh+tJlIUdaVaQd804UrlIXvS0lLQMBSikNOHtQxocPcilH1pB0wacBxxSGgFPFN60o6c0hod34pRQMdhQKVykhaX8aTjpilpFIP50flQOlLQMSlFFH4UAApR9aTn8KUY70AFOHvSCnCkAo9KevemL0py/SkwJEqYe1QrUy+o/GkykPFSL7VGMY5FSL+FIpDx+dKBSCnL1IHSpGPWpV6VEtSr0pMEOWpFpi9MU9aQyVKnQ1AufWpkqCkSLUq+1Rp0qValopIcnSpB+tMUU8CpGhaO1A4paBicYx3oFL9cUoyO4pAH0/CmGpO1JjtQIjxSEU88im8DOc0CIyOaifvg1MwqFxiqSAhPTmm54NPI9aY2e1UgsEcZlkWJclmIH519M/CbwtDo2jRzlczyjcSR6186eHVDa9ZBvumVQfzr7D0qNY7GFVxgKK6aCWpy4h8qsiyq8+1P2ihT60v0rqOK40qKhdanNNYCpY07FNos9RWTrGgWepQslzCrAjrit8r1pjDg1Eopm0ajR87fEb4fvbRNLZR7kX0Hb0rxq6t3gkKSAqRwfavt2/tEuIWV1BBGDkV4b8UPAqBJLu0jAPXisLOLNnHnV0eEMoycZqFxzVu4jaGRo2yCDioHU9c1rE50yuaaakI60witEK40U9KbinIKqw13J06UdG460q4xzTgMmlYq3Y+j/2f9VE+kvasfmU/pXsdfMvwF1IW+u/Z2bAc8V9NdVBB4rnejK6CHrSGlNNPTNIaGk9aQe9BPOKbmkmWkKaTNITUe7mhspImVqcGzVfzKVZPmz+FCZLRYZtsTHPSvOfEF8Zr+Q5JVTgV3eoymPT5GB5xXlN5cbpn55Lf1qJs68FFNtiTTE5PNZk8jSM2M4FWJ2whwc1TmGFOD2qG9D1qcSORWaIDHHSqZlaM4PYj9KV7gxjaWOM1nXN0qnJ6ZrJs7IQOlhut6BhtweDTZ2iZeSA31rmo9RWM/K+RnHpRLqAZjlvl7UlJl+yNJ5FRzk8EcH6VXnvcp8ze34Vj3OppGOWB/Gsu41hA+AeKLSZVox+I6gXmBkE4AxQ+ogDk8Vxz6u5GUzioW1GVuefzp8sjNyh0OzN8FXKnvmpBfgjI71w63sxBAJqaPUGVQGDEiq5WS3BnZpeoG+arC3St0xiuGGpyHJCtVu11RzjchHbr1oSZk+U7EMHG5WHHamGXbk7s57Vzq6oxJG3Ax61HJqwRcNnn0qkZ2OlF55bY4wfepI9SMa4VyOa5UamhHLjp6U3+0YwCd9OzJlbqdvbeIZIz8zEg8da04fECuOWry1tWQDhiaY2tlf8AVhvyPAqlFmE4QZ67/a6dm/WmnV0DEFgBXjU+vXg5izg9M5rLudX1J2LGZ1x07VXI2jmlCKPoO11NHOAwPFaMNyWwVYc+lfOOm+K9SspgXdpEHUe1eseDvEa6vbK6/LIOo6fnUuLiYNJno0Mvrg9/pVuNieR61iW83y4PU9MVp20jHoevrSTM2rIvd+KeOBxUSHHJPNSr75+tUSKAKXryetIB69aQccVNhocSO3UU1uRg44oGB/8AXppI6UXBIQn/ADmhW44pBjB4pe3SkMdnjg0pOB16ioxx6Um7jHFHqFhxOfrijJxyTim59fSk3ccUJisKWyTimnH50hOehpp/Gga0EJ7HoKYx+UjjinMcZqJm4ovYYjdeCaiPQnOCKkPrxUTEEHNKwhhPHJ96axPfmnZ468Co3Oc4oBCMTgjtUTY7U9jk9faoiecUDI2PBBFQucKcdTUzdDVaUkdM0DTI5eOfaqj5wemKsSHK4/Oqsjc4xQNIgcjB55qBm461K7ZJ/SqzdDz3oAY+Bkg1XkbqD0qSRu3NVXxk5OaAQ1yM81Xc/KcfhUknHU9KqynJyOlCFuNY561WlbqPfNShwSQarO3U4q0JleVhk4qlcMSpyRnrViQ4zg1SmbOapEyZTnbHfk9KzpWABOe1W7kn16GqFyeODwKpGcjNlbLtkmo8gdzk0j4Mh9jToFLzfSrRibelRkIMjk1sMcIF9aoWCYUE546VeBG0s34c1F7mqiNz3HamXB2QsT1xilHXnuePpUN9IMBeDihIJGU/HAOSaZaf61/TFJdSkKQoGT+gplvIVcA9wc1tBamM9ESQ8yHHQ8VJH1bPpUCOFmVQe9TgjJx0xXQjnZXk6n60yb7p+lSSffamS8jHegRQfg0i5z0p0nBxTR1pkl23+7VgCq9v061YH1GaoBeKX8aQf54paAIpfunmqL9Tmr8uNp6VnydSO1SNDKUUnagHtQA8f/qpDSD2pe1AED9SKZ+NPb2pp6UAJSGj6Un86ADn1oxzR3o9aQBzzSUvFJQIT3py0lPX9BQAo9qenWmDqefzpw4OaANK35X8KV/5cVHanK1I/egaITjkZpPx5pxHXnvTD+vSgBG71GR61IelR9+1ACChuh9qO1B6c0DIWHB4qMj0qdh6dKjYD/CgaK5GPWm09xx/9eo/rj86m4DgactMB45pRUspEy/pUi96iXuAakQ+9IZMvSpB1qFSPWpV/OkFh456U9eh96YOmacPepAcOlL9aaKcOtIVhw9qePaoxx9elOU9vSkIlSpVPNQofepAaAJw341Ih9arg09G9aVhltSOlSA1XRvQ1ICDSCxMpqRTioFNPVsfSkFiwhqVWqsre9PVvegZaVqmRqpq341IjUAalu/ar0be9ZED81owtke9ANF5DVqP6VRjbmrcLU0zKSLcftVhRxmq8RqwnTrTuYtEqD0qZaiTrUg9jTuZtDxTqapFOzQSJjimsRT8+lROev0oBIjZqYz8Uxmxn1qIv60rmiQ9m64qpNJ15p7vweaqSv154oZrFEM0h6DtVUykA8+1STNweeaoyPycYqGzRD5JeDk1nSyFieTUsjccVXIyDioGN3HHvRk8jpTgn1xTgh70ibka5qwg45pqx/Wp0XjvzUhclhHHXmrKDtUcSelTovoM0JCuOVRUqLTUHFSoKtCuSLT1pqCpBwKu5FxPamnvTzTT7UIm4w9DTTTj6CmE0ybjSetRk04n1Iph70E3EPSo29qd60w00ibjT6UynH60zNOxIlOFJ3o7UWEOHtn8qUdKQdPWlHXAHNFgHD2paQU78qBh+NJS+/NJSADTecUvPSkoAT3oFLSD8aEMcOnFNIpwpO9O4DaT1zS/0pp600wDjHtR2pO1LTAXPFID6dKMcGk/Pii40SK1SA9+1RDNKCc9eKdxWJdw5o3ccCowaM8cGncQ/dxijNM3UmfzpXAfketFMyKKLiseI0UUdq1O8Q0tHtRQAUADnNFFABRS96B0pAAoHvRS9+tMBKd7/hTf50evNKwC96TtRR9KLAHek/Gl70hpgApMUtJQAetA70UUAFFFAzQAtFAHrR3NABRRQKACj3oooAPpSe9LRQAfXOKSlooQB+NA6H1pPrS/ypgHaj6UfyopoA9qBRR1oABxQO9FAoAPxpaTjpS0AApw7Ug9acvSmgHClFIPzFOFFwDFLiil4pAJSjPXtSUv40AApRSCloAO9LSd6PqaACiikzQAdqSijtQAvem/Sl+lFACU3HHNOpKAG/jR7UvFN/WgBaKPWj60DQlOFNFLQNC0CkFKKQ0OByeaeOnOajFSLUloUU4CminjFKxSAdaWgUvagYd6UUlKKQ0KKcM02nDrSGKPenDGKaKcP5UrlIcPrThTR9acOnFIpC/hSD9aXseaKCkFLxSDHSjvx3oAUdOaUdfSk4o/lQAvY0UlKKAFpwpopwoAUZ9actNH1p69akCVaev9aYv8qkXpg9KTKRIuf8mpVFRJ3FSjpUspDh05pw6cdaaOlPFIY5akUcc1GtSrSBDlqRRTFqVaQx61Mg5qJKlSpsUiVfrT1pg96kX2qCkSDpThTQPenjpUsoB1pee1IOlA6d6QC/WlHHTFID1zSjHpQHQOetFHU8+lGfegVhMcU09OaU+1BPFAiNulRNUxx2qM/jVICAg9RUbDjip271EcHP5VSBsk06XyNRtpOmx1J/A19g+G7n7TpEDhgflHSvjc/K2f7pGK+k/gxra6h4fWBnBki+U8+mK6KL3OXEK6uekCpMjpUSkU7+VdSehxNDqaaM4HWkz1zTQJCHpTSOPanUh9KVrlIgcDBrG1SyS7geN1BBGK3GXiqkqjJrOa6HRSlY+aPih4I+xSSXdqDjqRXlboVyD1HFfYnijSY9QspY3UHI44r5e8a6K+lalKu3CZ4/M1nFvYqrTVuZHJuDTMetWHHvUJwK2RzMZjvTkptPSqBEi9DT4+tNXgGpYQB1zmlc0TOr+HF19j8TWjggAuAea+vLCUTWUTg5yor4q0yRra7jlTOVINfWvgHUBfeH7WQE/cANYz3KSudMabQD1oqehSQw005pxpp71BaGdjmq7sF9ambviqcpwxyT0pNmkVcbLNtojmJWqc8hBwDUXn7e4yTSG46D/EF7ssWAxgjFeeTtuc4rq9dmWSAjIxjOK4yWUKxGRUvc6sNaKGyyAqQDz/ADrOuXOOHqxOy4bJA4rEvp2UHB46VDPUpale6mCscE1k3dyBnJNTrDdXjssKMRSnw/dONzj+uKlI7E+VaHP3N1K/ypwoOagaafoWOPpXWw+FJXG5s4+nWpx4WY/KIzz7VorIy5aj1ucKxYnkkk1GV7kfpXo0Xgkvyy/SrS+B4iBuTmnciVFy6nmcCFsgA/lV2HT5pfuxsfwr1Ky8GWkKcRKWratvDSRL8sS444pWbCNKMF7zPJ7Xw9cy9I2/Kte18MOUzIpz0xivWLbQipUFUGSM8VsweG4iPmlQMRxxVxpSkZ1MTSpniw8PorjzEK/hipf7DaSQKkQweBjvXpmqaJJazMjxho24DVDpulqkCjkOHOOPejka0Y3Wg480Ty99BAnKSAoRxUN14dZSyMo3cY7Zr1PXdFH2fzCp3dz/AI1z8674RHKAJY+hx1+tTbldiIy51dHn76DyOzDrQ+iGJhnDRt19q6mdk81cKdwHPvUUy42qF3Mx5xxxVJi5TmhokcT/ALxd6EfTHvUh0mBCQANvatxoHdAoB4PBp0di8jkKOSMVaZnKNjl305cMAOByKI9Ea4YblOzGBgV3NnoLPITIOOlb9ppUSJyBtHHIp8xzVJJHm0XhKOQjMZx34xmuh0LR008FYlIxzx612L2yggRqAB7dKjW2AY8Yz1rKTbMOYktGPyh+SAK2bPj2H1rJghCyblP51rWhHcVC3M5bGgh7mpVJzyahTsQcipV6VdzMkGMYzRkc4o7ZAFHOeMUXEhhyScE4pRjHPWjucnk0h+916UirjScUgIxwR1pG6nrxTB0/GkNIkPTjrTDzRntzSZoYId269KAwxim9vemHPb86V7CWo4+vekJ9TSbuetITkZJo3GNJ5Ppimkd89qcRTCcDmjYBpP5VG3rTm9s1G3oetISGMeCD3phIHNOOMGoyRj9KRSEJFRsffmlJ984qNmHP5VVxDXYdzVeRuMVI/Qn3qBzySD2oGiGU4ByapyHcc1akOfcGqkvT3qR3IZQOM55qu54OBzUjtxk5z0qB+47mgLEUhBHPX61WcnefpU0pwMY6VVdh6896oCKVicnOKqyHBwTU7nrn8KrSHrk9KEBG54OKry9xmpXYAZB7VUlJAJNNMRXmf5iBxVGduTU8rDJqlOT1PrirTIkU5z196oXJO01cnYZOc8Vmzt1rRIwloVD6Crmnx7m61TGScAcmtjTItqbjjNN6IiKbZqwJhQPSntzgHtTIyQMn8KUvtGSRWaN0tBScZyfpWfdN1wenNTyP6Gsu7l+U4NWiX3K00oZzgdOtOtPmm914qrGc7iKs2J2rIT1xW0UcspXGKw+1ZPriry9Wz0rKkZhNjvmtKJslgfSto6Gadxkn+sP4GmyU+T/WUjjgGqEZ83Wo161NcdeKgXrQIuwHA9qsKarQ9MVOPpQFiUGkz700YozzQFhJD8pqhJnNXn6VRk6n1zQFhlAPp2pvalHSgLCjp15petIKB+tAIYw7jFR/jUpqM96AGf56UgpT3pO1AB7mjvyaPrR7mkIKT370vak59KACnL+NN+lOWgB4xSjOOlIKcAPzoAuWpwtStz9Kitvu4qVu4NAERxzgU09+eKce9N+maBoac+vWmnpTvr2pKAG0Upz1pKLjGkcVE3ep+3FRsODgUrgVpBUGeMVYmqv3NSMXp1xSg0nOKP60hoep9KlU1CKkWkNE6NUqnjGarqf071MntSK3Jl9qeOOKYv14pV/WkFh4/WnD9KaPTpTgCKQWFHPtSjPekU04UhD14NPU+nWol9KeDxSFYlB/GnKTUQPanrSGiZSfwqQNxUIpwNIaROGPTNPVjUCninBqB2LCsalVqqq3vUitSCxZVqkRqrK1SI1A0i/E1X7d+MZrKiYe9XYWpBY1omq3C1ZkL1dhb3oTMpI0Ymq0jcVQib3q3G350zGSLSmpAeKgVuOtODcUXM7FgN70u7061X3U4NxQmRYlLVG7cHikLcVE7cZp3BIjlbk5qqz+/FPlbg4qq7cUXNEDvwarSycU+RuKpyngnJpXNEyOeTGcEVTLZ561M6k555qPy+35VJSZH14pAo6VME+v40BPSkK5GF/GnhcipAmRT1TrkVJDYxE+lTqgpVTt/SpVXApC5hEUVKopAKkWgLiqOKlUUwcCnqRzVILj1pwpq06qJuFIe9L6000E3GH2+nSo24zUjfWoW9aolsa2Ov40w0p/yab/AEpk3D86Y1OPT6Uw96aJZGfWmmnn60z8aYgHpzQKPrSCgBwNOFR9+e1KDjpRcCUdKXNMB4pc/nSGPNJ24pufXvRmgEL70fhRSUgF5zwaOO1J9MZpRQMO2RSH9KXt1pO1MBpoo/CigBO3FJ2606gfSi4CUD0pQKcBRcBuDSjp05opKdwFye9JmkNNzQA7d6UmfSm0CgCTP+c0UzPvRQB4tRSewNFdB2i0D0pP5Uo/CkAUUDmlFIBDS0UUIA7Ufzo+tFMAoope1ACUdqKSgAo7UZooAKTFKaQ0AFFJS0AFH40DGKKAFoFIOhpaACij+VHr+lACfjS0nbmj8KACjil6Ug+lAC0nNL2o+tABj1FHsKB3o7fWmAe1J9KXt05o+tAB+FJ60vvRQAUUDnpS00ACgUClHFABTlpo96eKAFHpTh3pB70o6GgBaKKB3oAPpQPej60DpQAoo60lKM+woAPpS0gxijNACUUZpM0AFLSUmaAFooo/lQAUUn8qO3SgBD9aQ0vammgApKO/FFAC/Sge9J2oFA0LSnrSUZoKQ5akWox6mpB09qktDh7U4U1T2pw6UikOFLSDigUhi06kFLSGhR0pR156Ug+tL9aQwHSnDim+uBTlpFIePenD1FNHTvTu1IpC/lR2pM8UtBQDpRQP0o9fSgBRR2oHtmj60ALQM+vSkpRQAo9KUdDTRThjtQA8U5fw5pq05cVIEq9KkU0xe9OX6UmUiZPepBx1qJOnrUg9/wADSKTHinD+tNGenNPX0qQuOWpFzzTFqRPrSGiVakXFRr0qRPSlYZItSJUa1KvFIpEo96kUdx1qJDxUq1BSHjkU4e1IvSlH4VI0LS9uDRSUtB3AY5Bp3H5UnqaB0xSBKyFz2HQUgFKOKTigQU0/hTucE0nY0CGkcc1GafntUZ6EVSCxG3fmoyeDUh9qifp1qkJkT9OM16R8DdRNtrz25c7XXOM/SvN36HFbPgC/Nl4mt2yRuOD+YrSGhlNXPryFsgGpwTVGwcSW8bA9QKugjFdMXocU1qL1607jFMBzS54NWmRYT6UlA6UVSYxG6VWkHWrJqGQcVMloXBmbdoGUg15N8TPDq3ls8ip8wHp9a9gmXINYGsWizxOrDgjFc7utTupJTVmfHN7btbTvGwIIOOapvXpXxM8OtZXjTRr8rGvN5BgkHtWqldXOKpFxk4sip6UzFSp096tamaJUU4PpU0S5ai1iklYJEpZj0xXoPg74dahqzpJNGyRe4qW7HRCHc5nS7F7iQCNGc+wJr6V+FVrNbeHkWZWXgYyKPC3gSw0hFZo1eTHp3rsIQkSiNAFUcVjJvqXa2xOvSjsaXHFNPTFJMSEPSmc804+lNPTFBSGP04qhcZySDV9vT2qlcDk8ipkjSJlXL4JyOlZtzLgcHkVo3fQkisS/JCscnpUWNEY2r3vLAkelcfeanGHbcwGK1tXLDdz2rzrX2dS2GOc4pJNuxsnyK51kF4t58sZz2x711mgeCZNQ2zXwMcR+6vr+HYVD8GvDUa6d/aF6peQnKA9MH2r1hCodNowF7V2QpR6l/WpcvumBF4WtLOFVSMAD9aZLoUJGWGBngdK6gfvX3Nzt6CsfUb2NJX3kfKcYFOpCCVwo16s3YoposRHIGKeNMhjJyqjA4pk2rBeEOc8VRuNT6ln5Irl5oo7IxrS3L8VvFIcqBVaWAbxjs2DUVpfbYFO7BIqWG5RS5fuapNMrlnFlmC1jZucYFWiwh3fLwKy/Pwku1jktkVKbtXifc3OKaaIlCUtzRDhgSeMiltLpQse/BOMZPfmsc3oKrgMeMcVTnuhHHgnaF71XtLErDOejOn1C/jljRVKthsfjWWmrWyxSqcIVfnPr61yrao43BQDg5BFUVuTISC4O85Iz09qzdW7N4YBRVmdbfatFcaeVaUDPBPrzXJzRme43lm8scfUZqa3ia5lKIPlAzmte00vc67j8o59KW+5V4UFZGHLpiTSpJah93cY/lUsWjPIxlZPmBx3rsYLJI3DLgEDtVvykVewP86EjhnjHfQ5KDRNqkuOvbFTxabHGcheQOK6CVM9cgAfnVZoSCM880GLrSa1KkUHX5alWHaOBmr0cPoD+NOEJ4z9KW5z8xniLgdAab5IwR7+laf2fOOmfpSPDke9Fhcxl+VgEc5qzCMKOvFOkgbd1GKkRMDvUjuTRcjBqZB61AnBwSefapgMfSncmxKMgc0c4yOvtTRx1yaXjFMQfWmfjTic8elRnjIwPypAhD061Hu9acf1FMf61LKVhQeOBSfzpF96UnAJFGwAPpSZwCaTnH9KQ4oEhG55NKOR7Uh6mkB9aENh+PSo3zjinkjmmE8H1zQxIZng4zUbnI46089+RUTEYIGM0raDRGe4PYZqNmGPahmz1NRuevoKQ0hpb2pjMecdKaX/MGmljgmmOw12447VBIcDmnFyQeKhkbnBFAtiN3x0x0xVaQ5HNSueOMVBK3Xpg0gIJMEHJNVnyMknpU0hPPTiqkjZPB4oTGtiORuCMGqrY696kkb5uSc1Xdu3pzTGNZshvXtVWTGDzU0jDnGeaquc5zTQhsjAr09qozsOxFWJG5IzxVKdupGKaEVZ24wOoqjcMcYY81blbjJxWdK/JJq0ZyehVuWG3AJrPlP6VbnbnAPWqm3c+BWiMZMW1hMkox2rftkITBHQVSsYO/pWnHjBznFKTuVGNh6kbeOgqIn72fwpxGATk0yQgJx1pJGlytOwRWIPNZFy42EZ5J/Sr9y42kYrJlzv57cVcUYzlZEYypCj8avWYzvyfujNUNxaTjGKvWOFgkY+uK3SOO+5Uf5pyfersJ/efUVUABYk/hVmH/W4z2rRCTJpfvimkDaPWnS43LSdvaqAo3XXrUC1buF4JNVQO1AizD0qdfSoIeF96mGeaAHg0zPJp3ao880APbofeqcvfirjdOlVJRzSAhxQPeg0mOtMBwz0o/pR/Kj1PpSAD0qF8VKfaom+tADO9JzS+tAxQAdvek+lO+tJQISj8aOtJn19aADFOX3xTactADxTlHbNNHtT060AXIPu81IcYqGE8VNQNEZ9yMdqYRUhpnY+1ADfYUmPUU7+dNOenpQAnf6036U6kNIELjimkZHSnY4pCKTGVpl6ntVUg1fkH+FVXXBPPsKkaIf1pPfHFOP603696BocOhp49KYPrTx0zQNEint1qWM+tQr0qROlSUiwp96epFRKfSpFpMZIv6U9eKav86cB70h2FFL70g/nSj2pCsOFOFNHSikA8E5p6niox9acp4pBYmX3p4PFQqeKcD780DsTA5pQaiB/CnA0AShsVIrVXzTg1Kw0iyrcU9WH51VDe/NPVvekUkXon561dhf3rKjb1NXYW75qWwsakUnvV6B6x4396vW71NzKSNiF+auRP+dZUTVdhei5hJGgjVIGqsjVIpouZ2JQacDjpUYNOouTYcWwKryOc1I3SoHByaLgkQyHrioG7k1O/U+lQsvHTimmNFeQ+4qs468VbdeKiKcHH40ykyrt70m3jP51Pso2VNwuQBKULip9gpdlK5NyAJT1UVLs4pAuKkVxAMU4D1o7dKBQTccKePwqMe9PFMdx46U8Go804HimmFyQEU4H0qNT704N0qkwH9qb25pM+9JmqTIEbviom7+lSE9cVEf0piGnpmmc88U49PrTe3vTJuN+tNPf3px69KQimhEX1pPyp5FMpisIOnFJntzTv5Unr6UrjQlKPejvScYpAOHvSg8U2kz696AJAevNJnr0qPIo3elFxkme1APHNR7qM+nakCRJnscUoPpUYPpSg/wCcUx2JBz+FJxzzSDpS80BYPpR60eoFAzRcQgpaXtS0XAKO9HTkUUXGJTTTjTTRcLDTTacabRcLCfSjv7UUUXGHFFJj3oouB4x3ooorqOsB7Uo6UnuKWkAUo6UfSjn1pAA6e1A6UfSihAFHejj15oxTAB3o/lR9KKACg0DpikoABQKKBQAlFFFACYpaSlouAUfSikpXAWgdaQdKWmAopKUdKT+tAB260UdqO2KAD60euOoooFABSgetJ7UtCAPY0D3ooNMA/CilpKACij60g6cUALR9aKBTAcBQKSl/OgBR15pwpop60AKOnrS0nNKKAFH86PbFJ60UAAooooAOaXikzRQAtANJQaADsaKKPpQAnel+lJ9aKACjtSUUAGaQketL25pPxoAKb9KX8aPrQAn0oFJS0AFFH0ooGhRQKQUooGhR3p46UwcU4cUrFpjxTgaYOlOFTYpEgP5UtMGMU4UikOFKKaKUUDH0Ckpe2RU2GL60opopR0zRYaY8GnA/lUQINKKLFpko9zSg8VGD6nNKD+VFh3JOMUcdqYDS5osFx3HNGe3akBoosFxR7U4U0Uo5FIBacMYyM5popy+gpAOFPX60xQTxTx0zUhckWpB9elRoe1PHoT1p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";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/math.js */ "./src/js/math.js");
/* harmony import */ var _js_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/element.js */ "./src/js/element.js");
/* harmony import */ var vue_dist_vue_esm_bundler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue/dist/vue.esm-bundler */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _vue_App_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vue/App.vue */ "./src/vue/App.vue");
//ES Module

 ////vue.runtime.esm-bundler.js


 // commonjs

var _require = __webpack_require__(/*! ./js/format.js */ "./src/js/format.js"),
    priceForamt = _require.priceForamt;

console.log((0,_js_math_js__WEBPACK_IMPORTED_MODULE_0__.sum)(1, 2));
console.log(priceForamt()); // const app = createApp({
//     template: "#my-app",
//     data() {
//         return {
//             title: 'hello world',
//         }
//     }
// })
// SFC

var app = (0,vue_dist_vue_esm_bundler__WEBPACK_IMPORTED_MODULE_2__.createApp)(_vue_App_vue__WEBPACK_IMPORTED_MODULE_3__["default"]);
app.mount('#app');
})();

/******/ })()
;
//# sourceMappingURL=bundle.js.map